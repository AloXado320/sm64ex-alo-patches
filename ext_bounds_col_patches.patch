diff --git a/data/behavior_data.c b/data/behavior_data.c
index 17d3adb..0d1cc8c 100644
--- a/data/behavior_data.c
+++ b/data/behavior_data.c
@@ -5546,7 +5546,11 @@ const BehaviorScript bhvTTCPendulum[] = {
 
 const BehaviorScript bhvTTCTreadmill[] = {
     BEGIN(OBJ_LIST_SURFACE),
+#ifdef PLATFORM_DISPLACEMENT_2
+    OR_INT(oFlags, (OBJ_FLAG_COMPUTE_DIST_TO_MARIO | OBJ_FLAG_UPDATE_GFX_POS_AND_ANGLE | OBJ_FLAG_VELOCITY_PLATFORM)),
+#else
     OR_INT(oFlags, (OBJ_FLAG_COMPUTE_DIST_TO_MARIO | OBJ_FLAG_UPDATE_GFX_POS_AND_ANGLE)),
+#endif
     SET_FLOAT(oCollisionDistance, 750),
     CALL_NATIVE(bhv_ttc_treadmill_init),
     DELAY(1),
diff --git a/include/config.h b/include/config.h
index a34d9c1..d832e11 100644
--- a/include/config.h
+++ b/include/config.h
@@ -11,6 +11,9 @@
 // Qol Defines
 #include "qol_defines.h"
 
+// Ext bounds
+#include "src/engine/extended_bounds.h"
+
 // Bug Fixes
 // --| Post-JP Version Nintendo Bug Fixes
 /// Fixes bug where obtaining over 999 coins sets the number of lives to 999 (or -25)
diff --git a/include/object_constants.h b/include/object_constants.h
index 9f5e8c6..5d60ad0 100644
--- a/include/object_constants.h
+++ b/include/object_constants.h
@@ -43,7 +43,7 @@
 #define OBJ_FLAG_1000                             (1 << 12) // 0x00001000
 #define OBJ_FLAG_COMPUTE_ANGLE_TO_MARIO           (1 << 13) // 0x00002000
 #define OBJ_FLAG_PERSISTENT_RESPAWN               (1 << 14) // 0x00004000
-#define OBJ_FLAG_8000                             (1 << 15) // 0x00008000
+#define OBJ_FLAG_VELOCITY_PLATFORM                (1 << 15) // 0x00008000 - Used in PLATFORM_DISPLACEMENT_2
 #define OBJ_FLAG_DONT_CALC_COLL_DIST              (1 << 16) // 0x00010000 - Used in QOL_FEATURES
 #define OBJ_FLAG_30                               (1 << 30) // 0x40000000
 
diff --git a/include/sm64.h b/include/sm64.h
index 75de983..ccb753e 100644
--- a/include/sm64.h
+++ b/include/sm64.h
@@ -88,6 +88,7 @@ int strcmp(char *s, char *t);
 #define AIR_STEP_GRABBED_LEDGE   3
 #define AIR_STEP_GRABBED_CEILING 4
 #define AIR_STEP_HIT_LAVA_WALL   6
+#define AIR_STEP_HIT_CEILING     8
 
 #define WATER_STEP_NONE        0
 #define WATER_STEP_HIT_FLOOR   1
diff --git a/include/surface_terrains.h b/include/surface_terrains.h
index f555d5b..000a62e 100644
--- a/include/surface_terrains.h
+++ b/include/surface_terrains.h
@@ -4,6 +4,8 @@
 // Surface Types
 #define SURFACE_DEFAULT                      0x0000 // Environment default
 #define SURFACE_BURNING                      0x0001 // Lava / Frostbite (in SL), but is used mostly for Lava
+#define SURFACE_NEW_WATER                    0x0002 // Custom water surface
+#define SURFACE_NEW_WATER_BOTTOM             0x0003 // Custom water surface bottom marker
 #define SURFACE_0004                         0x0004 // Unused, has no function and has parameters
 #define SURFACE_HANGABLE                     0x0005 // Ceiling that Mario can climb on
 #define SURFACE_SLOW                         0x0009 // Slow down Mario, unused
diff --git a/include/types.h b/include/types.h
index c44e154..db1e12a 100644
--- a/include/types.h
+++ b/include/types.h
@@ -334,6 +334,9 @@ struct MarioState {
     /*0xBC*/ f32 peakHeight;
     /*0xC0*/ f32 quicksandDepth;
     /*0xC4*/ f32 unkC4;
+#ifdef CENTERED_COLLISION
+             f32 midY;
+#endif
     #ifdef PORT_MOP_OBJS
 	/*0xd4*/ u8 SelFallDmg; //For certain objects I don't want fall damage ever
     #endif
diff --git a/src/engine/extended_bounds.h b/src/engine/extended_bounds.h
new file mode 100644
index 0000000..764ca4a
--- /dev/null
+++ b/src/engine/extended_bounds.h
@@ -0,0 +1,212 @@
+#ifndef EXTENDED_BOUNDS_H
+#define EXTENDED_BOUNDS_H
+
+/*
+    Better Extended Bounds + Collsion Patches
+        Thanks to anonymous_moose for the original Better Extended Bounds patch
+        Thanks to someone2639 for the shiftable segments patch
+        Thanks to Wiseguy for the Surface Pool Full error code and 4x bounds fix
+        Thanks to FramePerfection/chaosBrick for the wall collision rewrite
+        Thanks to Arthurtilly for the platform displacement rewrite
+        Thanks to falcobuster for the long render distance fix
+        Thanks to JoshDuman, Kaze, Arceveti and various people for the QoL collision code changes
+        Patch compilated by AloXado320
+
+    0: Regular bounds
+        Same as vanilla sm64, boundaries are (-8192 to 8191)
+        16x16 collision cells.
+    1: Regular bounds (performance)
+        Same boundaries as vanilla (-8192 to 8191), but with twice the amount of collision cells
+        Trades more RAM usage for faster collision calculations.
+    2: 2x extended bounds
+        level boundaries are twice as big (-16384 to 16383)
+        Collision calculations remain as fast as vanilla, at the cost of using more RAM.
+        32x32 collision cells.
+    3: 4x extended bounds
+        level boundaries are 4 times as big (-32768 to 32767)
+        Collision calculations remain as fast as vanilla, at the cost of using far more RAM (16 times vanilla).
+        64x64 collision cells.
+    4: 4x extended bounds (Memory saver)
+        level boundaries are 4 times as big (-32768 to 32767)
+        Collision cells are the same size as vanilla, at the cost of being much slower.
+        32x32 collision cells.
+
+    If you see "SURFACE POOL FULL" or "SURFACE NODE POOL FULL" in game, you should increase
+    SURFACE_POOL_SIZE or SURFACE_NODE_POOL_SIZE, respectively, or reduce the amount of
+    collision surfaces in your level.
+*/
+
+//set this to the extended bounds mode you want, then do "make clean".
+#define EXTENDED_BOUNDS_MODE 3
+
+// Coordinate overflow fix by falcobuster (World Scale).
+// Your levels will render correctly on console and LLE emulators
+// even when using 2x or 4x bounds, while not hurting anything on HLE plugins.
+
+// SURFACE_POOL_SIZE and SURFACE_NODE_POOL_SIZE only matter on N64
+// On non-N64 targets, surface sizes are allocated using SYSTEM_MALLOC
+// If SYSTEM_MALLOC is not defined on PC Port, then fixed pools are used instead
+
+// SURFACE_POOL_SIZE
+// The maximum amount of collision surfaces (static and dynamic combined)
+// The vanilla value is 2300
+
+// SURFACE_NODE_POOL_SIZE
+// Make this approximately (amount of collision cells) + (SURFACE_POOL_SIZE * 3)
+// The vanilla value is 7000
+
+// Cell and height limits
+// Default cell/floor limit is 20000/-11000 respectively
+#define CELL_HEIGHT_LIMIT           20000
+#define FLOOR_LOWER_LIMIT           -11000
+#define FLOOR_LOWER_LIMIT_MISC      (FLOOR_LOWER_LIMIT + 1000)
+#define FLOOR_LOWER_LIMIT_SHADOW    FLOOR_LOWER_LIMIT_MISC
+
+/* Miscellaneous Tweaks */
+
+// Show ingame text info if any surface pool is full (N64 and Non-sys malloc only)
+#ifndef SYSTEM_MALLOC
+#define SURFACE_POOLS_FULL_MESSAGES
+
+#ifdef SURFACE_POOLS_FULL_MESSAGES
+// Sanity checks if pool gets past the size
+#define NOT_ENOUGH_ROOM_FOR_SURFACES (1 << 0)
+#define NOT_ENOUGH_ROOM_FOR_NODES    (1 << 1)
+#endif
+
+#endif
+
+// Set vanilla camera course specific functions
+#define CAMERA_SPECIFIC_FUNCTION_DEFINES
+
+// Platform displacement 2 also known as momentum patch.
+// Makes Mario keep the momemtum from moving platforms.
+// Doesn't break treadmills anymore!
+// (Arthurtilly, HackerSM64)
+#define PLATFORM_DISPLACEMENT_2
+
+// Water surfaces (Thecozies)
+#define NEW_WATER_SURFACES
+
+// Improved wall collision detection, with rounded corners
+// Fixes Mario jittering when walking into multiple walls at once
+// (frameperfection/Frame#5375)
+#define BETTER_WALL_COLLISION
+
+// Ceiling margin from BWC
+// (frameperfection/Frame#5375)
+#define CEILING_MARGINS
+
+// For static floor checks only
+#define FIND_FLOOR_EXCLUDE_DYNAMIC_CHECK
+
+// Push Mario out of sloped ceilings instead of stopping or bonking
+// helps prevent unwanted bonks and softlocks
+// (Arceveti)
+#define BETTER_CEILING_HANDLING
+
+// Properly fixes false ledge grabs
+// Does nothing if BETTER_WALL_COLLISION is enabled.
+// (Arceveti)
+#define FIX_LEDGE_GRABS
+
+// Experimental: Automatic World Scale
+//#define AUTOMATIC_WORLD_SCALE
+
+// Check for floors/ceilings from halfway up Mario's hitbox rather than from the bottom
+// (Arceveti)
+#define CENTERED_COLLISION
+
+#ifdef CENTERED_COLLISION
+// Step height for objects. Comment out the define to use vanilla behavior. (Arceveti)
+#define OBJ_STEP_HEIGHT 40.0f
+#endif
+
+// Maximum number of walls to check (vanilla is 4, higher is recommended)
+#define MAX_REFEREMCED_WALLS 16
+
+// Include steep floors when checking for walls when underwater
+// This fixes the weirdness caused by swimming into such slopes (as seen with the JRB pillars in vanilla)
+// May cause performance issues when underwater due to also iterating through the floors partition
+// in addition to the regular walls partition when checking wall collisions.
+// (Arceveti)
+#define UNDERWATER_STEEP_FLOORS_AS_WALLS
+#define MIN_UNDERWATER_FLOOR_NORMAL_Y 0.1f
+
+// Minimum Y normal for floors (vanilla is 0.01f)
+#define MIN_FLOOR_NORMAL_Y 0.02f
+
+// Minimum Y normal for ceilings (vanilla is -0.01f, -0.2f is recommended)
+#define MAX_CEIL_NORMAL_Y -0.2f
+
+// Number of null floors to check ahead through during a qstep.
+// Fixes many instances of invisible walls but may cause minor
+// issues on actual level boundaries, such as extra knockback
+// (Arceveti)
+#define NULL_FLOOR_STEPS 4
+
+// Number of swimming steps per frame (Vanilla is 1)
+#define WATER_NUM_STEPS  4
+
+// Number of ground steps per frame (Vanilla is 4)
+#define GROUND_NUM_STEPS 4
+
+// Number of air steps per frame (Vanilla is 4)
+#define AIR_NUM_STEPS    4
+
+/* Don't touch the stuff past this point unless you know what you're doing! */
+
+// Default value to check if the user set a proper extended bounds mode
+#define LEVEL_BOUNDARY_MAX 0x0000
+
+// Scales the world down by this factor, increasing how far you can render on
+// console (and PC) in exchange for a slight loss in precision.
+#define WORLD_SCALE 1.0f
+
+#if EXTENDED_BOUNDS_MODE == 0 // Vanilla
+    #undef LEVEL_BOUNDARY_MAX // Undefine the old value to avoid compiler warnings
+    #undef WORLD_SCALE
+    #define LEVEL_BOUNDARY_MAX      0x2000L
+    #define CELL_SIZE               0x400
+    #define SURFACE_POOL_SIZE       4000
+    #define SURFACE_NODE_POOL_SIZE  12000
+    #define WORLD_SCALE             1.0f
+    #define 
+#elif EXTENDED_BOUNDS_MODE == 1 // Vanilla size with performance but more RAM usage
+    #undef LEVEL_BOUNDARY_MAX
+    #undef WORLD_SCALE
+    #define LEVEL_BOUNDARY_MAX      0x2000L
+    #define CELL_SIZE               0x200
+    #define SURFACE_POOL_SIZE       4000
+    #define SURFACE_NODE_POOL_SIZE  16000
+    #define WORLD_SCALE             1.0f
+#elif EXTENDED_BOUNDS_MODE == 2 // 2x bounds
+    #undef LEVEL_BOUNDARY_MAX
+    #undef WORLD_SCALE
+    #define LEVEL_BOUNDARY_MAX      0x4000L
+    #define CELL_SIZE               0x400
+    #define SURFACE_POOL_SIZE       8200
+    #define SURFACE_NODE_POOL_SIZE  22000
+    #define WORLD_SCALE             2.0f
+#elif EXTENDED_BOUNDS_MODE == 3 // 4x bounds
+    #undef LEVEL_BOUNDARY_MAX
+    #undef WORLD_SCALE
+    #define LEVEL_BOUNDARY_MAX      0x8000L
+    #define CELL_SIZE               0x400
+    #define SURFACE_POOL_SIZE       8200
+    #define SURFACE_NODE_POOL_SIZE  24600
+    #define WORLD_SCALE             4.0f
+#elif EXTENDED_BOUNDS_MODE == 4 // 4x bounds with big cells (similar to old ext bounds)
+    #undef LEVEL_BOUNDARY_MAX
+    #undef WORLD_SCALE
+    #define LEVEL_BOUNDARY_MAX      0x8000L
+    #define CELL_SIZE               0x800
+    #define SURFACE_POOL_SIZE       8200
+    #define SURFACE_NODE_POOL_SIZE  20600
+    #define WORLD_SCALE             4.0f
+#endif
+
+#define NUM_CELLS (2 * LEVEL_BOUNDARY_MAX / CELL_SIZE)
+#define NUM_CELLS_INDEX (NUM_CELLS - 1)
+
+#endif // EXTENDED_BOUNDS_H
diff --git a/src/engine/math_util.c b/src/engine/math_util.c
index 378a54f..de952b0 100644
--- a/src/engine/math_util.c
+++ b/src/engine/math_util.c
@@ -4,7 +4,7 @@
 #include "engine/graph_node.h"
 #include "math_util.h"
 #include "surface_collision.h"
-
+#include "game/rendering_graph_node.h"
 #include "trig_tables.inc.c"
 
 // Variables for a spline curve animation (used for the flight path in the grand star cutscene)
@@ -630,22 +630,19 @@ void mtxf_mul_vec3s(Mat4 mtx, Vec3s b) {
  * and no crashes occur.
  */
 void mtxf_to_mtx(Mtx *dest, Mat4 src) {
-#ifdef AVOID_UB
-    // Avoid type-casting which is technically UB by calling the equivalent
-    // guMtxF2L function. This helps little-endian systems, as well.
-    guMtxF2L(src, dest);
+#if EXTENDED_BOUNDS_MODE > 1
+	Mat4 temp;
+	register s32 i, j;
+	for( i = 0; i < 4; i++ ) {
+		for( j = 0; j < 3; j++ ) {
+			temp[i][j] = src[i][j] / gWorldScale;
+		}
+		temp[i][3] = src[i][3];
+	}
+
+	guMtxF2L(temp, dest);
 #else
-    s32 asFixedPoint;
-    register s32 i;
-    register s16 *a3 = (s16 *) dest;      // all integer parts stored in first 16 bytes
-    register s16 *t0 = (s16 *) dest + 16; // all fraction parts stored in last 16 bytes
-    register f32 *t1 = (f32 *) src;
-
-    for (i = 0; i < 16; i++) {
-        asFixedPoint = *t1++ * (1 << 16); //! float-to-integer conversion responsible for PU crashes
-        *a3++ = GET_HIGH_S16_OF_32(asFixedPoint); // integer part
-        *t0++ = GET_LOW_S16_OF_32(asFixedPoint);  // fraction part
-    }
+    guMtxF2L(temp, dest);
 #endif
 }
 
diff --git a/src/engine/surface_collision.c b/src/engine/surface_collision.c
index 46b2385..3472fff 100644
--- a/src/engine/surface_collision.c
+++ b/src/engine/surface_collision.c
@@ -5,6 +5,7 @@
 #include "game/level_update.h"
 #include "game/mario.h"
 #include "game/object_list_processor.h"
+#include "game/rendering_graph_node.h"
 #include "surface_collision.h"
 #include "surface_load.h"
 #include "math_util.h"
@@ -13,149 +14,274 @@
 #include "extras/cheats.h"
 #endif
 
+// moved from extended_bounds.h to here since STATIC_ASSERT makes sense in a C file
+STATIC_ASSERT(LEVEL_BOUNDARY_MAX != 0, "You must set a valid extended bounds mode!");
+
 /**************************************************
  *                      WALLS                     *
  **************************************************/
 
+static u32 is_outside_level_bounds(f32 x, f32 z) {
+    return ((x <= -LEVEL_BOUNDARY_MAX)
+         || (x >=  LEVEL_BOUNDARY_MAX)
+         || (z <= -LEVEL_BOUNDARY_MAX)
+         || (z >=  LEVEL_BOUNDARY_MAX));
+}
+
+/*
+void move_towards_wall(struct MarioState *m, f32 amount) {
+    m->vel[0] += (m->wall->normal.x * amount);
+    m->vel[1] += (m->wall->normal.y * amount);
+    m->vel[2] += (m->wall->normal.z * amount);
+}
+*/
+
 /**
  * Iterate through the list of walls until all walls are checked and
  * have given their wall push.
  */
+#ifdef BETTER_WALL_COLLISION
 static s32 find_wall_collisions_from_list(struct SurfaceNode *surfaceNode, struct WallCollisionData *data) {
+    const f32 corner_threshold = (-0.9f);
     register struct Surface *surf;
     register f32 offset;
     register f32 radius = data->radius;
-    register f32 x = data->x;
-    register f32 y = data->y + data->offsetY;
-    register f32 z = data->z;
-    register f32 px, pz;
-    register f32 w1, w2, w3;
-    register f32 y1, y2, y3;
+    register f32 x      =  data->x;
+    register f32 y      = (data->y + data->offsetY);
+    register f32 z      =  data->z;
+    register f32 v0x, v0y, v0z;
+    register f32 v1x, v1y, v1z;
+    register f32 v2x, v2y, v2z;
+    register f32 d00, d01, d11, d20, d21;
+    register f32 invDenom;
+    register f32 v, w;
+    register f32 margin_radius = (radius - 1.0f);
+    register s16 type = SURFACE_DEFAULT;
     s32 numCols = 0;
-
+ //#if EXTENDED_BOUNDS_MODE > 1
+ //   const float down_scale = (1.0f / gWorldScale);
+ //   radius        *= down_scale;
+ //   x             *= down_scale;
+ //   y             *= down_scale;
+ //   z             *= down_scale;
+ //   margin_radius *= down_scale;
+ //#endif
     // Max collision radius = 200
-    if (radius > 200.0f) {
-        radius = 200.0f;
-    }
-
+    if (radius > 200.0f) radius = 200.0f;
     // Stay in this loop until out of walls.
     while (surfaceNode != NULL) {
-        surf = surfaceNode->surface;
+        surf        = surfaceNode->surface;
         surfaceNode = surfaceNode->next;
-
+        type        = surf->type;
         // Exclude a large number of walls immediately to optimize.
-        if (y < surf->lowerY || y > surf->upperY) {
-            continue;
+ #ifdef NEW_WATER_SURFACES
+        if ((type == SURFACE_NEW_WATER) || (type == SURFACE_NEW_WATER_BOTTOM)) continue;
+ #endif
+        // Determine if checking for the camera or not.
+        if (gCheckingSurfaceCollisionsForCamera) {
+            if (surf->flags & SURFACE_FLAG_NO_CAM_COLLISION) continue;
+        } else {
+            // Ignore camera only surfaces.
+            if (type == SURFACE_CAMERA_BOUNDARY) continue;
+            // If an object can pass through a vanish cap wall, pass through.
+            if ((type == SURFACE_VANISH_CAP_WALLS) && (gCurrentObject != NULL)) {
+                // If an object can pass through a vanish cap wall, pass through.
+                if (gCurrentObject->activeFlags & ACTIVE_FLAG_MOVE_THROUGH_GRATE) continue;
+                // If Mario has a vanish cap, pass through the vanish cap wall.
+                if ((gCurrentObject == gMarioObject) && (gMarioState->flags & MARIO_VANISH_CAP)) continue;
+            }
         }
-
-        offset = surf->normal.x * x + surf->normal.y * y + surf->normal.z * z + surf->originOffset;
-
-        if (offset < -radius || offset > radius) {
-            continue;
+        if ((y < surf->lowerY) || (y > surf->upperY)) continue;
+ #ifdef UNDERWATER_STEEP_FLOORS_AS_WALLS
+        if (gIncludeSteepFloorsInWallCollisionCheck && (surf->normal.y > MIN_UNDERWATER_FLOOR_NORMAL_Y)) continue;
+ #endif
+        // Dot of normal and pos, + originOffset
+        offset = ((surf->normal.x * x) + (surf->normal.y * y) + (surf->normal.z * z) + surf->originOffset);
+        if ((offset < -radius) || (offset > radius)) continue;
+        v0x = (f32)(surf->vertex2[0] -      surf->vertex1[0]);
+        v0y = (f32)(surf->vertex2[1] -      surf->vertex1[1]);
+        v0z = (f32)(surf->vertex2[2] -      surf->vertex1[2]);
+        v1x = (f32)(surf->vertex3[0] -      surf->vertex1[0]);
+        v1y = (f32)(surf->vertex3[1] -      surf->vertex1[1]);
+        v1z = (f32)(surf->vertex3[2] -      surf->vertex1[2]);
+        v2x =                      x - (f32)surf->vertex1[0];
+        v2y =                      y - (f32)surf->vertex1[1];
+        v2z =                      z - (f32)surf->vertex1[2];
+        // Face
+        d00 = (   sqr(v0x) +    sqr(v0y) +    sqr(v0z));
+        d01 = ((v0x * v1x) + (v0y * v1y) + (v0z * v1z));
+        d11 = (   sqr(v1x) +    sqr(v1y) +    sqr(v1z));
+        d20 = ((v2x * v0x) + (v2y * v0y) + (v2z * v0z));
+        d21 = ((v2x * v1x) + (v2y * v1y) + (v2z * v1z));
+        invDenom = (1.0f / ((d00 * d11) - (d01 * d01)));
+        v = (((d11 * d20) - (d01 * d21)) * invDenom);
+        if ((v < 0.0f) || (v > 1.0f)) goto edge_1_2;
+        w = (((d00 * d21) - (d01 * d20)) * invDenom);
+        if ((w < 0.0f) || (w > 1.0f) || ((v + w) > 1.0f)) goto edge_1_2;
+        x += (surf->normal.x * (radius - offset));
+        z += (surf->normal.z * (radius - offset));
+        goto hasCollision;
+    edge_1_2:
+        if (offset < 0) continue;
+        // Edge 1-2
+        if (v0y != 0.0f) {
+            v = (v2y / v0y);
+            if ((v < 0.0f) || (v > 1.0f)) goto edge_1_3;
+            d00 = ((v0x * v) - v2x);
+            d01 = ((v0z * v) - v2z);
+            invDenom = sqrtf(sqr(d00) + sqr(d01));
+            offset   = (invDenom - margin_radius);
+            if (offset > 0.0f) goto edge_1_3;
+            invDenom = (offset / invDenom);
+            x += (d00 *= invDenom);
+            z += (d01 *= invDenom);
+            margin_radius += 0.01f;
+            if ((d00 * surf->normal.x) + (d01 * surf->normal.z) < (corner_threshold * offset)) {
+                continue;
+            } else {
+                goto hasCollision;
+            }
         }
-
-        px = x;
-        pz = z;
-
-        //! (Quantum Tunneling) Due to issues with the vertices walls choose and
-        //  the fact they are floating point, certain floating point positions
-        //  along the seam of two walls may collide with neither wall or both walls.
-        if (surf->flags & SURFACE_FLAG_X_PROJECTION) {
-            w1 = -surf->vertex1[2];           w2 = -surf->vertex2[2];           w3 = -surf->vertex3[2];
-            y1 = surf->vertex1[1];            y2 = surf->vertex2[1];            y3 = surf->vertex3[1];
-
-            if (surf->normal.x > 0.0f) {
-                if ((y1 - y) * (w2 - w1) - (w1 - -pz) * (y2 - y1) > 0.0f) {
-                    continue;
-                }
-                if ((y2 - y) * (w3 - w2) - (w2 - -pz) * (y3 - y2) > 0.0f) {
-                    continue;
-                }
-                if ((y3 - y) * (w1 - w3) - (w3 - -pz) * (y1 - y3) > 0.0f) {
-                    continue;
-                }
+    edge_1_3:
+        // Edge 1-3
+        if (v1y != 0.0f) {
+            v = (v2y / v1y);
+            if ((v < 0.0f) || (v > 1.0f)) goto edge_2_3;
+            d00 = ((v1x * v) - v2x);
+            d01 = ((v1z * v) - v2z);
+            invDenom = sqrtf(sqr(d00) + sqr(d01));
+            offset   = (invDenom - margin_radius);
+            if (offset > 0.0f) goto edge_2_3;
+            invDenom = (offset / invDenom);
+            x += (d00 *= invDenom);
+            z += (d01 *= invDenom);
+            margin_radius += 0.01f;
+            if ((d00 * surf->normal.x) + (d01 * surf->normal.z) < (corner_threshold * offset)) {
+                continue;
             } else {
-                if ((y1 - y) * (w2 - w1) - (w1 - -pz) * (y2 - y1) < 0.0f) {
-                    continue;
-                }
-                if ((y2 - y) * (w3 - w2) - (w2 - -pz) * (y3 - y2) < 0.0f) {
-                    continue;
-                }
-                if ((y3 - y) * (w1 - w3) - (w3 - -pz) * (y1 - y3) < 0.0f) {
-                    continue;
-                }
+                goto hasCollision;
             }
-        } else {
-            w1 = surf->vertex1[0];            w2 = surf->vertex2[0];            w3 = surf->vertex3[0];
-            y1 = surf->vertex1[1];            y2 = surf->vertex2[1];            y3 = surf->vertex3[1];
-
-            if (surf->normal.z > 0.0f) {
-                if ((y1 - y) * (w2 - w1) - (w1 - px) * (y2 - y1) > 0.0f) {
-                    continue;
-                }
-                if ((y2 - y) * (w3 - w2) - (w2 - px) * (y3 - y2) > 0.0f) {
-                    continue;
-                }
-                if ((y3 - y) * (w1 - w3) - (w3 - px) * (y1 - y3) > 0.0f) {
-                    continue;
-                }
+        }
+    edge_2_3:
+        // Edge 2-3
+        v1x = (f32)(surf->vertex3[0] -      surf->vertex2[0]);
+        v1y = (f32)(surf->vertex3[1] -      surf->vertex2[1]);
+        v1z = (f32)(surf->vertex3[2] -      surf->vertex2[2]);
+        v2x =                      x - (f32)surf->vertex2[0];
+        v2y =                      y - (f32)surf->vertex2[1];
+        v2z =                      z - (f32)surf->vertex2[2];
+        if (v1y != 0.0f) {
+            v = (v2y / v1y);
+            if ((v < 0.0f) || (v > 1.0f)) continue;
+            d00 = ((v1x * v) - v2x);
+            d01 = ((v1z * v) - v2z);
+            invDenom = sqrtf(sqr(d00) + sqr(d01));
+            offset   = (invDenom - margin_radius);
+            if (offset > 0.0f) continue;
+            invDenom = (offset / invDenom);
+            x += (d00 *= invDenom);
+            z += (d01 *= invDenom);
+            margin_radius += 0.01f;
+            if ((d00 * surf->normal.x) + (d01 * surf->normal.z) < (corner_threshold * offset)) {
+                continue;
             } else {
-                if ((y1 - y) * (w2 - w1) - (w1 - px) * (y2 - y1) < 0.0f) {
-                    continue;
-                }
-                if ((y2 - y) * (w3 - w2) - (w2 - px) * (y3 - y2) < 0.0f) {
-                    continue;
-                }
-                if ((y3 - y) * (w1 - w3) - (w3 - px) * (y1 - y3) < 0.0f) {
-                    continue;
-                }
+                goto hasCollision;
             }
+        } else {
+            continue;
         }
+    hasCollision:
+        if (data->numWalls < MAX_REFEREMCED_WALLS) data->walls[data->numWalls++] = surf;
+        numCols++;
+    }
+ //#if EXTENDED_BOUNDS_MODE > 1
+ //   x *= gWorldScale;
+ //   y *= gWorldScale;
+ //   z *= gWorldScale;
+ //#endif
+    data->x = x;
+    data->z = z;
 
+    return numCols;
+}
+#else
+static s32 find_wall_collisions_from_list(struct SurfaceNode *surfaceNode, struct WallCollisionData *data) {
+    register struct Surface *surf;
+    register f32 offset;
+    register f32 radius = data->radius;
+    // these are f32 in vanilla
+    register s32 x =  data->x;
+    register s32 y = (data->y + data->offsetY);
+    register s32 z =  data->z;
+    register s32 w1, w2, w3;
+    register s32 y1, y2, y3;
+    s32 numCols = 0;
+    s16 type = SURFACE_DEFAULT;
+    // Max collision radius = 200
+    if (radius > 200.0f) radius = 200.0f;
+    // Stay in this loop until out of walls.
+    while (surfaceNode != NULL) {
+        surf        = surfaceNode->surface;
+        surfaceNode = surfaceNode->next;
+        type        = surf->type;
+ #ifdef NEW_WATER_SURFACES
+        if ((type == SURFACE_NEW_WATER) || (type == SURFACE_NEW_WATER_BOTTOM)) continue;
+ #endif
         // Determine if checking for the camera or not.
         if (gCheckingSurfaceCollisionsForCamera) {
-            if (surf->flags & SURFACE_FLAG_NO_CAM_COLLISION) {
-                continue;
-            }
+            if (surf->flags & SURFACE_FLAG_NO_CAM_COLLISION) continue;
         } else {
             // Ignore camera only surfaces.
-            if (surf->type == SURFACE_CAMERA_BOUNDARY) {
-                continue;
-            }
-
+            if (type == SURFACE_CAMERA_BOUNDARY) continue;
             // If an object can pass through a vanish cap wall, pass through.
-            if (surf->type == SURFACE_VANISH_CAP_WALLS) {
+            if ((type == SURFACE_VANISH_CAP_WALLS) && (gCurrentObject != NULL)) {
                 // If an object can pass through a vanish cap wall, pass through.
-                if (gCurrentObject != NULL
-                    && (gCurrentObject->activeFlags & ACTIVE_FLAG_MOVE_THROUGH_GRATE)) {
-                    continue;
-                }
-
+                if (gCurrentObject->activeFlags & ACTIVE_FLAG_MOVE_THROUGH_GRATE) continue;
                 // If Mario has a vanish cap, pass through the vanish cap wall.
-                if (gCurrentObject != NULL && gCurrentObject == gMarioObject
-                    && (gMarioState->flags & MARIO_VANISH_CAP)) {
-                    continue;
-                }
+                if ((gCurrentObject == gMarioObject) && (gMarioState->flags & MARIO_VANISH_CAP)) continue;
             }
         }
-
-        //! (Wall Overlaps) Because this doesn't update the x and z local variables,
-        //  multiple walls can push mario more than is required.
-        data->x += surf->normal.x * (radius - offset);
-        data->z += surf->normal.z * (radius - offset);
-
-        //! (Unreferenced Walls) Since this only returns the first four walls,
-        //  this can lead to wall interaction being missed. Typically unreferenced walls
-        //  come from only using one wall, however.
-        if (data->numWalls < 4) {
-            data->walls[data->numWalls++] = surf;
+        if ((y < surf->lowerY) || (y > surf->upperY)) continue;
+        // Exclude a large number of walls immediately to optimize.
+        offset = ((surf->normal.x * x) + (surf->normal.y * y) + (surf->normal.z * z) + surf->originOffset);
+        if ((offset < -radius) || (offset > radius))  continue;
+        //  (Quantum Tunneling) Due to issues with the vertices walls choose
+        //  and the fact they are floating point, certain floating point positions
+        //  along the seam of two walls may collide with neither wall or both walls.
+        y1 = surf->vertex1[1]; y2 = surf->vertex2[1]; y3 = surf->vertex3[1];
+        if (surf->flags & SURFACE_FLAG_X_PROJECTION) {
+            w1 = -surf->vertex1[2]; w2 = -surf->vertex2[2]; w3 = -surf->vertex3[2];
+            if (surf->normal.x > 0.0f) {
+                if (((y1 - y) * (w2 - w1)) - ((w1 - -z) * (y2 - y1)) > 0) continue;
+                if (((y2 - y) * (w3 - w2)) - ((w2 - -z) * (y3 - y2)) > 0) continue;
+                if (((y3 - y) * (w1 - w3)) - ((w3 - -z) * (y1 - y3)) > 0) continue;
+            } else {
+                if (((y1 - y) * (w2 - w1)) - ((w1 - -z) * (y2 - y1)) < 0) continue;
+                if (((y2 - y) * (w3 - w2)) - ((w2 - -z) * (y3 - y2)) < 0) continue;
+                if (((y3 - y) * (w1 - w3)) - ((w3 - -z) * (y1 - y3)) < 0) continue;
+            }
+        } else {
+            w1 =  surf->vertex1[0]; w2 =  surf->vertex2[0]; w3 =  surf->vertex3[0];
+            if (surf->normal.z > 0.0f) {
+                if (((y1 - y) * (w2 - w1)) - ((w1 -  x) * (y2 - y1)) > 0) continue;
+                if (((y2 - y) * (w3 - w2)) - ((w2 -  x) * (y3 - y2)) > 0) continue;
+                if (((y3 - y) * (w1 - w3)) - ((w3 -  x) * (y1 - y3)) > 0) continue;
+            } else {
+                if (((y1 - y) * (w2 - w1)) - ((w1 -  x) * (y2 - y1)) < 0) continue;
+                if (((y2 - y) * (w3 - w2)) - ((w2 -  x) * (y3 - y2)) < 0) continue;
+                if (((y3 - y) * (w1 - w3)) - ((w3 -  x) * (y1 - y3)) < 0) continue;
+            }
         }
-
+        x += (surf->normal.x * (radius - offset));
+        z += (surf->normal.z * (radius - offset));
+        data->x = x;
+        data->z = z;
+        if (data->numWalls < MAX_REFEREMCED_WALLS) data->walls[data->numWalls++] = surf;
         numCols++;
     }
-
     return numCols;
 }
+#endif
 
 /**
  * Formats the position and wall search for find_wall_collisions.
@@ -187,33 +313,34 @@ s32 f32_find_wall_collision(f32 *xPtr, f32 *yPtr, f32 *zPtr, f32 offsetY, f32 ra
  */
 s32 find_wall_collisions(struct WallCollisionData *colData) {
     struct SurfaceNode *node;
-    s16 cellX, cellZ;
     s32 numCollisions = 0;
-    s16 x = colData->x;
-    s16 z = colData->z;
+    s32 x = colData->x;
+    s32 z = colData->z;
 
     colData->numWalls = 0;
 
-    if (x <= -LEVEL_BOUNDARY_MAX || x >= LEVEL_BOUNDARY_MAX) {
-        return numCollisions;
-    }
-    if (z <= -LEVEL_BOUNDARY_MAX || z >= LEVEL_BOUNDARY_MAX) {
-        return numCollisions;
-    }
+    if (is_outside_level_bounds(x, z)) return numCollisions;
 
     // World (level) consists of a 16x16 grid. Find where the collision is on
     // the grid (round toward -inf)
-    cellX = ((x + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX;
-    cellZ = ((z + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX;
-
+    register const s32 cellX = (((x + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX);
+    register const s32 cellZ = (((z + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX);
     // Check for surfaces belonging to objects.
     node = gDynamicSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_WALLS].next;
     numCollisions += find_wall_collisions_from_list(node, colData);
-
     // Check for surfaces that are a part of level geometry.
     node = gStaticSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_WALLS].next;
     numCollisions += find_wall_collisions_from_list(node, colData);
-
+#ifdef UNDERWATER_STEEP_FLOORS_AS_WALLS
+    if (gIncludeSteepFloorsInWallCollisionCheck) {
+        // Check for surfaces belonging to objects.
+        node = gDynamicSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_FLOORS].next;
+        numCollisions += find_wall_collisions_from_list(node, colData);
+        // Check for surfaces that are a part of level geometry.
+        node = gStaticSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_FLOORS].next;
+        numCollisions += find_wall_collisions_from_list(node, colData);
+    }
+#endif
     // Increment the debug tracker.
     gNumCalls.wall++;
 
@@ -224,134 +351,113 @@ s32 find_wall_collisions(struct WallCollisionData *colData) {
  *                     CEILINGS                   *
  **************************************************/
 
+// Find the height of the floor at a given location
+static f32 get_surface_height_at_location(s32 x, s32 z, struct Surface *surf) {
+    return -(x * surf->normal.x + surf->normal.z * z + surf->originOffset) / surf->normal.y;
+}
+
+#ifdef CEILING_MARGINS
+void add_ceil_margin(f32 *x, f32 *z, Vec3s target1, Vec3s target2, f32 margin) {
+    register f32 diff_x, diff_z, invDenom;
+    diff_x = target1[0] - *x + target2[0] - *x;
+    diff_z = target1[2] - *z + target2[2] - *z;
+    invDenom = margin / sqrtf(diff_x * diff_x + diff_z * diff_z);
+    *x += diff_x * invDenom;
+    *z += diff_z * invDenom;
+}
+#endif
+
 /**
  * Iterate through the list of ceilings and find the first ceiling over a given point.
  */
-static struct Surface *find_ceil_from_list(struct SurfaceNode *surfaceNode, s32 x, s32 y, s32 z, f32 *pheight) {
+static struct Surface *find_ceil_from_list(struct SurfaceNode *surfaceNode, f32 x, f32 y, f32 z, f32 *pheight) {
+#ifdef CEILING_MARGINS
+    const f32 margin = 1.5f;
+#endif
     register struct Surface *surf;
-    register s32 x1, z1, x2, z2, x3, z3;
+    f32 x1, z1, x2, z2, x3, z3;
+    f32 height;
+    s16 type = SURFACE_DEFAULT;
     struct Surface *ceil = NULL;
-
-    ceil = NULL;
-
+    // *pheight = CELL_HEIGHT_LIMIT;
     // Stay in this loop until out of ceilings.
     while (surfaceNode != NULL) {
-        surf = surfaceNode->surface;
+        surf        = surfaceNode->surface;
         surfaceNode = surfaceNode->next;
-
+        type        = surf->type;
+        // Determine if checking for the camera or not.
+        if (gCheckingSurfaceCollisionsForCamera) {
+            if (surf->flags & SURFACE_FLAG_NO_CAM_COLLISION) continue;
+        // Ignore camera only surfaces.
+        } else if (type == SURFACE_CAMERA_BOUNDARY) {
+            continue;
+        }
+#ifdef NEW_WATER_SURFACES
+        if ((type == SURFACE_NEW_WATER) || (type == SURFACE_NEW_WATER_BOTTOM)) continue;
+#endif
+        // Skip if ceil is too low
+        if (y > surf->upperY) continue;
         x1 = surf->vertex1[0];
         z1 = surf->vertex1[2];
+#ifdef CEILING_MARGINS
+        if (type != SURFACE_HANGABLE) add_ceil_margin(&x1, &z1, surf->vertex2, surf->vertex3, margin);
+#endif
         z2 = surf->vertex2[2];
         x2 = surf->vertex2[0];
-
+#ifdef CEILING_MARGINS
+        if (type != SURFACE_HANGABLE) add_ceil_margin(&x2, &z2, surf->vertex3, surf->vertex1, margin);
+#endif
         // Checking if point is in bounds of the triangle laterally.
-        if ((z1 - z) * (x2 - x1) - (x1 - x) * (z2 - z1) > 0) {
-            continue;
-        }
-
+        if ((z1 - z) * (x2 - x1) - (x1 - x) * (z2 - z1) > 0) continue;
         // Slight optimization by checking these later.
         x3 = surf->vertex3[0];
         z3 = surf->vertex3[2];
-        if ((z2 - z) * (x3 - x2) - (x2 - x) * (z3 - z2) > 0) {
-            continue;
-        }
-        if ((z3 - z) * (x1 - x3) - (x3 - x) * (z1 - z3) > 0) {
-            continue;
-        }
-
-        // Determine if checking for the camera or not.
-        if (gCheckingSurfaceCollisionsForCamera != 0) {
-            if (surf->flags & SURFACE_FLAG_NO_CAM_COLLISION) {
-                continue;
-            }
-        }
-        // Ignore camera only surfaces.
-        else if (surf->type == SURFACE_CAMERA_BOUNDARY) {
-            continue;
-        }
-
-        f32 nx = surf->normal.x;
-        f32 ny = surf->normal.y;
-        f32 nz = surf->normal.z;
-        f32 oo = surf->originOffset;
-        f32 height;
-
-        // If a wall, ignore it. Likely a remnant, should never occur.
-        if (ny == 0.0f) {
-            continue;
-        }
-
+#ifdef CEILING_MARGINS
+        if (type != SURFACE_HANGABLE) add_ceil_margin(&x3, &z3, surf->vertex1, surf->vertex2, margin);
+#endif
+        if ((z2 - z) * (x3 - x2) - (x2 - x) * (z3 - z2) > 0) continue;
+        if ((z3 - z) * (x1 - x3) - (x3 - x) * (z1 - z3) > 0) continue;
         // Find the ceil height at the specific point.
-        height = -(x * nx + nz * z + oo) / ny;
-
-        // Checks for ceiling interaction with a 78 unit buffer.
-        //! (Exposed Ceilings) Because any point above a ceiling counts
-        //  as interacting with a ceiling, ceilings far below can cause
-        // "invisible walls" that are really just exposed ceilings.
-        if (y - (height - -78.0f) > 0.0f) {
-            continue;
-        }
-
+        height = get_surface_height_at_location(x, z, surf);
+        if (height >= *pheight) continue;
+        // Checks for ceiling interaction
+        if (y > height      ) continue;
+        if (y > surf->upperY) continue;
         *pheight = height;
-        ceil = surf;
-        break;
+        ceil     = surf;
+        if (height == y) break;
     }
-
-    //! (Surface Cucking) Since only the first ceil is returned and not the lowest,
-    //  lower ceilings can be "cucked" by higher ceilings.
     return ceil;
 }
 
 /**
  * Find the lowest ceiling above a given position and return the height.
  */
-f32 find_ceil(f32 posX, f32 posY, f32 posZ, struct Surface **pceil) {
-    s16 cellZ, cellX;
-
+f32 find_ceil(f32 x, f32 y, f32 z, struct Surface **pceil) {
     struct Surface *ceil, *dynamicCeil;
     struct SurfaceNode *surfaceList;
-
-    f32 height = CELL_HEIGHT_LIMIT;
+    f32 height        = CELL_HEIGHT_LIMIT;
     f32 dynamicHeight = CELL_HEIGHT_LIMIT;
-
-    //! (Parallel Universes) Because position is casted to an s16, reaching higher
-    //  float locations can return ceilings despite them not existing there.
-    //  (Dynamic ceilings will unload due to the range.)
-    s16 x = (s16) posX;
-    s16 y = (s16) posY;
-    s16 z = (s16) posZ;
-
-    *pceil = NULL;
-
-    if (x <= -LEVEL_BOUNDARY_MAX || x >= LEVEL_BOUNDARY_MAX) {
-        return height;
-    }
-    if (z <= -LEVEL_BOUNDARY_MAX || z >= LEVEL_BOUNDARY_MAX) {
-        return height;
-    }
-
+    *pceil            = NULL;
+    if (is_outside_level_bounds(x, z)) return height;
     // Each level is split into cells to limit load, find the appropriate cell.
-    cellX = ((x + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX;
-    cellZ = ((z + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX;
-
+    register const s32 cellX = ((((s32)x + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX);
+    register const s32 cellZ = ((((s32)z + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX);
+    // Check for surfaces that are a part of level geometry.
+    surfaceList = gStaticSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_CEILS].next;
+    ceil        = find_ceil_from_list(surfaceList, x, y, z, &height);
+    dynamicHeight = height;
     // Check for surfaces belonging to objects.
     surfaceList = gDynamicSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_CEILS].next;
     dynamicCeil = find_ceil_from_list(surfaceList, x, y, z, &dynamicHeight);
-
-    // Check for surfaces that are a part of level geometry.
-    surfaceList = gStaticSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_CEILS].next;
-    ceil = find_ceil_from_list(surfaceList, x, y, z, &height);
-
+    // Use the dynamic ceiling if it is lower
     if (dynamicHeight < height) {
-        ceil = dynamicCeil;
+        ceil   = dynamicCeil;
         height = dynamicHeight;
     }
-
     *pceil = ceil;
-
     // Increment the debug tracker.
     gNumCalls.ceil++;
-
     return height;
 }
 
@@ -362,120 +468,156 @@ f32 find_ceil(f32 posX, f32 posY, f32 posZ, struct Surface **pceil) {
 /**
  * Find the height of the highest floor below an object.
  */
-f32 unused_obj_find_floor_height(struct Object *obj) {
+UNUSED f32 unused_obj_find_floor_height(struct Object *obj) {
     struct Surface *floor;
     f32 floorHeight = find_floor(obj->oPosX, obj->oPosY, obj->oPosZ, &floor);
     return floorHeight;
 }
 
-/**
- * Basically a local variable that passes through floor geo info.
- */
-struct FloorGeometry sFloorGeo;
-
-UNUSED static u8 unused8038BE50[0x40];
-
-/**
- * Return the floor height underneath (xPos, yPos, zPos) and populate `floorGeo`
- * with data about the floor's normal vector and origin offset. Also update
- * sFloorGeo.
- */
-f32 find_floor_height_and_data(f32 xPos, f32 yPos, f32 zPos, struct FloorGeometry **floorGeo) {
-    struct Surface *floor;
-    f32 floorHeight = find_floor(xPos, yPos, zPos, &floor);
-
-    *floorGeo = NULL;
-
-    if (floor != NULL) {
-        sFloorGeo.normalX = floor->normal.x;
-        sFloorGeo.normalY = floor->normal.y;
-        sFloorGeo.normalZ = floor->normal.z;
-        sFloorGeo.originOffset = floor->originOffset;
-
-        *floorGeo = &sFloorGeo;
+s32 floor_type_exists_in_current_cell(f32 x, f32 z, s16 type, u32 dynamic) {
+    register const s32 cellX = ((((s32)x + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX);
+    register const s32 cellZ = ((((s32)z + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX);
+    struct SurfaceNode *surfaceNode;
+    surfaceNode = gStaticSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_FLOORS].next;
+    // Check for surfaces that are a part of level geometry.
+    while (surfaceNode != NULL) {
+        if (surfaceNode->surface->type == type) return TRUE;
+        surfaceNode = surfaceNode->next;
     }
-    return floorHeight;
+    if (dynamic) {
+        // Check for surfaces belonging to objects.
+        surfaceNode = gDynamicSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_FLOORS].next;
+        while (surfaceNode != NULL) {
+            if (surfaceNode->surface->type == type) return TRUE;
+            surfaceNode = surfaceNode->next;
+        }
+    }
+    return FALSE;
 }
 
+static s16 check_within_floor_triangle_bounds(s32 x, s32 z, struct Surface *surf) {
+    register f32 x1 = surf->vertex1[0];
+    register f32 z1 = surf->vertex1[2];
+    register f32 x2 = surf->vertex2[0];
+    register f32 z2 = surf->vertex2[2];
+    // Checking if point is in bounds of the triangle laterally.
+    if ((z1 - z) * (x2 - x1) - (x1 - x) * (z2 - z1) < 0.0f) return FALSE; // 12
+    // Slight optimization by checking these later.
+    register f32 x3 = surf->vertex3[0];
+    register f32 z3 = surf->vertex3[2];
+    if ((z2 - z) * (x3 - x2) - (x2 - x) * (z3 - z2) < 0.0f) return FALSE; // 23
+    if ((z3 - z) * (x1 - x3) - (x3 - x) * (z1 - z3) < 0.0f) return FALSE; // 31
+    return TRUE;
+}
 
 /**
  * Iterate through the list of floors and find the first floor under a given point.
  */
-static struct Surface *find_floor_from_list(struct SurfaceNode *surfaceNode, s32 x, s32 y, s32 z, f32 *pheight) {
+static struct Surface *find_floor_from_list(struct SurfaceNode *surfaceNode, f32 x, f32 y, f32 z, f32 *pheight) {
     register struct Surface *surf;
-    register f32 x1, z1, x2, z2, x3, z3;
-    f32 nx, ny, nz;
-    f32 oo;
     f32 height;
+    s16 type = SURFACE_DEFAULT;
     struct Surface *floor = NULL;
-
     // Iterate through the list of floors until there are no more floors.
     while (surfaceNode != NULL) {
-        surf = surfaceNode->surface;
+        surf        = surfaceNode->surface;
         surfaceNode = surfaceNode->next;
-
-        x1 = surf->vertex1[0];
-        z1 = surf->vertex1[2];
-        x2 = surf->vertex2[0];
-        z2 = surf->vertex2[2];
-
-        // Check that the point is within the triangle bounds.
-        if ((z1 - z) * (x2 - x1) - (x1 - x) * (z2 - z1) < 0) {
-            continue;
-        }
-
-        // To slightly save on computation time, set this later.
-        x3 = surf->vertex3[0];
-        z3 = surf->vertex3[2];
-
-        if ((z2 - z) * (x3 - x2) - (x2 - x) * (z3 - z2) < 0) {
-            continue;
-        }
-        if ((z3 - z) * (x1 - x3) - (x3 - x) * (z1 - z3) < 0) {
-            continue;
-        }
-
+        type        = surf->type;
+        // To prevent the Merry-Go-Round room from loading when Mario passes above the hole that leads
+        // there, SURFACE_INTANGIBLE is used. This prevent the wrong room from loading, but can also allow
+        // Mario to pass through.
+        if (!gFindFloorIncludeSurfaceIntangible && (type == SURFACE_INTANGIBLE)) continue;
         // Determine if we are checking for the camera or not.
-        if (gCheckingSurfaceCollisionsForCamera != 0) {
-            if (surf->flags & SURFACE_FLAG_NO_CAM_COLLISION) {
-                continue;
-            }
-        }
+        if (gCheckingSurfaceCollisionsForCamera) {
+#ifdef NEW_WATER_SURFACES
+            if ((surf->flags & SURFACE_FLAG_NO_CAM_COLLISION) || (type == SURFACE_NEW_WATER) || (type == SURFACE_NEW_WATER_BOTTOM)) continue;
+#else
+            if (surf->flags & SURFACE_FLAG_NO_CAM_COLLISION) continue;
+#endif
         // If we are not checking for the camera, ignore camera only floors.
-        else if (surf->type == SURFACE_CAMERA_BOUNDARY) {
-            continue;
-        }
-
-        nx = surf->normal.x;
-        ny = surf->normal.y;
-        nz = surf->normal.z;
-        oo = surf->originOffset;
+        } else if (type == SURFACE_CAMERA_BOUNDARY) continue;
+        // Skip if floor is too high
+        if (y < (surf->lowerY - 30)) continue; //! why 30?
+        // Check if point is within tri laterally
+        if (!check_within_floor_triangle_bounds(x, z, surf)) continue;
+        // Get the height of the point on the tri
+        height = get_surface_height_at_location(x, z, surf);
+#ifdef CENTERED_COLLISION
+        // Ignore if the height is below or the same as the current surface height
+        if (height <= *pheight) continue;
+        // Check if the original location is above the floor height
+        if (y < height) continue;
+        // Set current surface and height for next iteration
+        *pheight = height;
+        floor    = surf;
+        // Exit the loop if it's not possible for another floor to be closer to the original point
+        if (y == height) break;
+#else
+        // Ignore if the height is below or the same as the current surface height, without the buffer
+        if (height <= *pheight) continue;
+        // Check if the original location is more than 78 units above the floor height
+        if (y < (height - 78.0f)) continue;
+        // Set current surface and height for next iteration
+        *pheight = height;
+        floor    = surf;
+        // Exit the loop if it's not possible for another floor to be closer to the original point
+        if (y == (height - 78.0f)) break;
+#endif
+    }
+    return floor;
+}
 
-        // If a wall, ignore it. Likely a remnant, should never occur.
-        if (ny == 0.0f) {
+#ifdef NEW_WATER_SURFACES
+/**
+ * Iterate through the list of water floors and find the first water floor under a given point.
+ */
+struct Surface *find_water_floor_from_list(struct SurfaceNode *surfaceNode, s32 x, s32 y, s32 z, s32 *pheight, s32 *pBottomHeight) {
+    register struct Surface *surf;
+    struct Surface     *floor             = NULL;
+    struct SurfaceNode *topSurfaceNode    = surfaceNode;
+    struct SurfaceNode *bottomSurfaceNode = surfaceNode;
+    s32 height          = FLOOR_LOWER_LIMIT;
+    s32 bottomHeight    = FLOOR_LOWER_LIMIT;
+    s32 topBottomHeight = FLOOR_LOWER_LIMIT;
+    // Iterate through the list of water floors until there are no more water floors.
+    while (bottomSurfaceNode != NULL) {
+        s32 curBottomHeight = FLOOR_LOWER_LIMIT;
+        surf                = bottomSurfaceNode->surface;
+        bottomSurfaceNode   = bottomSurfaceNode->next;
+        if (surf->type != SURFACE_NEW_WATER_BOTTOM || !check_within_floor_triangle_bounds(x, z, surf)) continue;
+        curBottomHeight = get_surface_height_at_location(x, z, surf);
+#ifdef CENTERED_COLLISION
+        if (curBottomHeight < y) {
+            if (curBottomHeight > topBottomHeight) topBottomHeight = curBottomHeight;
             continue;
         }
-
-        // Find the height of the floor at a given location.
-        height = -(x * nx + nz * z + oo) / ny;
-        // Checks for floor interaction with a 78 unit buffer.
-        if (y - (height + -78.0f) < 0.0f) {
+        if (curBottomHeight >= y) bottomHeight = curBottomHeight;
+#else
+        if (curBottomHeight < (y + 78.0f)) {
+            if (curBottomHeight > topBottomHeight) topBottomHeight = curBottomHeight;
             continue;
         }
-
-#ifdef CHEATS_ACTIONS
-        height = cheats_walk_on_environment(height, x, z);
+        if (curBottomHeight >= (y + 78.0f)) bottomHeight = curBottomHeight;
 #endif
-
-        *pheight = height;
-        floor = surf;
-        break;
     }
-
-    //! (Surface Cucking) Since only the first floor is returned and not the highest,
-    //  higher floors can be "cucked" by lower floors.
+    // Iterate through the list of water tops until there are no more water tops.
+    while (topSurfaceNode != NULL) {
+        s32 curHeight  = FLOOR_LOWER_LIMIT;
+        surf           = topSurfaceNode->surface;
+        topSurfaceNode = topSurfaceNode->next;
+        if (surf->type == SURFACE_NEW_WATER_BOTTOM || !check_within_floor_triangle_bounds(x, z, surf)) continue;
+        curHeight = get_surface_height_at_location(x, z, surf);
+        if ((bottomHeight != FLOOR_LOWER_LIMIT) && (curHeight > bottomHeight)) continue;
+        if (curHeight > height) {
+            height   = curHeight;
+            *pheight = curHeight;
+            floor    = surf;
+        }
+    }
+    *pBottomHeight = topBottomHeight;
     return floor;
 }
+#endif
 
 /**
  * Find the height of the highest floor below a point.
@@ -489,22 +631,41 @@ f32 find_floor_height(f32 x, f32 y, f32 z) {
 }
 
 /**
- * Find the highest dynamic floor under a given position. Perhaps originally static
- * and dynamic floors were checked separately.
+ * Find the highest static floor under a given position.
+ */
+
+f32 find_static_floor(f32 x, f32 y, f32 z, struct Surface **pfloor) {
+    struct SurfaceNode *surfaceList;
+    struct Surface *floor;
+    f32 floorHeight = FLOOR_LOWER_LIMIT;
+
+    if (is_outside_level_bounds(x, z)) return floorHeight;
+
+    // Each level is split into cells to limit load, find the appropriate cell.
+    s32 cellX = (((s32)x + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX;
+    s32 cellZ = (((s32)z + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX;
+
+    surfaceList = gStaticSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_FLOORS].next;
+    floor = find_floor_from_list(surfaceList, x, y, z, &floorHeight);
+
+    *pfloor = floor;
+
+    return floorHeight;
+}
+
+/**
+ * Find the highest dynamic floor under a given position.
  */
-f32 unused_find_dynamic_floor(f32 xPos, f32 yPos, f32 zPos, struct Surface **pfloor) {
+f32 find_dynamic_floor(f32 x, f32 y, f32 z, struct Surface **pfloor) {
     struct SurfaceNode *surfaceList;
     struct Surface *floor;
     f32 floorHeight = FLOOR_LOWER_LIMIT;
 
-    // Would normally cause PUs, but dynamic floors unload at that range.
-    s16 x = (s16) xPos;
-    s16 y = (s16) yPos;
-    s16 z = (s16) zPos;
+    if (is_outside_level_bounds(x, z)) return floorHeight;
 
     // Each level is split into cells to limit load, find the appropriate cell.
-    s16 cellX = ((x + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX;
-    s16 cellZ = ((z + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX;
+    s32 cellX = (((s32)x + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX;
+    s32 cellZ = (((s32)z + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX;
 
     surfaceList = gDynamicSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_FLOORS].next;
     floor = find_floor_from_list(surfaceList, x, y, z, &floorHeight);
@@ -517,81 +678,139 @@ f32 unused_find_dynamic_floor(f32 xPos, f32 yPos, f32 zPos, struct Surface **pfl
 /**
  * Find the highest floor under a given position and return the height.
  */
-f32 find_floor(f32 xPos, f32 yPos, f32 zPos, struct Surface **pfloor) {
-    s16 cellZ, cellX;
-
+f32 find_floor(f32 x, f32 y, f32 z, struct Surface **pfloor) {
     struct Surface *floor, *dynamicFloor;
     struct SurfaceNode *surfaceList;
-
-    f32 height = FLOOR_LOWER_LIMIT;
+    f32 height        = FLOOR_LOWER_LIMIT;
     f32 dynamicHeight = FLOOR_LOWER_LIMIT;
-
-    //! (Parallel Universes) Because position is casted to an s16, reaching higher
-    //  float locations can return floors despite them not existing there.
-    //  (Dynamic floors will unload due to the range.)
-    s16 x = (s16) xPos;
-    s16 y = (s16) yPos;
-    s16 z = (s16) zPos;
-
     *pfloor = NULL;
-
-    if (x <= -LEVEL_BOUNDARY_MAX || x >= LEVEL_BOUNDARY_MAX) {
+    // Exclude floors outside of level boundaries
+    if (is_outside_level_bounds(x, z)) {
         return height;
     }
-    if (z <= -LEVEL_BOUNDARY_MAX || z >= LEVEL_BOUNDARY_MAX) {
-        return height;
-    }
-
     // Each level is split into cells to limit load, find the appropriate cell.
-    cellX = ((x + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX;
-    cellZ = ((z + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX;
-
-    // Check for surfaces belonging to objects.
-    surfaceList = gDynamicSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_FLOORS].next;
-    dynamicFloor = find_floor_from_list(surfaceList, x, y, z, &dynamicHeight);
-
+    register const s32 cellX = ((((s32)x + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX);
+    register const s32 cellZ = ((((s32)z + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX);
     // Check for surfaces that are a part of level geometry.
-    surfaceList = gStaticSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_FLOORS].next;
-    floor = find_floor_from_list(surfaceList, x, y, z, &height);
-
-    // To prevent the Merry-Go-Round room from loading when Mario passes above the hole that leads
-    // there, SURFACE_INTANGIBLE is used. This prevent the wrong room from loading, but can also allow
-    // Mario to pass through.
-    if (!gFindFloorIncludeSurfaceIntangible) {
-        //! (BBH Crash) Most NULL checking is done by checking the height of the floor returned
-        //  instead of checking directly for a NULL floor. If this check returns a NULL floor
-        //  (happens when there is no floor under the SURFACE_INTANGIBLE floor) but returns the height
-        //  of the SURFACE_INTANGIBLE floor instead of the typical -11000 returned for a NULL floor.
-        if (floor != NULL && floor->type == SURFACE_INTANGIBLE) {
-            floor = find_floor_from_list(surfaceList, x, (s32)(height - 200.0f), z, &height);
+    surfaceList  = gStaticSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_FLOORS].next;
+    floor        = find_floor_from_list(surfaceList, x, y, z, &height);
+#ifdef FIND_FLOOR_EXCLUDE_DYNAMIC_CHECK
+    if (!gFindFloorExcludeDynamic) {
+        // In the next check, only check for floors higher than the previous check
+        dynamicHeight = height;
+        // Check for surfaces belonging to objects.
+        surfaceList  = gDynamicSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_FLOORS].next;
+        dynamicFloor = find_floor_from_list(surfaceList, x, y, z, &dynamicHeight);
+        // Use the dynamic floor if it's higher
+        if (dynamicHeight > height) {
+            floor  = dynamicFloor;
+            height = dynamicHeight;
         }
-    } else {
-        // To prevent accidentally leaving the floor tangible, stop checking for it.
-        gFindFloorIncludeSurfaceIntangible = FALSE;
     }
-
+#endif
     // If a floor was missed, increment the debug counter.
-    if (floor == NULL) {
-        gNumFindFloorMisses++;
-    }
-
-    if (dynamicHeight > height) {
-        floor = dynamicFloor;
-        height = dynamicHeight;
-    }
-
+    if (floor == NULL) gNumFindFloorMisses++;
     *pfloor = floor;
-
+    // To prevent the Merry-Go-Round room from loading when Mario passes above the hole that leads
+    // there, SURFACE_INTANGIBLE is used. This prevent the wrong room from loading, but can also allow
+    // Mario to pass through.
+    // To prevent accidentally leaving the floor tangible, stop checking for it.
+    gFindFloorIncludeSurfaceIntangible = FALSE;
+#ifdef FIND_FLOOR_EXCLUDE_DYNAMIC_CHECK
+    gFindFloorExcludeDynamic           = FALSE;
+#endif
     // Increment the debug tracker.
     gNumCalls.floor++;
+    return height;
+}
 
+#ifdef NEW_WATER_SURFACES
+/**
+ * Find the highest water floor under a given position and return the height.
+ */
+f32 find_water_floor(f32 x, f32 y, f32 z, struct Surface **pfloor) {
+    struct Surface     *floor = NULL;
+    struct SurfaceNode *surfaceList;
+    s32 height       = FLOOR_LOWER_LIMIT;
+    s32 bottomheight = FLOOR_LOWER_LIMIT;
+    // Check if position is within level bounds
+    if (is_outside_level_bounds(x, z)) return height;
+    // Each level is split into cells to limit load, find the appropriate cell.
+    register const s32 cellX = (((s32)x + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX;
+    register const s32 cellZ = (((s32)z + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX;
+    // Check for surfaces that are a part of level geometry.
+    surfaceList = gStaticSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_WATER].next;
+    floor = find_water_floor_from_list(surfaceList, x, y, z, &height, &bottomheight);
+    if (floor == NULL) {
+        height       = FLOOR_LOWER_LIMIT;
+        bottomheight = FLOOR_LOWER_LIMIT;
+    } else {
+        *pfloor = floor;
+    }
     return height;
 }
+#endif
+
+f32 find_room_floor(f32 x, f32 y, f32 z, struct Surface **pfloor) {
+    gFindFloorIncludeSurfaceIntangible = TRUE;
+#ifdef FIND_FLOOR_EXCLUDE_DYNAMIC_CHECK
+    gFindFloorExcludeDynamic           = TRUE;
+#endif
+    return find_floor(x, y, z, pfloor);
+}
 
 /**************************************************
  *               ENVIRONMENTAL BOXES              *
  **************************************************/
 
+/**
+ * Finds the height of water at a given location.
+ */
+f32 find_water_level_and_floor(f32 x, f32 z, struct Surface **pfloor) {
+    s32 i;
+    s32 numRegions;
+    s16 val;
+    f32 loX, hiX, loZ, hiZ;
+    f32 waterLevel = FLOOR_LOWER_LIMIT;
+    s16 *p = gEnvironmentRegions;
+
+#ifdef NEW_WATER_SURFACES
+    struct Surface *floor = NULL;
+    waterLevel = find_water_floor(x, gCheckingSurfaceCollisionsForCamera ? gLakituState.pos[1] : gMarioState->pos[1], z, &floor);
+    if (p != NULL && waterLevel == FLOOR_LOWER_LIMIT)
+#else
+    if (p != NULL) 
+#endif
+    {
+        numRegions = *p++;
+
+        for (i = 0; i < numRegions; i++) {
+            val = *p++;
+            loX = *p++;
+            loZ = *p++;
+            hiX = *p++;
+            hiZ = *p++;
+
+            // If the location is within a water box and it is a water box.
+            // Water is less than 50 val only, while above is gas and such.
+            if (loX < x && x < hiX && loZ < z && z < hiZ && val < 50) {
+                // Set the water height. Since this breaks, only return the first height.
+                waterLevel = *p;
+                break;
+            }
+            p++;
+        }
+    } else {
+#ifdef NEW_WATER_SURFACES
+        *pfloor = floor;
+#else
+        *pfloor = NULL;
+#endif
+    }
+
+    return waterLevel;
+}
+
 /**
  * Finds the height of water at a given location.
  */
@@ -603,7 +822,14 @@ f32 find_water_level(f32 x, f32 z) {
     f32 waterLevel = FLOOR_LOWER_LIMIT;
     s16 *p = gEnvironmentRegions;
 
-    if (p != NULL) {
+#ifdef NEW_WATER_SURFACES
+    struct Surface *floor;
+    waterLevel = find_water_floor(x, gCheckingSurfaceCollisionsForCamera ? gLakituState.pos[1] : gMarioState->pos[1], z, &floor);
+    if (p != NULL && waterLevel == FLOOR_LOWER_LIMIT)
+#else
+    if (p != NULL)
+#endif
+    {
         numRegions = *p++;
 
         for (i = 0; i < numRegions; i++) {
@@ -745,7 +971,7 @@ void debug_surface_list_info(f32 xPos, f32 zPos) {
  * An unused function that finds and interacts with any type of surface.
  * Perhaps an original implementation of surfaces before they were more specialized.
  */
-static s32 unused_resolve_floor_or_ceil_collisions(s32 checkCeil, f32 *px, f32 *py, f32 *pz, f32 radius,
+UNUSED static s32 unused_resolve_floor_or_ceil_collisions(s32 checkCeil, f32 *px, f32 *py, f32 *pz, f32 radius,
                                             struct Surface **psurface, f32 *surfaceHeight) {
     f32 nx, ny, nz, oo;
     f32 x = *px;
diff --git a/src/engine/surface_collision.h b/src/engine/surface_collision.h
index f469508..db9090c 100644
--- a/src/engine/surface_collision.h
+++ b/src/engine/surface_collision.h
@@ -5,41 +5,26 @@
 
 #include "types.h"
 
-// Range level area is 16384x16384 (-8192 to +8192 in x and z)
-#define LEVEL_BOUNDARY_MAX  0x2000 // 8192
-
-#define CELL_SIZE           (1 << 10) // 0x400
-
-#define CELL_HEIGHT_LIMIT           20000
-#define FLOOR_LOWER_LIMIT           -11000
-#define FLOOR_LOWER_LIMIT_MISC      (FLOOR_LOWER_LIMIT + 1000)
-// same as FLOOR_LOWER_LIMIT_MISC, explicitly for shadow.c 
-// It doesn't match if ".0" is removed or ".f" is added
-#define FLOOR_LOWER_LIMIT_SHADOW    (FLOOR_LOWER_LIMIT + 1000.0)
+#include "extended_bounds.h"
 
 struct WallCollisionData {
     /*0x00*/ f32 x, y, z;
     /*0x0C*/ f32 offsetY;
     /*0x10*/ f32 radius;
-    /*0x14*/ u8 filler[2];
     /*0x16*/ s16 numWalls;
-    /*0x18*/ struct Surface *walls[4];
-};
-
-struct FloorGeometry {
-    u8 filler[16]; // possibly position data?
-    f32 normalX;
-    f32 normalY;
-    f32 normalZ;
-    f32 originOffset;
+    /*0x18*/ struct Surface *walls[MAX_REFEREMCED_WALLS];
 };
 
 s32 f32_find_wall_collision(f32 *xPtr, f32 *yPtr, f32 *zPtr, f32 offsetY, f32 radius);
 s32 find_wall_collisions(struct WallCollisionData *colData);
 f32 find_ceil(f32 posX, f32 posY, f32 posZ, struct Surface **pceil);
-f32 find_floor_height_and_data(f32 xPos, f32 yPos, f32 zPos, struct FloorGeometry **floorGeo);
+s32 floor_type_exists_in_current_cell(f32  xPos, f32  zPos, s16 type, u32 dynamic);
 f32 find_floor_height(f32 x, f32 y, f32 z);
+f32 find_static_floor(f32 xPos, f32 yPos, f32 zPos, struct Surface **pfloor);
+f32 find_dynamic_floor(f32 xPos, f32 yPos, f32 zPos, struct Surface **pfloor);
 f32 find_floor(f32 xPos, f32 yPos, f32 zPos, struct Surface **pfloor);
+f32 find_room_floor(f32 xPos, f32  yPos, f32 zPos, struct Surface **pfloor);
+f32 find_water_level_and_floor(f32 x, f32 z, struct Surface **pfloor);
 f32 find_water_level(f32 x, f32 z);
 f32 find_poison_gas_level(f32 x, f32 z);
 void debug_surface_list_info(f32 xPos, f32 zPos);
diff --git a/src/engine/surface_load.c b/src/engine/surface_load.c
index dfe0d92..f3f50a3 100644
--- a/src/engine/surface_load.c
+++ b/src/engine/surface_load.c
@@ -15,8 +15,6 @@
 #include "game/game_init.h"
 #include "engine/math_util.h"
 
-s32 unused8038BE90;
-
 /**
  * Partitions for course and object surfaces. The arrays represent
  * the 16x16 cells that each level is split into.
@@ -43,8 +41,9 @@ struct Surface *sSurfacePool;
 s16 sSurfacePoolSize;
 #endif
 
-
-u8 unused8038EEA8[0x30];
+#ifdef SURFACE_POOLS_FULL_MESSAGES
+u8 gSurfacePoolError;
+#endif
 
 /**
  * Allocate the part of the surface node pool to contain a surface node.
@@ -61,11 +60,9 @@ static struct SurfaceNode *alloc_surface_node(void) {
 
     node->next = NULL;
 
-#ifndef USE_SYSTEM_MALLOC
-    //! A bounds check! If there's more surface nodes than 7000 allowed,
-    //  we, um...
-    // Perhaps originally just debug feedback?
-    if (gSurfaceNodesAllocated >= 7000) {
+#if !defined(USE_SYSTEM_MALLOC) && defined(SURFACE_POOLS_FULL_MESSAGES)
+    if (gSurfaceNodesAllocated >= SURFACE_NODE_POOL_SIZE) {
+        gSurfacePoolError |= NOT_ENOUGH_ROOM_FOR_NODES;
     }
 #endif
 
@@ -86,11 +83,9 @@ static struct Surface *alloc_surface(void) {
 #endif
     gSurfacesAllocated++;
 
-#ifndef USE_SYSTEM_MALLOC
-    //! A bounds check! If there's more surfaces than the 2300 allowed,
-    //  we, um...
-    // Perhaps originally just debug feedback?
+#if !defined(USE_SYSTEM_MALLOC) && defined(SURFACE_POOLS_FULL_MESSAGES)
     if (gSurfacesAllocated >= sSurfacePoolSize) {
+        gSurfacePoolError |= NOT_ENOUGH_ROOM_FOR_SURFACES;
     }
 #endif
 
@@ -113,7 +108,9 @@ static void clear_spatial_partition(SpatialPartitionCell *cells) {
         (*cells)[SPATIAL_PARTITION_FLOORS].next = NULL;
         (*cells)[SPATIAL_PARTITION_CEILS].next = NULL;
         (*cells)[SPATIAL_PARTITION_WALLS].next = NULL;
-
+#ifdef NEW_WATER_SURFACES
+        (*cells)[SPATIAL_PARTITION_WATER].next = NULL;
+#endif
         cells++;
     }
 }
@@ -139,29 +136,30 @@ static void add_surface_to_cell(s16 dynamic, s16 cellX, s16 cellZ, struct Surfac
     s16 priority;
     s16 sortDir;
     s16 listIndex;
-
-    if (surface->normal.y > 0.01) {
+#ifdef NEW_WATER_SURFACES
+    u32 isWater = ((surface->type == SURFACE_NEW_WATER) || (surface->type == SURFACE_NEW_WATER_BOTTOM));
+    if (surface->normal.y > MIN_FLOOR_NORMAL_Y) {
+        listIndex = (isWater ? SPATIAL_PARTITION_WATER : SPATIAL_PARTITION_FLOORS);
+#else
+    if (surface->normal.y > MIN_FLOOR_NORMAL_Y) {
         listIndex = SPATIAL_PARTITION_FLOORS;
+#endif
         sortDir = 1; // highest to lowest, then insertion order
-    } else if (surface->normal.y < -0.01) {
+    } else if (surface->normal.y < MAX_CEIL_NORMAL_Y) {
         listIndex = SPATIAL_PARTITION_CEILS;
         sortDir = -1; // lowest to highest, then insertion order
     } else {
         listIndex = SPATIAL_PARTITION_WALLS;
         sortDir = 0; // insertion order
 
+#ifndef BETTER_WALL_COLLISION
         if (surface->normal.x < -0.707 || surface->normal.x > 0.707) {
             surface->flags |= SURFACE_FLAG_X_PROJECTION;
         }
+#endif
     }
 
-    //! (Surface Cucking) Surfaces are sorted by the height of their first
-    //  vertex. Since vertices aren't ordered by height, this causes many
-    //  lower triangles to be sorted higher. This worsens surface cucking since
-    //  many functions only use the first triangle in surface order that fits,
-    //  missing higher surfaces.
-    //  upperY would be a better sort method.
-    surfacePriority = surface->vertex1[1] * sortDir;
+    surfacePriority = surface->upperY * sortDir;
 
     newNode->surface = surface;
 
@@ -173,7 +171,7 @@ static void add_surface_to_cell(s16 dynamic, s16 cellX, s16 cellZ, struct Surfac
 
     // Loop until we find the appropriate place for the surface in the list.
     while (list->next != NULL) {
-        priority = list->next->surface->vertex1[1] * sortDir;
+        priority = list->next->surface->upperY * sortDir;
 
         if (surfacePriority > priority) {
             break;
@@ -221,8 +219,8 @@ static s16 max_3(s16 a0, s16 a1, s16 a2) {
  * time). This function determines the lower cell for a given x/z position.
  * @param coord The coordinate to test
  */
-static s16 lower_cell_index(s16 coord) {
-    s16 index;
+static s32 lower_cell_index(s32 coord) {
+    s32 index;
 
     // Move from range [-0x2000, 0x2000) to [0, 0x4000)
     coord += LEVEL_BOUNDARY_MAX;
@@ -253,8 +251,8 @@ static s16 lower_cell_index(s16 coord) {
  * time). This function determines the upper cell for a given x/z position.
  * @param coord The coordinate to test
  */
-static s16 upper_cell_index(s16 coord) {
-    s16 index;
+static s32 upper_cell_index(s32 coord) {
+    s32 index;
 
     // Move from range [-0x2000, 0x2000) to [0, 0x4000)
     coord += LEVEL_BOUNDARY_MAX;
@@ -553,8 +551,8 @@ void alloc_surface_pools(void) {
     sDynamicSurfaceNodePool = alloc_only_pool_init();
     sDynamicSurfacePool = alloc_only_pool_init();
 #else
-    sSurfacePoolSize = 2300;
-    sSurfaceNodePool = main_pool_alloc(7000 * sizeof(struct SurfaceNode), MEMORY_POOL_LEFT);
+    sSurfacePoolSize = SURFACE_POOL_SIZE;
+    sSurfaceNodePool = main_pool_alloc(SURFACE_NODE_POOL_SIZE * sizeof(struct SurfaceNode), MEMORY_POOL_LEFT);
     sSurfacePool = main_pool_alloc(sSurfacePoolSize * sizeof(struct Surface), MEMORY_POOL_LEFT);
 #endif
 }
@@ -620,7 +618,6 @@ void load_area_terrain(s16 index, s16 *data, s8 *surfaceRooms, s16 *macroObjects
 
     // Initialize the data for this.
     gEnvironmentRegions = NULL;
-    unused8038BE90 = 0;
     gSurfaceNodesAllocated = 0;
     gSurfacesAllocated = 0;
 #ifdef USE_SYSTEM_MALLOC
diff --git a/src/engine/surface_load.h b/src/engine/surface_load.h
index e00e2bc..6ed4008 100644
--- a/src/engine/surface_load.h
+++ b/src/engine/surface_load.h
@@ -3,11 +3,12 @@
 
 #include <PR/ultratypes.h>
 
-#include "surface_collision.h"
 #include "types.h"
+#include "extended_bounds.h"
 
-#define NUM_CELLS       (2 * LEVEL_BOUNDARY_MAX / CELL_SIZE)
-#define NUM_CELLS_INDEX (NUM_CELLS - 1)
+#ifdef SURFACE_POOLS_FULL_MESSAGES
+extern u8 gSurfacePoolError;
+#endif
 
 struct SurfaceNode {
     struct SurfaceNode *next;
@@ -17,13 +18,14 @@ struct SurfaceNode {
 enum {
     SPATIAL_PARTITION_FLOORS,
     SPATIAL_PARTITION_CEILS,
-    SPATIAL_PARTITION_WALLS
+    SPATIAL_PARTITION_WALLS,
+#ifdef NEW_WATER_SURFACES
+    SPATIAL_PARTITION_WATER,
+#endif
+    SPATIAL_PARTITION_MAX
 };
 
-typedef struct SurfaceNode SpatialPartitionCell[3];
-
-// Needed for bs bss reordering memes.
-extern s32 unused8038BE90;
+typedef struct SurfaceNode SpatialPartitionCell[SPATIAL_PARTITION_MAX];
 
 extern SpatialPartitionCell gStaticSurfacePartition[NUM_CELLS][NUM_CELLS];
 extern SpatialPartitionCell gDynamicSurfacePartition[NUM_CELLS][NUM_CELLS];
diff --git a/src/extras/bettercamera.c b/src/extras/bettercamera.c
index 648bf06..05d715e 100644
--- a/src/extras/bettercamera.c
+++ b/src/extras/bettercamera.c
@@ -951,6 +951,11 @@ s32 ray_surface_intersect(Vec3f orig, Vec3f dir, f32 dir_length, struct Surface
     if (surface->type == SURFACE_HANGABLE && gMarioState->action & ACT_FLAG_HANGING)
         return FALSE;
 
+#ifdef NEW_WATER_SURFACES
+    if (surface->flags & SURFACE_NEW_WATER || surface->flags & SURFACE_NEW_WATER_BOTTOM)
+        return FALSE;
+#endif
+
     // Get surface normal and some other stuff
     norm[0] = 0;
     norm[1] = surface->normal.y;
@@ -1061,6 +1066,12 @@ void find_surface_on_ray_cell(s16 cellX, s16 cellZ, Vec3f orig, Vec3f normalized
             find_surface_on_ray_list(gStaticSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_WALLS].next, orig, normalized_dir, dir_length, hit_surface, hit_pos, max_length);
             find_surface_on_ray_list(gDynamicSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_WALLS].next, orig, normalized_dir, dir_length, hit_surface, hit_pos, max_length);
         }
+#ifdef NEW_WATER_SURFACES
+        if (flags & RAYCAST_FIND_WATER) {
+            find_surface_on_ray_list(gStaticSurfacePartition [cellZ][cellX][SPATIAL_PARTITION_WATER].next, orig, normalized_dir, dir_length, hit_surface, hit_pos, max_length);
+            find_surface_on_ray_list(gDynamicSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_WATER].next, orig, normalized_dir, dir_length, hit_surface, hit_pos, max_length);
+        }
+#endif
 	}
 }
 
@@ -1599,6 +1610,9 @@ static void puppycan_opacity(void) {
 //Handles collision detection using ray casting.
 static void puppycam_collision(void)
 {
+#ifdef BETTER_WALL_COLLISION
+    struct WallCollisionData wall0, wall1;
+#endif
     struct Surface *surf[2];
     Vec3f camdir[2];
     Vec3f hitpos[2];
@@ -1628,8 +1642,13 @@ static void puppycam_collision(void)
 
     find_surface_on_ray(target[0], camdir[0], &surf[0], hitpos[0], RAYCAST_FIND_FLOOR | RAYCAST_FIND_CEIL | RAYCAST_FIND_WALL);
     find_surface_on_ray(target[1], camdir[1], &surf[1], hitpos[1], RAYCAST_FIND_FLOOR | RAYCAST_FIND_CEIL | RAYCAST_FIND_WALL);
+#ifdef BETTER_WALL_COLLISION
+    resolve_and_return_wall_collisions(hitpos[0], 0.0f, 25.0f, &wall0);
+    resolve_and_return_wall_collisions(hitpos[1], 0.0f, 25.0f, &wall1);
+#else
     resolve_and_return_wall_collisions(hitpos[0], 0.0f, 25.0f);
     resolve_and_return_wall_collisions(hitpos[1], 0.0f, 25.0f);
+#endif
     dist[0] = ((target[0][0] - hitpos[0][0]) * (target[0][0] - hitpos[0][0]) + (target[0][1] - hitpos[0][1]) * (target[0][1] - hitpos[0][1]) + (target[0][2] - hitpos[0][2]) * (target[0][2] - hitpos[0][2]));
     dist[1] = ((target[1][0] - hitpos[1][0]) * (target[1][0] - hitpos[1][0]) + (target[1][1] - hitpos[1][1]) * (target[1][1] - hitpos[1][1]) + (target[1][2] - hitpos[1][2]) * (target[1][2] - hitpos[1][2]));
 
diff --git a/src/extras/bettercamera.h b/src/extras/bettercamera.h
index f0dd378..ac599c2 100644
--- a/src/extras/bettercamera.h
+++ b/src/extras/bettercamera.h
@@ -37,6 +37,7 @@
 #define RAYCAST_FIND_FLOOR  (1 << 0) // 0x0001
 #define RAYCAST_FIND_WALL   (1 << 1) // 0x0002
 #define RAYCAST_FIND_CEIL   (1 << 2) // 0x0004
+#define RAYCAST_FIND_WATER  (1 << 3) // 0x0008
 #define RAYCAST_FIND_ALL    (0xFFFFFFFF)
 
 enum gPuppyCamInputType
diff --git a/src/extras/mop/behaviors/Blargg.inc.c b/src/extras/mop/behaviors/Blargg.inc.c
index 30ab675..596ce3c 100644
--- a/src/extras/mop/behaviors/Blargg.inc.c
+++ b/src/extras/mop/behaviors/Blargg.inc.c
@@ -1,5 +1,8 @@
 void bhv_blargg_mop(void) {
     f32 speed = 10.f;
+#ifdef BETTER_WALL_COLLISION
+    struct WallCollisionData wall;
+#endif
     cur_obj_scale(2.0f);
 
     switch (o->oAction) {
@@ -43,5 +46,9 @@ void bhv_blargg_mop(void) {
             break;
     }
     cur_obj_move_xz_using_fvel_and_yaw();
+#ifdef BETTER_WALL_COLLISION
+    resolve_and_return_wall_collisions(&o->oPosX, 10.0f, 150.0f, &wall);
+#else
     resolve_and_return_wall_collisions(&o->oPosX, 10.0f, 150.0f);
+#endif
 }
diff --git a/src/game/behaviors/bowling_ball.inc.c b/src/game/behaviors/bowling_ball.inc.c
index b14b1cb..0f8dc35 100644
--- a/src/game/behaviors/bowling_ball.inc.c
+++ b/src/game/behaviors/bowling_ball.inc.c
@@ -233,11 +233,15 @@ void bhv_bob_pit_bowling_ball_init(void) {
 }
 
 void bhv_bob_pit_bowling_ball_loop(void) {
-    struct FloorGeometry *sp1c;
-    UNUSED s16 collisionFlags = object_step();
+    struct Surface *floor;
+    object_step();
 
-    find_floor_height_and_data(o->oPosX, o->oPosY, o->oPosZ, &sp1c);
-    if ((sp1c->normalX == 0) && (sp1c->normalZ == 0)) {
+#ifdef CENTERED_COLLISION
+    find_floor(o->oPosX, (o->oPosY + (o->hitboxHeight / 2.0f)), o->oPosZ, &floor);
+#else
+    find_floor(o->oPosX, o->oPosY, o->oPosZ, &floor);
+#endif
+    if ((floor != NULL) && (floor->normal.x == 0) && (floor->normal.z == 0)) {
         o->oForwardVel = 28.0f;
     }
 
diff --git a/src/game/behaviors/bowser.inc.c b/src/game/behaviors/bowser.inc.c
index 85bfeb6..d1627bc 100644
--- a/src/game/behaviors/bowser.inc.c
+++ b/src/game/behaviors/bowser.inc.c
@@ -1512,6 +1512,10 @@ s32 bowser_check_fallen_off_stage(void) {
     return FALSE;
 }
 
+#ifdef PLATFORM_DISPLACEMENT_2
+struct PlatformDisplacementInfo sBowserDisplacementInfo;
+#endif
+
 /**
  * Set Bowser's actions
  */
@@ -1590,9 +1594,16 @@ void bowser_free_update(void) {
     UNUSED f32 floorHeight;
 
     // Platform displacement check (for BitFS)
+#ifdef PLATFORM_DISPLACEMENT_2
+    if ((platform = o->platform) != NULL) {
+        apply_platform_displacement(&sBowserDisplacementInfo, &o->oPosX, (s16 *) &o->oFaceAngleYaw, platform);
+    }
+#else
     if ((platform = o->platform) != NULL) {
         apply_platform_displacement(FALSE, platform);
     }
+#endif
+
     // Reset grabbed status
     o->oBowserGrabbedStatus = BOWSER_GRAB_STATUS_NONE;
     // Update positions and actions (default action)
diff --git a/src/game/behaviors/butterfly.inc.c b/src/game/behaviors/butterfly.inc.c
index 7e9563b..4de887a 100644
--- a/src/game/behaviors/butterfly.inc.c
+++ b/src/game/behaviors/butterfly.inc.c
@@ -11,7 +11,6 @@ void bhv_butterfly_init(void) {
 }
 
 void butterfly_step(s32 speed) {
-    struct FloorGeometry *sp24;
     s16 yaw = o->oMoveAngleYaw;
     s16 pitch = o->oMoveAnglePitch;
     s16 yPhase = o->oButterflyYPhase;
@@ -30,7 +29,11 @@ void butterfly_step(s32 speed) {
         o->oPosY -= o->oVelY;
     }
 
-    floorY = find_floor_height_and_data(o->oPosX, o->oPosY, o->oPosZ, &sp24);
+#ifdef CENTERED_COLLISION
+    floorY = find_floor_height(o->oPosX, o->oPosY + OBJ_STEP_HEIGHT, o->oPosZ);
+#else
+    floorY = find_floor_height(o->oPosX, o->oPosY, o->oPosZ);
+#endif
 
     if (o->oPosY < floorY + 2.0f) {
         o->oPosY = floorY + 2.0f;
diff --git a/src/game/behaviors/door.inc.c b/src/game/behaviors/door.inc.c
index c25626c..19ce873 100644
--- a/src/game/behaviors/door.inc.c
+++ b/src/game/behaviors/door.inc.c
@@ -92,21 +92,21 @@ void bhv_door_init(void) {
 
     x = o->oPosX;
     z = o->oPosZ;
-    find_floor(x, o->oPosY, z, &floor);
+    find_room_floor(x, o->oPosY, z, &floor);
     if (floor != NULL) {
         o->oDoorUnkF8 = floor->room;
     }
 
     x = o->oPosX + sins(o->oMoveAngleYaw) * 200.0f;
     z = o->oPosZ + coss(o->oMoveAngleYaw) * 200.0f;
-    find_floor(x, o->oPosY, z, &floor);
+    find_room_floor(x, o->oPosY, z, &floor);
     if (floor != NULL) {
         o->oDoorUnkFC = floor->room;
     }
 
     x = o->oPosX + sins(o->oMoveAngleYaw) * -200.0f;
     z = o->oPosZ + coss(o->oMoveAngleYaw) * -200.0f;
-    find_floor(x, o->oPosY, z, &floor);
+    find_room_floor(x, o->oPosY, z, &floor);
     if (floor != NULL) {
         o->oDoorUnk100 = floor->room;
     }
diff --git a/src/game/behaviors/floating_platform.inc.c b/src/game/behaviors/floating_platform.inc.c
index 1dea8a6..6af5cab 100644
--- a/src/game/behaviors/floating_platform.inc.c
+++ b/src/game/behaviors/floating_platform.inc.c
@@ -3,14 +3,18 @@
 f32 floating_platform_find_home_y(void) {
     struct Surface *sp24;
     f32 sp20 = find_water_level(o->oPosX, o->oPosZ);
-    f32 sp1C = find_floor(o->oPosX, o->oPosY, o->oPosZ, &sp24);
+#ifdef CENTERED_COLLISION
+    f32 floorHeight = find_floor(o->oPosX, (o->oPosY + OBJ_STEP_HEIGHT), o->oPosZ, &sp24);
+#else
+    f32 floorHeight = find_floor(o->oPosX, o->oPosY, o->oPosZ, &sp24);
+#endif
 
-    if (sp20 > sp1C + o->oFloatingPlatformUnkFC) {
+    if (sp20 > floorHeight + o->oFloatingPlatformUnkFC) {
         o->oFloatingPlatformUnkF4 = 0;
         return sp20 + o->oFloatingPlatformUnkFC;
     } else {
         o->oFloatingPlatformUnkF4 = 1;
-        return sp1C + o->oFloatingPlatformUnkFC;
+        return floorHeight + o->oFloatingPlatformUnkFC;
     }
 }
 
diff --git a/src/game/behaviors/hoot.inc.c b/src/game/behaviors/hoot.inc.c
index ab50c1a..20af42a 100644
--- a/src/game/behaviors/hoot.inc.c
+++ b/src/game/behaviors/hoot.inc.c
@@ -11,30 +11,29 @@ void bhv_hoot_init(void) {
     cur_obj_become_intangible();
 }
 
-f32 hoot_find_next_floor(struct FloorGeometry **floorGeo, f32 arg1) {
+f32 hoot_find_next_floor(f32 arg1) {
     f32 sp24 = arg1 * sins(o->oMoveAngleYaw) + o->oPosX;
     UNUSED f32 sp20 = o->oPosY;
     f32 sp1c = arg1 * coss(o->oMoveAngleYaw) + o->oPosZ;
-    f32 floorY = find_floor_height_and_data(sp24, 10000.0f, sp1c, floorGeo);
+    f32 floorY = find_floor_height(sp24, CELL_HEIGHT_LIMIT, sp1c);
 
     return floorY;
 }
 
 void hoot_floor_bounce(void) {
-    struct FloorGeometry *floorGeo;
     f32 floorY;
 
-    floorY = hoot_find_next_floor(&floorGeo, 375.0f);
+    floorY = hoot_find_next_floor(375.0f);
     if (floorY + 75.0f > o->oPosY) {
         o->oMoveAnglePitch -= 3640.8888;
     }
 
-    floorY = hoot_find_next_floor(&floorGeo, 200.0f);
+    floorY = hoot_find_next_floor(200.0f);
     if (floorY + 125.0f > o->oPosY) {
         o->oMoveAnglePitch -= 7281.7776;
     }
 
-    floorY = hoot_find_next_floor(&floorGeo, 0);
+    floorY = hoot_find_next_floor(0.0f);
     if (floorY + 125.0f > o->oPosY) {
         o->oPosY = floorY + 125.0f;
     }
@@ -45,7 +44,7 @@ void hoot_floor_bounce(void) {
 }
 
 void hoot_free_step(s16 fastOscY, s32 speed) {
-    struct FloorGeometry *floorGeo;
+    struct Surface *floor;
     s16 yaw = o->oMoveAngleYaw;
     s16 pitch = o->oMoveAnglePitch;
     s16 animFrame = o->header.gfx.animInfo.animFrame;
@@ -66,8 +65,12 @@ void hoot_free_step(s16 fastOscY, s32 speed) {
     }
     o->oPosZ += o->oVelZ;
 
-    find_floor_height_and_data(o->oPosX, o->oPosY, o->oPosZ, &floorGeo);
-    if (floorGeo == NULL) {
+#ifdef CENTERED_COLLISION
+    find_floor(o->oPosX, (o->oPosY + OBJ_STEP_HEIGHT), o->oPosZ, &floor);
+#else
+    find_floor(o->oPosX, o->oPosY, o->oPosZ, &floor);
+#endif
+    if (floor == NULL) {
         o->oPosX = xPrev;
         o->oPosZ = zPrev;
     }
@@ -119,7 +122,7 @@ void hoot_carry_step(s32 speed, UNUSED f32 xPrev, UNUSED f32 zPrev) {
 }
 
 void hoot_surface_collision(f32 xPrev, UNUSED f32 yPrev, f32 zPrev) {
-    struct FloorGeometry *floorGeo;
+    struct Surface *floor;
     struct WallCollisionData hitbox;
     f32 floorY;
 
@@ -136,8 +139,13 @@ void hoot_surface_collision(f32 xPrev, UNUSED f32 yPrev, f32 zPrev) {
         gMarioObject->oInteractStatus |= INT_STATUS_MARIO_UNK7;
     }
 
-    floorY = find_floor_height_and_data(o->oPosX, o->oPosY, o->oPosZ, &floorGeo);
-    if (floorGeo == NULL) {
+#ifdef CENTERED_COLLISION
+    floorY = find_floor(o->oPosX, (o->oPosY + OBJ_STEP_HEIGHT), o->oPosZ, &floor);
+#else
+    floorY = find_floor(o->oPosX, o->oPosY, o->oPosZ, &floor);
+#endif
+
+    if (floor == NULL) {
         o->oPosX = xPrev;
         o->oPosZ = zPrev;
         return;
diff --git a/src/game/behaviors/metal_box.inc.c b/src/game/behaviors/metal_box.inc.c
index c0dddc6..8c8abb8 100644
--- a/src/game/behaviors/metal_box.inc.c
+++ b/src/game/behaviors/metal_box.inc.c
@@ -14,11 +14,14 @@ struct ObjectHitbox sMetalBoxHitbox = {
 
 s32 check_if_moving_over_floor(f32 a0, f32 a1) {
     struct Surface *sp24;
-    f32 sp20 = o->oPosX + sins(o->oMoveAngleYaw) * a1;
-    f32 floorHeight;
-    f32 sp18 = o->oPosZ + coss(o->oMoveAngleYaw) * a1;
-
-    floorHeight = find_floor(sp20, o->oPosY, sp18, &sp24);
+    f32 xPos = o->oPosX + sins(o->oMoveAngleYaw) * a1;
+    f32 zPos = o->oPosZ + coss(o->oMoveAngleYaw) * a1;
+
+#ifdef CENTERED_COLLISION
+    f32 floorHeight = find_floor(xPos, (o->oPosY + (o->hitboxHeight / 2)), zPos, &sp24);
+#else
+    f32 floorHeight = find_floor(xPos, o->oPosY, zPos, &sp24);
+#endif
 
     if (absf(floorHeight - o->oPosY) < a0) {
         return TRUE;
diff --git a/src/game/behaviors/tilting_inverted_pyramid.inc.c b/src/game/behaviors/tilting_inverted_pyramid.inc.c
index 77193dc..9761f34 100644
--- a/src/game/behaviors/tilting_inverted_pyramid.inc.c
+++ b/src/game/behaviors/tilting_inverted_pyramid.inc.c
@@ -72,10 +72,12 @@ void bhv_tilting_inverted_pyramid_loop(void) {
     Vec3f posBeforeRotation;
     Vec3f posAfterRotation;
 
+#ifndef PLATFORM_DISPLACEMENT_2
     // Mario's position
     f32 mx;
     f32 my;
     f32 mz;
+#endif
 
     s32 marioOnPlatform = FALSE;
     UNUSED u8 filler1[4];
@@ -83,8 +85,9 @@ void bhv_tilting_inverted_pyramid_loop(void) {
     UNUSED u8 filler2[28];
 
     if (gMarioObject->platform == o) {
+#ifndef PLATFORM_DISPLACEMENT_2
         get_mario_pos(&mx, &my, &mz);
-
+#endif
         dist[0] = gMarioObject->oPosX - o->oPosX;
         dist[1] = gMarioObject->oPosY - o->oPosY;
         dist[2] = gMarioObject->oPosZ - o->oPosZ;
@@ -130,10 +133,12 @@ void bhv_tilting_inverted_pyramid_loop(void) {
     // If Mario is on the platform, adjust his position for the platform tilt.
     if (marioOnPlatform) {
         linear_mtxf_mul_vec3f(*transform, posAfterRotation, dist);
+#ifndef PLATFORM_DISPLACEMENT_2
         mx += posAfterRotation[0] - posBeforeRotation[0];
         my += posAfterRotation[1] - posBeforeRotation[1];
         mz += posAfterRotation[2] - posBeforeRotation[2];
         set_mario_pos(mx, my, mz);
+#endif
     }
 
     o->header.gfx.throwMatrix = transform;
diff --git a/src/game/camera.c b/src/game/camera.c
index aa1f6ff..69c3918 100644
--- a/src/game/camera.c
+++ b/src/game/camera.c
@@ -831,14 +831,17 @@ void set_camera_height(struct Camera *c, f32 goalHeight) {
  */
 s16 look_down_slopes(s16 camYaw) {
     struct Surface *floor;
-    f32 floorDY;
     // Default pitch
     s16 pitch = 0x05B0;
     // x and z offsets towards the camera
     f32 xOff = sMarioCamState->pos[0] + sins(camYaw) * 40.f;
     f32 zOff = sMarioCamState->pos[2] + coss(camYaw) * 40.f;
 
-    floorDY = find_floor(xOff, sMarioCamState->pos[1], zOff, &floor) - sMarioCamState->pos[1];
+#ifdef CENTERED_COLLISION
+    f32 floorDY = (find_floor(xOff, (sMarioCamState->pos[1] + gMarioState->midY), zOff, &floor) - sMarioCamState->pos[1]);
+#else
+    f32 floorDY = (find_floor(xOff, sMarioCamState->pos[1], zOff, &floor) - sMarioCamState->pos[1]);
+#endif
 
     if (floor != NULL) {
         if (floor->type != SURFACE_WALL_MISC && floorDY > 0) {
@@ -903,6 +906,7 @@ void pan_ahead_of_player(struct Camera *c) {
     vec3f_add(c->focus, pan);
 }
 
+#ifdef CAMERA_SPECIFIC_FUNCTION_DEFINES
 s16 find_in_bounds_yaw_wdw_bob_thi(Vec3f pos, Vec3f origin, s16 yaw) {
     switch (gCurrLevelArea) {
         case AREA_WDW_MAIN:
@@ -920,6 +924,7 @@ s16 find_in_bounds_yaw_wdw_bob_thi(Vec3f pos, Vec3f origin, s16 yaw) {
     }
     return yaw;
 }
+#endif
 
 /**
  * Rotates the camera around the area's center point.
@@ -939,7 +944,9 @@ s32 update_radial_camera(struct Camera *c, Vec3f focus, Vec3f pos) {
     sAreaYaw = camYaw - sModeOffsetYaw;
     calc_y_to_curr_floor(&posY, 1.f, 200.f, &focusY, 0.9f, 200.f);
     focus_on_mario(focus, pos, posY + yOff, focusY + yOff, sLakituDist + baseDist, pitch, camYaw);
+#ifdef CAMERA_SPECIFIC_FUNCTION_DEFINES
     camYaw = find_in_bounds_yaw_wdw_bob_thi(pos, focus, camYaw);
+#endif
 
     return camYaw;
 }
@@ -3120,7 +3127,10 @@ void update_camera(struct Camera *c) {
     c->mode = gLakituState.mode;
     c->defMode = gLakituState.defMode;
 
+#ifdef CAMERA_SPECIFIC_FUNCTION_DEFINES
     camera_course_processing(c);
+#endif
+
     stub_camera_3(c);
     sCButtonsPressed = find_c_buttons_pressed(sCButtonsPressed, gPlayer1Controller->buttonPressed,gPlayer1Controller->buttonDown);
 
@@ -3599,9 +3609,11 @@ void zoom_out_if_paused_and_outside(struct GraphNodeCamera *camera) {
                 camera->focus[2] = gCamera->areaCenZ;
                 vec3f_get_dist_and_angle(camera->focus, sMarioCamState->pos, &dist, &pitch, &yaw);
                 vec3f_set_dist_and_angle(sMarioCamState->pos, camera->pos, 6000.f, 0x1000, yaw);
+                #ifdef CAMERA_SPECIFIC_FUNCTION_DEFINES
                 if (gCurrLevelNum != LEVEL_THI) {
                     find_in_bounds_yaw_wdw_bob_thi(camera->pos, camera->focus, 0);
                 }
+                #endif
             }
         } else {
             sFramesPaused++;
@@ -4060,7 +4072,7 @@ s32 collide_with_walls(Vec3f pos, f32 offsetY, f32 radius) {
     f32 originOffset;
     f32 offset;
     f32 offsetAbsolute;
-    Vec3f newPos[4];
+    Vec3f newPos[MAX_REFEREMCED_WALLS];
     s32 i;
     s32 numCollisions = 0;
 
diff --git a/src/game/envfx_bubbles.c b/src/game/envfx_bubbles.c
index 771f560..b4050a1 100644
--- a/src/game/envfx_bubbles.c
+++ b/src/game/envfx_bubbles.c
@@ -89,7 +89,6 @@ s32 random_flower_offset(void) {
  */
 void envfx_update_flower(Vec3s centerPos) {
     s32 i;
-    struct FloorGeometry *floorGeo; // unused
     s32 globalTimer = gGlobalTimer;
 
     s16 centerX = centerPos[0];
@@ -101,8 +100,7 @@ void envfx_update_flower(Vec3s centerPos) {
         if (!(gEnvFxBuffer + i)->isAlive) {
             (gEnvFxBuffer + i)->xPos = random_flower_offset() + centerX;
             (gEnvFxBuffer + i)->zPos = random_flower_offset() + centerZ;
-            (gEnvFxBuffer + i)->yPos = find_floor_height_and_data((gEnvFxBuffer + i)->xPos, 10000.0f,
-                                                                  (gEnvFxBuffer + i)->zPos, &floorGeo);
+            (gEnvFxBuffer + i)->yPos = find_floor_height((gEnvFxBuffer + i)->xPos, CELL_HEIGHT_LIMIT, (gEnvFxBuffer + i)->zPos);
             (gEnvFxBuffer + i)->isAlive = TRUE;
             (gEnvFxBuffer + i)->animFrame = random_float() * 5.0f;
         } else if (!(globalTimer & 3)) {
diff --git a/src/game/hud.c b/src/game/hud.c
index a5a5ac2..9fb3ba6 100644
--- a/src/game/hud.c
+++ b/src/game/hud.c
@@ -453,6 +453,19 @@ void render_hud_camera_status(void) {
     gSPDisplayList(gDisplayListHead++, dl_hud_img_end);
 }
 
+#ifdef SURFACE_POOLS_FULL_MESSAGES
+#include "engine/surface_load.h"
+void render_hud_surface_text(void) {
+    if (gSurfacePoolError & NOT_ENOUGH_ROOM_FOR_NODES) {
+        print_text(GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(22), 40, "SURFACE NODE POOL FULL");
+    }
+    
+    if (gSurfacePoolError & NOT_ENOUGH_ROOM_FOR_SURFACES) {
+        print_text(GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(22), 20, "SURFACE POOL FULL");
+    }
+}
+#endif
+
 /**
  * Render HUD strings using hudDisplayFlags with it's render functions,
  * excluding the cannon reticle which detects a camera preset for it.
@@ -492,6 +505,10 @@ void render_hud(void) {
         }
 #endif
 
+#ifdef SURFACE_POOLS_FULL_MESSAGES
+        render_hud_surface_text();
+#endif
+
         if (hudDisplayFlags & HUD_DISPLAY_FLAG_LIVES) {
             render_hud_mario_lives();
         }
diff --git a/src/game/interaction.c b/src/game/interaction.c
index 87fd514..92fd318 100644
--- a/src/game/interaction.c
+++ b/src/game/interaction.c
@@ -1798,13 +1798,21 @@ u32 interact_text(struct MarioState *m, UNUSED u32 interactType, struct Object *
 }
 
 void check_kick_or_punch_wall(struct MarioState *m) {
+#ifdef BETTER_WALL_COLLISION
+    struct WallCollisionData wallData;
+#endif
     if (m->flags & (MARIO_PUNCHING | MARIO_KICKING | MARIO_TRIPPING)) {
         Vec3f detector;
         detector[0] = m->pos[0] + 50.0f * sins(m->faceAngle[1]);
         detector[2] = m->pos[2] + 50.0f * coss(m->faceAngle[1]);
         detector[1] = m->pos[1];
-
-        if (resolve_and_return_wall_collisions(detector, 80.0f, 5.0f) != NULL) {
+#ifdef BETTER_WALL_COLLISION
+        resolve_and_return_wall_collisions(detector, 80.0f, 5.0f, &wallData);
+        if (wallData.numWalls > 0)
+#else
+        if (resolve_and_return_wall_collisions(detector, 80.0f, 5.0f) != NULL)
+#endif
+        {
             if (m->action != ACT_MOVE_PUNCHING || m->forwardVel >= 0.0f) {
                 if (m->action == ACT_PUNCHING) {
                     m->action = ACT_MOVE_PUNCHING;
diff --git a/src/game/mario.c b/src/game/mario.c
index fd3a4b5..1e21e16 100644
--- a/src/game/mario.c
+++ b/src/game/mario.c
@@ -534,6 +534,21 @@ u32 mario_get_terrain_sound_addend(struct MarioState *m) {
 /**
  * Collides with walls and returns the most recent wall.
  */
+#ifdef BETTER_WALL_COLLISION
+void resolve_and_return_wall_collisions(Vec3f pos, f32 offset, f32 radius, struct WallCollisionData *collisionData) {
+    collisionData->x = pos[0];
+    collisionData->y = pos[1];
+    collisionData->z = pos[2];
+    collisionData->radius = radius;
+    collisionData->offsetY = offset;
+
+	find_wall_collisions(collisionData);
+
+    pos[0] = collisionData->x;
+    pos[1] = collisionData->y;
+    pos[2] = collisionData->z;
+}
+#else
 struct Surface *resolve_and_return_wall_collisions(Vec3f pos, f32 offset, f32 radius) {
     struct WallCollisionData collisionData;
     struct Surface *wall = NULL;
@@ -556,15 +571,18 @@ struct Surface *resolve_and_return_wall_collisions(Vec3f pos, f32 offset, f32 ra
     // there are no wall collisions.
     return wall;
 }
+#endif
 
+#ifndef CENTERED_COLLISION
 /**
  * Finds the ceiling from a vec3f horizontally and a height (with 80 vertical buffer).
  */
 f32 vec3f_find_ceil(Vec3f pos, f32 height, struct Surface **ceil) {
     UNUSED u8 filler[4];
 
-    return find_ceil(pos[0], height + 80.0f, pos[2], ceil);
+    return find_ceil(pos[0], height + 3.0f, pos[2], ceil);
 }
+#endif
 
 /**
  * Determines if Mario is facing "downhill."
@@ -1191,6 +1209,24 @@ s32 transition_submerged_to_walking(struct MarioState *m) {
     }
 }
 
+/**
+ * Transitions Mario from a submerged action to an airborne action.
+ * You may want to change these actions to fit your hack
+ */
+s32 transition_submerged_to_airborne(struct MarioState *m) {
+    set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+
+    vec3s_set(m->angleVel, 0, 0, 0);
+
+    if (m->heldObj == NULL) {
+        if (m->input & INPUT_A_DOWN) return set_mario_action(m, ACT_DIVE, 0);
+        else return set_mario_action(m, ACT_FREEFALL, 0);
+    } else {
+        if (m->input & INPUT_A_DOWN) return set_mario_action(m, ACT_HOLD_JUMP, 0);
+        else return set_mario_action(m, ACT_HOLD_FREEFALL, 0);
+    }
+}
+
 /**
  * This is the transition function typically for entering a submerged action for a
  * non-submerged action. This also applies the water surface camera preset.
@@ -1199,7 +1235,8 @@ s32 set_water_plunge_action(struct MarioState *m) {
     m->forwardVel = m->forwardVel / 4.0f;
     m->vel[1] = m->vel[1] / 2.0f;
 
-    m->pos[1] = m->waterLevel - 100;
+    // !BUG: Causes waterbox upwarp
+    // m->pos[1] = m->waterLevel - 100;
 
     m->faceAngle[2] = 0;
 
@@ -1345,9 +1382,13 @@ void update_mario_geometry_inputs(struct MarioState *m) {
     f32 ceilToFloorDist;
 
     f32_find_wall_collision(&m->pos[0], &m->pos[1], &m->pos[2], 60.0f, 50.0f);
-    f32_find_wall_collision(&m->pos[0], &m->pos[1], &m->pos[2], 30.0f, 24.0f);
+    f32_find_wall_collision(&m->pos[0], &m->pos[1], &m->pos[2], 30.0f, 25.0f);
 
-    m->floorHeight = find_floor(m->pos[0], m->pos[1], m->pos[2], &m->floor);
+#ifdef CENTERED_COLLISION
+    m->floorHeight = find_floor(m->pos[0], (m->pos[1] + m->midY),  m->pos[2], &m->floor);
+#else
+    m->floorHeight = find_floor(m->pos[0],  m->pos[1],  m->pos[2], &m->floor);
+#endif
 
     // If Mario is OOB, move his position to his graphical position (which was not updated)
     // and check for the floor there.
@@ -1355,10 +1396,18 @@ void update_mario_geometry_inputs(struct MarioState *m) {
     // since the graphical position was not Mario's previous location.
     if (m->floor == NULL) {
         vec3f_copy(m->pos, m->marioObj->header.gfx.pos);
+#ifdef CENTERED_COLLISION
+        m->floorHeight = find_floor(m->pos[0], (m->pos[1] + m->midY), m->pos[2], &m->floor);
+#else
         m->floorHeight = find_floor(m->pos[0], m->pos[1], m->pos[2], &m->floor);
+#endif
     }
+#ifdef CENTERED_COLLISION
+    m->ceilHeight = find_ceil(m->pos[0], (m->pos[1] + m->midY), m->pos[2], &m->ceil);
+#else
+    m->ceilHeight = vec3f_find_ceil(m->pos, m->pos[1], &m->ceil);
+#endif
 
-    m->ceilHeight = vec3f_find_ceil(&m->pos[0], m->floorHeight, &m->ceil);
     gasLevel = find_poison_gas_level(m->pos[0], m->pos[2]);
     m->waterLevel = find_water_level(m->pos[0], m->pos[2]);
 
@@ -1711,6 +1760,10 @@ void mario_update_hitbox_and_cap_model(struct MarioState *m) {
         m->marioObj->hitboxHeight = 160.0f;
     }
 
+#ifdef CENTERED_COLLISION
+    m->midY = ((m->action == ACT_SQUISHED) ? 0.0f : (m->marioObj->hitboxHeight / 2.0f));
+#endif
+
     if ((m->flags & MARIO_TELEPORTING) && (m->fadeWarpOpacity != 0xFF)) {
         bodyState->modelState &= ~0xFF;
         bodyState->modelState |= (0x100 | m->fadeWarpOpacity);
@@ -1901,8 +1954,11 @@ void init_mario(void) {
     vec3s_set(gMarioState->angleVel, 0, 0, 0);
     vec3s_to_vec3f(gMarioState->pos, gMarioSpawnInfo->startPos);
     vec3f_set(gMarioState->vel, 0, 0, 0);
-    gMarioState->floorHeight =
-        find_floor(gMarioState->pos[0], gMarioState->pos[1], gMarioState->pos[2], &gMarioState->floor);
+#ifdef CENTERED_COLLISION
+    gMarioState->floorHeight = find_floor(gMarioState->pos[0], (gMarioState->pos[1] + gMarioState->midY), gMarioState->pos[2], &gMarioState->floor);
+#else
+    gMarioState->floorHeight = find_floor(gMarioState->pos[0], gMarioState->pos[1], gMarioState->pos[2], &gMarioState->floor);
+#endif
 
     if (gMarioState->pos[1] < gMarioState->floorHeight) {
         gMarioState->pos[1] = gMarioState->floorHeight;
diff --git a/src/game/mario.h b/src/game/mario.h
index 0c573b8..d902bd2 100644
--- a/src/game/mario.h
+++ b/src/game/mario.h
@@ -6,6 +6,8 @@
 #include "macros.h"
 #include "types.h"
 
+#include "engine/surface_collision.h"
+
 s32 is_anim_at_end(struct MarioState *m);
 s32 is_anim_past_end(struct MarioState *m);
 s16 set_mario_animation(struct MarioState *m, s32 targetAnimID);
@@ -28,8 +30,14 @@ void play_mario_sound(struct MarioState *m, s32 primarySoundBits, s32 scondarySo
 void mario_set_forward_vel(struct MarioState *m, f32 speed);
 s32 mario_get_floor_class(struct MarioState *m);
 u32 mario_get_terrain_sound_addend(struct MarioState *m);
+#ifdef BETTER_WALL_COLLISION
+void resolve_and_return_wall_collisions(Vec3f pos, f32 offset, f32 radius, struct WallCollisionData *collisionData);
+#else
 struct Surface *resolve_and_return_wall_collisions(Vec3f pos, f32 offset, f32 radius);
+#endif
+#ifndef CENTERED_COLLISION
 f32 vec3f_find_ceil(Vec3f pos, f32 height, struct Surface **ceil);
+#endif
 s32 mario_facing_downhill(struct MarioState *m, s32 turnYaw);
 u32 mario_floor_is_slippery(struct MarioState *m);
 s32 mario_floor_is_slope(struct MarioState *m);
@@ -46,6 +54,7 @@ s32 hurt_and_set_mario_action(struct MarioState *m, u32 action, u32 actionArg, s
 s32 check_common_action_exits(struct MarioState *m);
 s32 check_common_hold_action_exits(struct MarioState *m);
 s32 transition_submerged_to_walking(struct MarioState *m);
+s32 transition_submerged_to_airborne(struct MarioState *m);
 s32 set_water_plunge_action(struct MarioState *m);
 u32 update_and_return_cap_flags(struct MarioState *m);
 s32 execute_mario_action(UNUSED struct Object *o);
diff --git a/src/game/mario_actions_automatic.c b/src/game/mario_actions_automatic.c
index 63d0470..6a129cf 100644
--- a/src/game/mario_actions_automatic.c
+++ b/src/game/mario_actions_automatic.c
@@ -88,7 +88,11 @@ s32 set_pole_position(struct MarioState *m, f32 offsetY) {
     collided = f32_find_wall_collision(&m->pos[0], &m->pos[1], &m->pos[2], 60.0f, 50.0f);
     collided |= f32_find_wall_collision(&m->pos[0], &m->pos[1], &m->pos[2], 30.0f, 24.0f);
 
+#ifdef CENTERED_COLLISION
+    ceilHeight = find_ceil(m->pos[0], (m->pos[1] + m->midY), m->pos[2], &ceil);
+#else
     ceilHeight = vec3f_find_ceil(m->pos, m->pos[1], &ceil);
+#endif
     if (m->pos[1] > ceilHeight - 160.0f) {
         m->pos[1] = ceilHeight - 160.0f;
         marioObj->oMarioPolePos = m->pos[1] - m->usedObj->oPosY;
@@ -311,16 +315,29 @@ s32 act_top_of_pole(struct MarioState *m) {
 }
 
 s32 perform_hanging_step(struct MarioState *m, Vec3f nextPos) {
-    UNUSED u8 filler[4];
+#ifdef BETTER_WALL_COLLISION
+    struct WallCollisionData wallData;
+#endif
     struct Surface *ceil;
     struct Surface *floor;
     f32 ceilHeight;
     f32 floorHeight;
     f32 ceilOffset;
 
-    m->wall = resolve_and_return_wall_collisions(nextPos, 50.0f, 50.0f);
-    floorHeight = find_floor(nextPos[0], nextPos[1], nextPos[2], &floor);
-    ceilHeight = vec3f_find_ceil(nextPos, floorHeight, &ceil);
+#ifdef BETTER_WALL_COLLISION
+    resolve_and_return_wall_collisions(nextPos, 50.0f, 50.0f, &wallData);
+    m->wall     = wallData.walls[0];
+#else
+    m->wall     = resolve_and_return_wall_collisions(nextPos, 50.0f, 50.0f);
+#endif
+
+#ifdef CENTERED_COLLISION
+    floorHeight = find_floor(  nextPos[0], (nextPos[1] + m->midY), nextPos[2], &floor);
+    ceilHeight  = find_ceil(nextPos[0], (nextPos[1] + m->midY), nextPos[2], &ceil);
+#else
+    floorHeight = find_floor(  nextPos[0], nextPos[1], nextPos[2], &floor);
+    ceilHeight  = vec3f_find_ceil(nextPos, nextPos[1], &ceil);
+#endif
 
     if (floor == NULL) {
         return HANG_HIT_CEIL_OR_OOB;
@@ -621,6 +638,10 @@ s32 act_ledge_grab(struct MarioState *m) {
         m->actionTimer++;
     }
 
+#ifdef FIX_LEDGE_GRABS
+    if ((m->wall != NULL) && ((m->wall->normal.y > MIN_FLOOR_NORMAL_Y) || (m->wall->normal.y < MAX_CEIL_NORMAL_Y))) return let_go_of_ledge(m);
+#endif
+
     if (m->floor->normal.y < 0.9063078f) {
         return let_go_of_ledge(m);
     }
diff --git a/src/game/mario_actions_cutscene.c b/src/game/mario_actions_cutscene.c
index eb2f7a4..b868e8d 100644
--- a/src/game/mario_actions_cutscene.c
+++ b/src/game/mario_actions_cutscene.c
@@ -550,6 +550,9 @@ s32 act_reading_sign(struct MarioState *m) {
 }
 
 s32 act_debug_free_move(struct MarioState *m) {
+#ifdef BETTER_WALL_COLLISION
+    struct WallCollisionData wallData;
+#endif
     struct Surface *surf;
     f32 floorHeight;
     Vec3f pos;
@@ -577,9 +580,18 @@ s32 act_debug_free_move(struct MarioState *m) {
         pos[2] += 32.0f * speed * coss(m->intendedYaw);
     }
 
-    resolve_and_return_wall_collisions(pos, 60.0f, 50.0f);
+#ifdef BETTER_WALL_COLLISION
+    resolve_and_return_wall_collisions(pos, 60.0f, 50.0f, &wallData);
+    m->wall = ((wallData.numWalls > 0) ? wallData.walls[0] : NULL); //! only returns first wall
+#else
+    m->wall = resolve_and_return_wall_collisions(pos, 60.0f, 50.0f);
+#endif
 
+#ifdef CENTERED_COLLISION
+    floorHeight = find_floor(pos[0], (pos[1] + m->midY), pos[2], &surf);
+#else
     floorHeight = find_floor(pos[0], pos[1], pos[2], &surf);
+#endif
     if (surf != NULL) {
         if (pos[1] < floorHeight) {
             pos[1] = floorHeight;
@@ -1604,13 +1616,26 @@ s32 act_squished(struct MarioState *m) {
             break;
     }
 
+#ifdef BETTER_CEILING_HANDLING
+    m->actionArg++;
+    if ((m->floor != NULL) && (m->ceil != NULL) && ((m->actionArg > 8) || (m->floor->type == SURFACE_BURNING) || (m->ceil->type == SURFACE_BURNING))) {
+        // steep floor
+        if (m->floor->normal.y < 0.9063078f)
+#else
     // steep floor
-    if (m->floor != NULL && m->floor->normal.y < 0.5f) {
+    if (m->floor != NULL && m->floor->normal.y < 0.5f)
+#endif
+    {
         surfAngle = atan2s(m->floor->normal.z, m->floor->normal.x);
         underSteepSurf = TRUE;
     }
     // steep ceiling
-    if (m->ceil != NULL && -0.5f < m->ceil->normal.y) {
+#ifdef BETTER_CEILING_HANDLING
+        if (-0.9063078f < m->ceil->normal.y)
+#else
+    if (m->ceil != NULL && -0.5f < m->ceil->normal.y)
+#endif
+    {
         surfAngle = atan2s(m->ceil->normal.z, m->ceil->normal.x);
         underSteepSurf = TRUE;
     }
@@ -1628,6 +1653,9 @@ s32 act_squished(struct MarioState *m) {
             return FALSE;
         }
     }
+#ifdef BETTER_CEILING_HANDLING
+    }
+#endif
 
     // squished for more than 10 seconds, so kill Mario
     if (m->actionArg++ > 300) {
diff --git a/src/game/mario_actions_moving.c b/src/game/mario_actions_moving.c
index 5a083ac..98eebfc 100644
--- a/src/game/mario_actions_moving.c
+++ b/src/game/mario_actions_moving.c
@@ -133,7 +133,11 @@ void check_ledge_climb_down(struct MarioState *m) {
         wallCols.offsetY = -10.0f;
 
         if (find_wall_collisions(&wallCols) != 0) {
+#ifdef CENTERED_COLLISION
+            floorHeight = find_floor(wallCols.x, (wallCols.y + m->midY), wallCols.z, &floor);
+#else
             floorHeight = find_floor(wallCols.x, wallCols.y, wallCols.z, &floor);
+#endif
             if (floor != NULL && (wallCols.y - floorHeight > 160.0f)) {
                 wall = wallCols.walls[wallCols.numWalls - 1];
                 wallAngle = atan2s(wall->normal.z, wall->normal.x);
diff --git a/src/game/mario_actions_object.c b/src/game/mario_actions_object.c
index c7341eb..00b214f 100644
--- a/src/game/mario_actions_object.c
+++ b/src/game/mario_actions_object.c
@@ -313,6 +313,9 @@ s32 act_stomach_slide_stop(struct MarioState *m) {
 }
 
 s32 act_picking_up_bowser(struct MarioState *m) {
+#ifdef CENTERED_COLLISION
+    if (m->pos[1] > m->floorHeight) m->pos[1] = m->floorHeight;
+#endif
     if (m->actionState == 0) {
         m->actionState = 1;
         m->angleVel[1] = 0;
diff --git a/src/game/mario_actions_stationary.c b/src/game/mario_actions_stationary.c
index 597e41d..f890b8d 100644
--- a/src/game/mario_actions_stationary.c
+++ b/src/game/mario_actions_stationary.c
@@ -501,6 +501,12 @@ s32 act_standing_against_wall(struct MarioState *m) {
         return set_mario_action(m, ACT_PUNCHING, 0);
     }
 
+#ifdef BETTER_WALL_COLLISION
+    if (m->wall == NULL) {
+        return set_mario_action(m, ACT_IDLE, 0);
+    }
+#endif
+
     set_mario_animation(m, MARIO_ANIM_STAND_AGAINST_WALL);
     stationary_ground_step(m);
     return FALSE;
diff --git a/src/game/mario_actions_submerged.c b/src/game/mario_actions_submerged.c
index 72fc656..499a513 100644
--- a/src/game/mario_actions_submerged.c
+++ b/src/game/mario_actions_submerged.c
@@ -16,6 +16,9 @@
 #include "behavior_data.h"
 #include "level_table.h"
 #include "rumble_init.h"
+#ifdef UNDERWATER_STEEP_FLOORS_AS_WALLS
+#include "object_list_processor.h"
+#endif
 
 #define MIN_SWIM_STRENGTH 160
 #define MIN_SWIM_SPEED 16.0f
@@ -67,54 +70,112 @@ static f32 get_buoyancy(struct MarioState *m) {
     return buoyancy;
 }
 
-static u32 perform_water_full_step(struct MarioState *m, Vec3f nextPos) {
+#if WATER_NUM_STEPS > 1
+static u32 perform_water_quarter_step(struct MarioState *m, Vec3f nextPos) {
+#ifdef BETTER_WALL_COLLISION
+    struct WallCollisionData wallData;
+#else
     struct Surface *wall;
+#endif
     struct Surface *ceil;
     struct Surface *floor;
     f32 ceilHeight;
     f32 floorHeight;
-
-    wall = resolve_and_return_wall_collisions(nextPos, 10.0f, 110.0f);
+    f32 ceilAmt;
+    // f32 floorAmt;
+#ifdef BETTER_WALL_COLLISION
+    m->wall = NULL;
+#ifdef UNDERWATER_STEEP_FLOORS_AS_WALLS
+    gIncludeSteepFloorsInWallCollisionCheck = TRUE;
+#endif
+    resolve_and_return_wall_collisions(nextPos, 10.0f, 110.0f, &wallData);
+#else
+    wall        = resolve_and_return_wall_collisions(nextPos, 10.0f, 110.0f);
+#endif
+#ifdef CENTERED_COLLISION
+    floorHeight = find_floor(nextPos[0], (nextPos[1] + m->midY), nextPos[2], &floor);
+    ceilHeight  = find_ceil( nextPos[0], (nextPos[1] + m->midY), nextPos[2], &ceil);
+#else
     floorHeight = find_floor(nextPos[0], nextPos[1], nextPos[2], &floor);
-    ceilHeight = vec3f_find_ceil(nextPos, floorHeight, &ceil);
-
-    if (floor == NULL) {
-        return WATER_STEP_CANCELLED;
+    ceilHeight  = vec3f_find_ceil(nextPos, nextPos[1], &ceil);
+#endif
+    if (floor == NULL) return WATER_STEP_CANCELLED;
+    if ((ceil != NULL) && (((nextPos[1] + 160.0f) >= ceilHeight) || ((ceilHeight - floorHeight) < 160.0f))) {
+        ceilAmt = ((nextPos[1] + 160.0f) - ceilHeight);
+        nextPos[0] += (ceil->normal.x * ceilAmt);
+        nextPos[2] += (ceil->normal.z * ceilAmt);
+        nextPos[1] = (ceilHeight - 160.0f);
+        vec3f_copy(m->pos, nextPos);
+        m->floor       = floor;
+        m->floorHeight = floorHeight;
+        if (wallData.numWalls > 0) m->wall = wallData.walls[0]; //! only returns the first wall
+        return WATER_STEP_HIT_CEILING;
     }
-
+    if (nextPos[1] <= floorHeight) {
+        nextPos[1]  = floorHeight;
+        vec3f_copy(m->pos, nextPos);
+        m->floor       = floor;
+        m->floorHeight = floorHeight;
+        if (wallData.numWalls > 0) m->wall = wallData.walls[0]; //! only returns the first wall
+        return WATER_STEP_HIT_FLOOR;
+    }
+    vec3f_copy(m->pos, nextPos);
+    m->floor       = floor;
+    m->floorHeight = floorHeight;
+    m->ceil        = ceil;
+    if (wallData.numWalls > 0) {
+        m->wall = wallData.walls[0]; //! only returns the first wall
+        return WATER_STEP_HIT_WALL;
+    } else {
+        return WATER_STEP_NONE;
+    }
+}
+#else
+static u32 perform_water_full_step(struct MarioState *m, Vec3f nextPos) {
+#ifdef BETTER_WALL_COLLISION
+    struct WallCollisionData wallData;
+#endif
+    struct Surface *wall;
+    struct Surface *ceil;
+    struct Surface *floor;
+    f32 ceilHeight;
+    f32 floorHeight;
+#ifdef BETTER_WALL_COLLISION
+    resolve_and_return_wall_collisions(nextPos, 10.0f, 110.0f, &wallData);
+    wall = wallData.walls[0];
+#else
+    wall        = resolve_and_return_wall_collisions(nextPos, 10.0f, 110.0f);
+#endif
+#ifdef CENTERED_COLLISION
+    floorHeight = find_floor(nextPos[0], (nextPos[1] + m->midY), nextPos[2], &floor);
+    ceilHeight  = find_ceil( nextPos[0], (nextPos[1] + m->midY), nextPos[2], &ceil);
+#else
+    floorHeight = find_floor(nextPos[0], nextPos[1], nextPos[2], &floor);
+    ceilHeight  = vec3f_find_ceil(nextPos, nextPos[1], &ceil);
+#endif
+    if (floor == NULL) return WATER_STEP_CANCELLED;
     if (nextPos[1] >= floorHeight) {
-        if (ceilHeight - nextPos[1] >= 160.0f) {
+        if ((ceilHeight - nextPos[1]) >= 160.0f) {
             vec3f_copy(m->pos, nextPos);
-            m->floor = floor;
+            m->floor       = floor;
             m->floorHeight = floorHeight;
-
-            if (wall != NULL) {
-                return WATER_STEP_HIT_WALL;
-            } else {
-                return WATER_STEP_NONE;
-            }
+            return ((wall != NULL) ? WATER_STEP_HIT_WALL : WATER_STEP_NONE);
         }
-
-        if (ceilHeight - floorHeight < 160.0f) {
-            return WATER_STEP_CANCELLED;
-        }
-
+        if ((ceilHeight - floorHeight) < 160.0f) return WATER_STEP_CANCELLED;
         //! Water ceiling downwarp
-        vec3f_set(m->pos, nextPos[0], ceilHeight - 160.0f, nextPos[2]);
-        m->floor = floor;
+        vec3f_set(m->pos, nextPos[0], (ceilHeight - 160.0f), nextPos[2]);
+        m->floor       = floor;
         m->floorHeight = floorHeight;
         return WATER_STEP_HIT_CEILING;
     } else {
-        if (ceilHeight - floorHeight < 160.0f) {
-            return WATER_STEP_CANCELLED;
-        }
-
+        if ((ceilHeight - floorHeight) < 160.0f) return WATER_STEP_CANCELLED;
         vec3f_set(m->pos, nextPos[0], floorHeight, nextPos[2]);
-        m->floor = floor;
+        m->floor       = floor;
         m->floorHeight = floorHeight;
         return WATER_STEP_HIT_FLOOR;
     }
 }
+#endif
 
 static void apply_water_current(struct MarioState *m, Vec3f step) {
     s32 i;
@@ -165,32 +226,42 @@ static void apply_water_current(struct MarioState *m, Vec3f step) {
 }
 
 static u32 perform_water_step(struct MarioState *m) {
-    UNUSED u8 filler[4];
-    u32 stepResult;
+    u32 stepResult = WATER_STEP_NONE;
     Vec3f nextPos;
     Vec3f step;
     struct Object *marioObj = m->marioObj;
-
     vec3f_copy(step, m->vel);
-
-    if (m->action & ACT_FLAG_SWIMMING) {
-        apply_water_current(m, step);
+    if (m->action & ACT_FLAG_SWIMMING) apply_water_current(m, step);
+#if WATER_NUM_STEPS > 1
+ #ifdef VARIABLE_STEPS
+    const f32 speed = (m->moveSpeed / 8.0f);
+    const f32 numSteps = MAX(WATER_NUM_STEPS, speed);
+ #else
+    const f32 numSteps = WATER_NUM_STEPS;
+ #endif
+    u32 i;
+    for (i = 0; i < numSteps; i++) {
+        nextPos[0] = (m->pos[0] + (step[0] / numSteps));
+        nextPos[1] = (m->pos[1] + (step[1] / numSteps));
+        nextPos[2] = (m->pos[2] + (step[2] / numSteps));
+        // If Mario is at the surface, keep him there?
+        if (nextPos[1] > (m->waterLevel - 80)) {
+            nextPos[1] = (m->waterLevel - 80);
+            m->vel[1]  = 0.0f;
+        }
+        stepResult = perform_water_quarter_step(m, nextPos);
+        if (stepResult == WATER_STEP_CANCELLED) break;
     }
-
-    nextPos[0] = m->pos[0] + step[0];
-    nextPos[1] = m->pos[1] + step[1];
-    nextPos[2] = m->pos[2] + step[2];
-
-    if (nextPos[1] > m->waterLevel - 80) {
-        nextPos[1] = m->waterLevel - 80;
-        m->vel[1] = 0.0f;
+#else
+    vec3f_sum(nextPos, m->pos, step);
+    if (nextPos[1] > (m->waterLevel - 80)) {
+        nextPos[1] = (m->waterLevel - 80);
+        m->vel[1]  = 0.0f;
     }
-
     stepResult = perform_water_full_step(m, nextPos);
-
+#endif
     vec3f_copy(marioObj->header.gfx.pos, m->pos);
-    vec3s_set(marioObj->header.gfx.angle, -m->faceAngle[0], m->faceAngle[1], m->faceAngle[2]);
-
+    vec3s_set( marioObj->header.gfx.angle, -m->faceAngle[0], m->faceAngle[1], m->faceAngle[2]);
     return stepResult;
 }
 
@@ -1511,7 +1582,13 @@ static s32 act_hold_metal_water_fall_land(struct MarioState *m) {
 static s32 check_common_submerged_cancels(struct MarioState *m) {
     if (m->pos[1] > m->waterLevel - 80) {
         if (m->waterLevel - 80 > m->floorHeight) {
-            m->pos[1] = m->waterLevel - 80;
+            // m->pos[1] = m->waterLevel - 80; //! BUG: Downwarp swimming out of waterfalls
+            if (m->pos[1] - (m->waterLevel - 80) < 50) {
+                m->pos[1] = m->waterLevel - 80; // lock mario to top if the falloff isn't big enough
+            } else {
+                // m->pos[1] = m->waterLevel - 80; //! BUG: Downwarp swimming out of waterfalls
+                return transition_submerged_to_airborne(m);
+            }
         } else {
             //! If you press B to throw the shell, there is a ~5 frame window
             // where your held object is the shell, but you are not in the
diff --git a/src/game/mario_step.c b/src/game/mario_step.c
index fd07d7b..923c165 100644
--- a/src/game/mario_step.c
+++ b/src/game/mario_step.c
@@ -8,6 +8,8 @@
 #include "game_init.h"
 #include "interaction.h"
 #include "mario_step.h"
+#include "object_helpers.h"
+#include "camera.h"
 
 #ifdef CHEATS_ACTIONS
 #include "extras/cheats.h"
@@ -276,25 +278,90 @@ s32 stationary_ground_step(struct MarioState *m) {
 extern s32 analog_stick_held_back(struct MarioState *m);
 
 static s32 perform_ground_quarter_step(struct MarioState *m, Vec3f nextPos) {
+#ifdef BETTER_WALL_COLLISION
+    struct WallCollisionData lowerWall, upperWall;
+    s16 i;
+#else
+ #ifndef SKIP_GROUND_LOWER_WALL
     UNUSED struct Surface *lowerWall;
+ #endif 
     struct Surface *upperWall;
+#endif
     struct Surface *ceil;
     struct Surface *floor;
     f32 ceilHeight;
     f32 floorHeight;
     f32 waterLevel;
 
+#if NULL_FLOOR_STEPS > 0
+    u32 missedFloors = 0;
+    Vec3f startPos;
+#endif
+#ifdef BETTER_WALL_COLLISION
+    // Check for walls
+    resolve_and_return_wall_collisions(nextPos, 30.0f, 24.0f, &lowerWall);
+    resolve_and_return_wall_collisions(nextPos, 60.0f, 50.0f, &upperWall);
+#else
+ #ifndef SKIP_GROUND_LOWER_WALL
     lowerWall = resolve_and_return_wall_collisions(nextPos, 30.0f, 24.0f);
+ #endif
     upperWall = resolve_and_return_wall_collisions(nextPos, 60.0f, 50.0f);
-
+#endif
+    // Check for a floor
+#ifdef CENTERED_COLLISION
+    floorHeight = find_floor(nextPos[0], (nextPos[1] + m->midY), nextPos[2], &floor);
+#else
     floorHeight = find_floor(nextPos[0], nextPos[1], nextPos[2], &floor);
-    ceilHeight = vec3f_find_ceil(nextPos, floorHeight, &ceil);
+#endif
+    // m->wall     = NULL;
+#if NULL_FLOOR_STEPS > 0
+    // Save the current position in case the next position is a null floor
+    vec3f_copy(startPos, nextPos);
+    // Check for null floors
+    while ((floor == NULL) && (missedFloors < NULL_FLOOR_STEPS)) {
+        nextPos[0] += (m->floor->normal.y * (m->vel[0] / AIR_NUM_STEPS));
+        nextPos[2] += (m->floor->normal.y * (m->vel[2] / AIR_NUM_STEPS));
+ #ifdef BETTER_WALL_COLLISION
+        resolve_and_return_wall_collisions(nextPos, 30.0f, 24.0f, &lowerWall);
+        resolve_and_return_wall_collisions(nextPos, 60.0f, 50.0f, &upperWall);
+ #else
+  #ifndef SKIP_GROUND_LOWER_WALL
+        lowerWall = resolve_and_return_wall_collisions(nextPos, 30.0f, 24.0f);
+  #endif
+        upperWall = resolve_and_return_wall_collisions(nextPos, 60.0f, 50.0f);
+ #endif
+ #ifdef CENTERED_COLLISION
+        floorHeight = find_floor(nextPos[0], (nextPos[1] + m->midY), nextPos[2], &floor);
+ #else
+        floorHeight = find_floor(nextPos[0], nextPos[1], nextPos[2], &floor);
+ #endif
+        missedFloors++;
+    }
+#endif
+
+    // Check for ceilings in the new position
+#ifdef CENTERED_COLLISION
+    ceilHeight = find_ceil(nextPos[0], (nextPos[1] + m->midY), nextPos[2], &ceil);
+#else
+    ceilHeight = vec3f_find_ceil(nextPos, nextPos[1], &ceil);
+#endif
 
     waterLevel = find_water_level(nextPos[0], nextPos[2]);
 
+#ifndef BETTER_WALL_COLLISION
     m->wall = upperWall;
-
+#endif
+    // If the next floor is null, return to the first position
     if (floor == NULL) {
+#if NULL_FLOOR_STEPS > 0
+        vec3f_copy(nextPos, startPos);
+#ifdef CENTERED_COLLISION
+        ceilHeight = find_ceil(nextPos[0], (nextPos[1] + m->midY), nextPos[2], &ceil);
+#else
+        ceilHeight = vec3f_find_ceil(nextPos, nextPos[1], &ceil);
+#endif
+        waterLevel = find_water_level(nextPos[0], nextPos[2]);
+#endif
         return GROUND_STEP_HIT_WALL_STOP_QSTEPS;
     }
 
@@ -329,45 +396,99 @@ static s32 perform_ground_quarter_step(struct MarioState *m, Vec3f nextPos) {
         return GROUND_STEP_LEFT_GROUND;
     }
 
-    if (floorHeight + 160.0f >= ceilHeight) {
+#ifdef BETTER_CEILING_HANDLING
+    // Handle getting stuck between a sloped floor/ceiling
+    f32 hitboxHeight = m->marioObj->hitboxHeight;
+    f32 ceilToFloorDist = (ceilHeight - nextPos[1]);
+    if (ceil && (ceilToFloorDist < hitboxHeight)) {
+    // if (ceil && ((nextPos[1] + hitboxHeight) > ceilHeight) && (floorHeight < ceilHeight)) {
+        if (nextPos[1] > floorHeight) {
+            nextPos[1] = (ceilHeight - hitboxHeight);
+            // Set Mario's position and floor
+            vec3f_copy(m->pos, nextPos);
+            m->ceil = ceil;
+            m->ceilHeight = ceilHeight;
+            m->floor = ceil;
+            m->floorHeight = floorHeight;
+            return GROUND_STEP_LEFT_GROUND;
+        } else {
+            f32 push = ((hitboxHeight - ceilToFloorDist) / hitboxHeight);
+            m->vel[0]  = (ceil->normal.x * push);
+            m->vel[2]  = (ceil->normal.z * push);
+            m->pos[0] += m->vel[0];
+            m->pos[2] += m->vel[2];
+            if ((m->pos[1] > m->floorHeight) && (m->pos[1] < (m->floorHeight + hitboxHeight))) m->pos[1] = m->floorHeight;
+            return GROUND_STEP_HIT_WALL_STOP_QSTEPS;
+        }
+    }
+#else
+    if (floorHeight + m->marioObj->hitboxHeight >= ceilHeight) {
         return GROUND_STEP_HIT_WALL_STOP_QSTEPS;
     }
+#endif
 
     vec3f_set(m->pos, nextPos[0], floorHeight, nextPos[2]);
     m->floor = floor;
     m->floorHeight = floorHeight;
 
-    if (upperWall != NULL) {
-        s16 wallDYaw = atan2s(upperWall->normal.z, upperWall->normal.x) - m->faceAngle[1];
-
-        if (wallDYaw >= 0x2AAA && wallDYaw <= 0x5555) {
-            return GROUND_STEP_NONE;
-        }
-        if (wallDYaw <= -0x2AAA && wallDYaw >= -0x5555) {
-            return GROUND_STEP_NONE;
+#ifdef BETTER_WALL_COLLISION
+    if (upperWall.numWalls == 0) {
+        m->wall = NULL;
+    } else {
+        s16 wallDYaw;
+        s16 oldWallDYaw = ((m->wall != NULL) ? abs_angle_diff(atan2s(m->wall->normal.z, m->wall->normal.x), m->faceAngle[1]) : 0x0);
+        for ((i = 0); (i < upperWall.numWalls); (i++)) {
+            wallDYaw = abs_angle_diff(atan2s(upperWall.walls[i]->normal.z, upperWall.walls[i]->normal.x), m->faceAngle[1]);
+            if (wallDYaw >= oldWallDYaw) {
+                oldWallDYaw = wallDYaw;
+                m->wall     = upperWall.walls[i];
+            }
+            // m->wall = upperWall.walls[i];
+            if ((wallDYaw >= DEGREES(60)) && (wallDYaw <= DEGREES(120))) continue;
+            return GROUND_STEP_HIT_WALL_CONTINUE_QSTEPS;
         }
-
+    }
+#else
+    if (upperWall != NULL) {
+        Angle wallDYaw = abs_angle_diff(atan2s(upperWall->normal.z, upperWall->normal.x), m->faceAngle[1]);
+        if ((wallDYaw >= DEGREES(60)) && (wallDYaw <= DEGREES(120))) return GROUND_STEP_NONE;
         return GROUND_STEP_HIT_WALL_CONTINUE_QSTEPS;
     }
+#endif
 
     return GROUND_STEP_NONE;
 }
 
 s32 perform_ground_step(struct MarioState *m) {
-    s32 i;
-    u32 stepResult;
     Vec3f intendedPos;
+    u32 stepResult = GROUND_STEP_NONE;
 
-    for (i = 0; i < 4; i++) {
-        intendedPos[0] = m->pos[0] + m->floor->normal.y * (m->vel[0] / 4.0f);
-        intendedPos[2] = m->pos[2] + m->floor->normal.y * (m->vel[2] / 4.0f);
-        intendedPos[1] = m->pos[1];
-
+// #ifdef BETTER_WALL_COLLISION
+//     m->wall = NULL;
+// #endif
+
+#if GROUND_NUM_STEPS > 1
+ #ifdef VARIABLE_STEPS
+    const f32 speed    = (m->moveSpeed / 8.0f);
+    const f32 numSteps = MAX(GROUND_NUM_STEPS, speed);
+ #else
+    const f32 numSteps = GROUND_NUM_STEPS;
+ #endif
+    s32 i;
+    for ((i = 0); (i < numSteps); (i++)) {
+        intendedPos[0] = (m->pos[0] + (m->floor->normal.y * (m->vel[0] / numSteps)));
+        intendedPos[2] = (m->pos[2] + (m->floor->normal.y * (m->vel[2] / numSteps)));
+        intendedPos[1] =  m->pos[1];
         stepResult = perform_ground_quarter_step(m, intendedPos);
-        if (stepResult == GROUND_STEP_LEFT_GROUND || stepResult == GROUND_STEP_HIT_WALL_STOP_QSTEPS) {
-            break;
-        }
+        if ((stepResult == GROUND_STEP_LEFT_GROUND) || (stepResult == GROUND_STEP_HIT_WALL_STOP_QSTEPS)) break;
     }
+#else
+    // Step once
+    intendedPos[0] = (m->pos[0] + (steepness * m->vel[0]));
+    intendedPos[2] = (m->pos[2] + (steepness * m->vel[2]));
+    intendedPos[1] =  m->pos[1];
+    stepResult     = perform_ground_quarter_step(m, intendedPos);
+#endif
 
     m->terrainSoundAddend = mario_get_terrain_sound_addend(m);
     vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
@@ -379,18 +500,58 @@ s32 perform_ground_step(struct MarioState *m) {
     return stepResult;
 }
 
+#ifdef BETTER_WALL_COLLISION
+struct Surface *check_ledge_grab(struct MarioState *m, struct Surface *grabbedWall, struct Surface *wall, Vec3f intendedPos, Vec3f nextPos, Vec3f ledgePos, struct Surface **ledgeFloor) {
+    struct Surface *returnedWall = wall;
+    if ((m->vel[1] > 0.0f) || (wall == NULL)) return FALSE;
+    //#ifdef EXTREME_FIX_LEDGE_GRABS // had WALL_SLIDE but doesn't exist here
+    //if ((m->action == ACT_FORWARD_ROLLOUT)
+    // || (m->action == ACT_BACKWARD_ROLLOUT)
+    // || analog_stick_held_back(m)) return FALSE;
+    //#endif
+    if (grabbedWall == NULL) grabbedWall = wall;
+    //! find better wall angle?
+    // Return the already grabbed wall if Mario is moving into it more than the newly tested wall
+    if (((grabbedWall->normal.x * m->vel[0]) + (grabbedWall->normal.z * m->vel[2])) < ((wall->normal.x * m->vel[0]) + (wall->normal.z * m->vel[2]))) returnedWall = grabbedWall;
+    f32 displacementX = (nextPos[0] - intendedPos[0]);
+    f32 displacementZ = (nextPos[2] - intendedPos[2]);
+    // Only ledge grab if the wall displaced Mario in the opposite direction of
+    // his velocity.
+    if (((displacementX * m->vel[0]) + (displacementZ * m->vel[2])) > 0.0f) returnedWall = grabbedWall;
+    ledgePos[0] = (nextPos[0] - (wall->normal.x * 60.0f));
+    ledgePos[2] = (nextPos[2] - (wall->normal.z * 60.0f));
+#ifdef CENTERED_COLLISION
+    ledgePos[1] = find_floor(ledgePos[0], (nextPos[1] + m->midY + 100.0f), ledgePos[2], ledgeFloor);
+#else
+    ledgePos[1] = find_floor(ledgePos[0], (nextPos[1] + 100.0f), ledgePos[2], ledgeFloor);
+#endif
+    if ((ledgeFloor == NULL)
+     || (ledgePos[1] < (nextPos[1] + 80.0f))
+     || ((*ledgeFloor)->normal.y < 0.9063078f)) return FALSE;
+    //#ifdef EXTREME_FIX_LEDGE_GRABS
+    //if (((*ledgeFloor)->type == SURFACE_BURNING)
+    // || SURFACE_IS_QUICKSAND((*ledgeFloor)->type)) return FALSE;
+    //#endif
+    // if (ledgePos[1] <= (nextPos[1] + 100.0f)) returnedWall = grabbedWall;
+    return returnedWall;
+}
+#else
 u32 check_ledge_grab(struct MarioState *m, struct Surface *wall, Vec3f intendedPos, Vec3f nextPos) {
     struct Surface *ledgeFloor;
     Vec3f ledgePos;
-    f32 displacementX;
-    f32 displacementZ;
 
     if (m->vel[1] > 0) {
         return FALSE;
     }
 
-    displacementX = nextPos[0] - intendedPos[0];
-    displacementZ = nextPos[2] - intendedPos[2];
+//#ifdef EXTREME_FIX_LEDGE_GRABS // had WALL_SLIDE but doesn't exist here
+    //if ((m->action == ACT_FORWARD_ROLLOUT) || (m->action == ACT_BACKWARD_ROLLOUT) || analog_stick_held_back(m)) {
+    //    return FALSE;
+    //}
+//#endif
+
+    f32 displacementX = nextPos[0] - intendedPos[0];
+    f32 displacementZ = nextPos[2] - intendedPos[2];
 
     // Only ledge grab if the wall displaced Mario in the opposite direction of
     // his velocity.
@@ -398,12 +559,25 @@ u32 check_ledge_grab(struct MarioState *m, struct Surface *wall, Vec3f intendedP
         return FALSE;
     }
 
-    //! Since the search for floors starts at y + 160, we will sometimes grab
-    // a higher ledge than expected (glitchy ledge grab)
     ledgePos[0] = nextPos[0] - wall->normal.x * 60.0f;
     ledgePos[2] = nextPos[2] - wall->normal.z * 60.0f;
-    ledgePos[1] = find_floor(ledgePos[0], nextPos[1] + 160.0f, ledgePos[2], &ledgeFloor);
+    //! Since the search for floors starts at y + 160, we will sometimes grab
+    // a higher ledge than expected (glitchy ledge grab)
+#ifdef FIX_LEDGE_GRABS
+    ledgePos[1] = find_floor(ledgePos[0], (nextPos[1] + (160.0f / 2.0f)), ledgePos[2], &ledgeFloor);
 
+    if ((ledgeFloor == NULL) || (ledgeFloor->normal.y < 0.9063078f)) {
+        return FALSE;
+    }
+
+    //#ifdef EXTREME_FIX_LEDGE_GRABS
+    //if ((ledgeFloor->type == SURFACE_BURNING) || SURFACE_IS_QUICKSAND(ledgeFloor->type)) {
+    //    return FALSE;
+    //}
+    //#endif
+#else
+    ledgePos[1] = find_floor(ledgePos[0], nextPos[1] + 160.0f, ledgePos[2], &ledgeFloor);
+#endif
     if (ledgePos[1] - nextPos[1] <= 100.0f) {
         return FALSE;
     }
@@ -418,30 +592,102 @@ u32 check_ledge_grab(struct MarioState *m, struct Surface *wall, Vec3f intendedP
     m->faceAngle[1] = atan2s(wall->normal.z, wall->normal.x) + 0x8000;
     return TRUE;
 }
+#endif
 
-s32 perform_air_quarter_step(struct MarioState *m, Vec3f intendedPos, u32 stepArg) {
+#ifdef BETTER_WALL_COLLISION
+s32 bonk_or_hit_lava_wall(struct MarioState *m, struct WallCollisionData *wallData) {
+    s16 i;
+    s32 result = AIR_STEP_NONE;
     s16 wallDYaw;
-    Vec3f nextPos;
-    struct Surface *upperWall;
-    struct Surface *lowerWall;
-    struct Surface *ceil;
-    struct Surface *floor;
-    f32 ceilHeight;
-    f32 floorHeight;
-    f32 waterLevel;
-
-    vec3f_copy(nextPos, intendedPos);
+    s16 oldWallDYaw = ((m->wall != NULL) ? abs_angle_diff(atan2s(m->wall->normal.z, m->wall->normal.x), m->faceAngle[1]) : 0x0);
 
-    upperWall = resolve_and_return_wall_collisions(nextPos, 150.0f, 50.0f);
-    lowerWall = resolve_and_return_wall_collisions(nextPos, 30.0f, 50.0f);
+    if (wallData->numWalls == 0) {
+        m->wall = NULL;
+    } else {
+        for (i = 0; i < wallData->numWalls; i++) {
+            if (wallData->walls[i] != NULL) {
+                if (wallData->walls[i]->type == SURFACE_BURNING) {
+                    m->wall = wallData->walls[i];
+                    return AIR_STEP_HIT_LAVA_WALL;
+                }
+                wallDYaw = abs_angle_diff(atan2s(wallData->walls[i]->normal.z, wallData->walls[i]->normal.x), m->faceAngle[1]);
+                // Update wall reference (bonked wall) only if the new wall has a better facing angle
+                if (wallDYaw >= oldWallDYaw) {
+                    oldWallDYaw = wallDYaw;
+                    m->wall     = wallData->walls[i];
+
+//#ifdef WALL_SLIDE (45 is wall kick degrees)
+//                    if ((wallDYaw > DEGREES(180 - 45)) && (m->vel[1] <= 0.0f)) {
+//#else
+                    if (wallDYaw > DEGREES(180 - 45)) {
+//#endif
+                        m->flags |= MARIO_UNKNOWN_30;
+                        result = AIR_STEP_HIT_WALL;
+                    }
+                }
+            }
+        }
+    }
+    return result;
+}
+#endif
 
+s32 perform_air_quarter_step(struct MarioState *m, Vec3f intendedPos, u32 stepArg) {
+#if NULL_FLOOR_STEPS > 0
+    u32 missedFloors = 0;
+    // Vec3f startPos;
+#endif
+    Vec3f nextPos;
+    struct Surface *ceil, *floor;
+    f32 ceilHeight, floorHeight, waterLevel;
+    vec3f_copy(nextPos, intendedPos);
+#ifdef BETTER_WALL_COLLISION
+    s16 i;
+    u32 stepResult = AIR_STEP_NONE;
+    struct WallCollisionData upperWall, lowerWall;
+    Vec3f ledgePos;
+    struct Surface *grabbedWall = NULL;
+    struct Surface *ledgeFloor;
+    m->wall = NULL;
+    resolve_and_return_wall_collisions(nextPos, 150.0f, 50.0f, &upperWall);
+    resolve_and_return_wall_collisions(nextPos,  30.0f, 50.0f, &lowerWall);
+#else
+    struct Surface *upperWall, *lowerWall;
+    Angle wallDYaw;
+    upperWall   = resolve_and_return_wall_collisions(nextPos, 150.0f, 50.0f);
+    lowerWall   = resolve_and_return_wall_collisions(nextPos,  30.0f, 50.0f);
+#endif
+#ifdef CENTERED_COLLISION
+    floorHeight = find_floor(nextPos[0], (nextPos[1] + m->midY), nextPos[2], &floor);
+#else
     floorHeight = find_floor(nextPos[0], nextPos[1], nextPos[2], &floor);
-    ceilHeight = vec3f_find_ceil(nextPos, floorHeight, &ceil);
-
+#endif
+#if NULL_FLOOR_STEPS > 0
+    // vec3f_copy(startPos, nextPos); // why does this crash the game when ledge grabbing?
+    while ((floor == NULL) && (missedFloors < NULL_FLOOR_STEPS)) {
+        nextPos[0] += (m->vel[0] / GROUND_NUM_STEPS);
+        nextPos[2] += (m->vel[2] / GROUND_NUM_STEPS);
+ #ifdef BETTER_WALL_COLLISION
+        resolve_and_return_wall_collisions(nextPos, 150.0f, 50.0f, &upperWall);
+        resolve_and_return_wall_collisions(nextPos,  30.0f, 50.0f, &lowerWall);
+ #else
+        upperWall   = resolve_and_return_wall_collisions(nextPos, 150.0f, 50.0f);
+        lowerWall   = resolve_and_return_wall_collisions(nextPos,  30.0f, 50.0f);
+ #endif
+ #ifdef CENTERED_COLLISION
+        floorHeight = find_floor(nextPos[0], (nextPos[1] + m->midY), nextPos[2], &floor);
+ #else
+        floorHeight = find_floor(nextPos[0], nextPos[1], nextPos[2], &floor);
+ #endif
+        missedFloors++;
+    }
+#endif
+#ifdef CENTERED_COLLISION
+    ceilHeight = find_ceil(nextPos[0], (nextPos[1] + m->midY), nextPos[2], &ceil);
+#else
+    ceilHeight = vec3f_find_ceil(nextPos, nextPos[1], &ceil);
+#endif
     waterLevel = find_water_level(nextPos[0], nextPos[2]);
-
-    m->wall = NULL;
-
     //! The water pseudo floor is not referenced when your intended qstep is
     // out of bounds, so it won't detect you as landing.
 
@@ -467,21 +713,50 @@ s32 perform_air_quarter_step(struct MarioState *m, Vec3f intendedPos, u32 stepAr
 
     //! This check uses f32, but findFloor uses short (overflow jumps)
     if (nextPos[1] <= floorHeight) {
-        if (ceilHeight - floorHeight > 160.0f) {
+        if (ceilHeight - floorHeight > m->marioObj->hitboxHeight) {
             m->pos[0] = nextPos[0];
             m->pos[2] = nextPos[2];
             m->floor = floor;
             m->floorHeight = floorHeight;
         }
 
-        //! When ceilHeight - floorHeight <= 160, the step result says that
-        // Mario landed, but his movement is cancelled and his referenced floor
-        // isn't updated (pedro spots)
         m->pos[1] = floorHeight;
+        m->floor       = floor;
+        m->floorHeight = floorHeight;
         return AIR_STEP_LANDED;
     }
-
-    if (nextPos[1] + 160.0f > ceilHeight) {
+#ifdef BETTER_CEILING_HANDLING
+    f32 hitboxHeight = m->marioObj->hitboxHeight;
+    if ((ceil != NULL) && ((nextPos[1] + hitboxHeight) > ceilHeight)) {
+        if (floorHeight > nextPos[1]) return AIR_STEP_HIT_WALL;
+        if ((m->vel[1] >= 0.0f) && !(m->prevAction & ACT_FLAG_HANGING) && (ceil->type == SURFACE_HANGABLE)) {
+            m->vel[1]   = 0.0f;
+            return AIR_STEP_GRABBED_CEILING;
+        }
+        if (-0.9063078f >= ceil->normal.y) {
+            if (m->vel[1] > 0.0f) m->vel[1] = 0.0f;
+        } else {
+            f32 ceilSteepness = sqrtf(sqr(ceil->normal.x) + sqr(ceil->normal.z));
+            if (abs_angle_diff(atan2s(ceil->normal.z,  ceil->normal.x), m->marioObj->oMoveAngleYaw) <= DEGREES(90)) {
+                if (m->vel[1] > 0.0f) {
+                    m->slideVelX += (ceil->normal.x * m->vel[1] * ceilSteepness);
+                    m->slideVelZ += (ceil->normal.z * m->vel[1] * ceilSteepness);
+                    m->vel[0]    += m->slideVelX;
+                    m->vel[2]    += m->slideVelZ;
+                    m->vel[1]    *= (1.0f + ceil->normal.y);
+                }
+            } else if (m->vel[1] > 0.0f) {
+                m->vel[1] = 0.0f;
+            }
+        }
+        nextPos[1] = (ceilHeight - hitboxHeight);
+        vec3f_copy(m->pos, nextPos);
+        m->floor       = floor;
+        m->floorHeight = floorHeight;
+        return AIR_STEP_NONE;
+    }
+#else
+    if ((nextPos[1] + 160.0f) > ceilHeight) {
         if (m->vel[1] >= 0.0f) {
             m->vel[1] = 0.0f;
 
@@ -507,16 +782,46 @@ s32 perform_air_quarter_step(struct MarioState *m, Vec3f intendedPos, u32 stepAr
         }
 
         m->pos[1] = nextPos[1];
+ #ifdef BETTER_WALL_COLLISION
+        return AIR_STEP_HIT_CEILING;
+ #else
         return AIR_STEP_HIT_WALL;
+ #endif
     }
-
+#endif
     //! When the wall is not completely vertical or there is a slight wall
     // misalignment, you can activate these conditions in unexpected situations
+#ifdef BETTER_WALL_COLLISION
+    if ((stepArg & AIR_STEP_CHECK_LEDGE_GRAB) && (upperWall.numWalls == 0) && (lowerWall.numWalls != 0)) {
+        for ((i = 0); (i < lowerWall.numWalls); (i++)) if ((grabbedWall = check_ledge_grab(m, grabbedWall, lowerWall.walls[i], intendedPos, nextPos, ledgePos, &ledgeFloor)) != NULL) stepResult = AIR_STEP_GRABBED_LEDGE;
+        if ((stepResult == AIR_STEP_GRABBED_LEDGE) && (grabbedWall != NULL) && (ledgeFloor != NULL) && (ledgePos != NULL)) {
+            vec3f_copy(m->pos, ledgePos);
+            m->floor        = ledgeFloor;
+            m->floorHeight  = ledgePos[1];
+            m->floorAngle   = atan2s(ledgeFloor->normal.z, ledgeFloor->normal.x);
+            m->faceAngle[0] = 0x0;
+            m->faceAngle[1] = (atan2s(grabbedWall->normal.z, grabbedWall->normal.x) + DEGREES(180));
+            m->wall         = grabbedWall;
+        } else {
+            vec3f_copy(m->pos, nextPos);
+            m->floor        = floor;
+            m->floorHeight  = floorHeight;
+        }
+        return stepResult;
+    }
+    vec3f_copy(m->pos, nextPos);
+    m->floor        = floor;
+    m->floorHeight  = floorHeight;
+    if (upperWall.numWalls > 0) {
+        stepResult  = bonk_or_hit_lava_wall(m, &upperWall);
+        if (stepResult != AIR_STEP_NONE) return stepResult;
+    }
+    return ((lowerWall.numWalls > 0) ? bonk_or_hit_lava_wall(m, &lowerWall) : AIR_STEP_NONE);
+#else
     if ((stepArg & AIR_STEP_CHECK_LEDGE_GRAB) && upperWall == NULL && lowerWall != NULL) {
         if (check_ledge_grab(m, lowerWall, intendedPos, nextPos)) {
             return AIR_STEP_GRABBED_LEDGE;
         }
-
         vec3f_copy(m->pos, nextPos);
         m->floor = floor;
         m->floorHeight = floorHeight;
@@ -529,19 +834,24 @@ s32 perform_air_quarter_step(struct MarioState *m, Vec3f intendedPos, u32 stepAr
 
     if (upperWall != NULL || lowerWall != NULL) {
         m->wall = upperWall != NULL ? upperWall : lowerWall;
-        wallDYaw = atan2s(m->wall->normal.z, m->wall->normal.x) - m->faceAngle[1];
+        wallDYaw = abs_angle_diff(atan2s(m->wall->normal.z, m->wall->normal.x), m->faceAngle[1]);
 
         if (m->wall->type == SURFACE_BURNING) {
             return AIR_STEP_HIT_LAVA_WALL;
         }
 
-        if (wallDYaw < -0x6000 || wallDYaw > 0x6000) {
+//#ifdef WALL_SLIDE (45 is wall kick degrees)
+//       if ((wallDYaw > DEGREES(180 - 45)) && (m->vel[1] <= 0.0f)) {
+//#else
+         if (wallDYaw > DEGREES(180 - 45)) {
+//#endif
             m->flags |= MARIO_UNKNOWN_30;
             return AIR_STEP_HIT_WALL;
         }
     }
 
     return AIR_STEP_NONE;
+#endif
 }
 
 void apply_twirl_gravity(struct MarioState *m) {
@@ -656,49 +966,50 @@ void apply_vertical_wind(struct MarioState *m) {
 }
 
 s32 perform_air_step(struct MarioState *m, u32 stepArg) {
+    // s16 wallDYaw;
     Vec3f intendedPos;
+    u32 stepResult = AIR_STEP_NONE;
+    // m->wall = NULL;
+#if AIR_NUM_STEPS > 1
+ #ifdef VARIABLE_STEPS
+    const f32 speed    = (m->moveSpeed / 8.0f);
+    const f32 numSteps = MAX(AIR_NUM_STEPS, speed);
+ #else
+    const f32 numSteps = AIR_NUM_STEPS; /* MAX(4.0f, (s32)(sqrtf(sqr(m->vel[0]) + sqr(m->vel[1]) + sqr(m->vel[2])) / 50.0f));*/
+ #endif
     s32 i;
-    s32 quarterStepResult;
-    s32 stepResult = AIR_STEP_NONE;
-
-    m->wall = NULL;
-
-    for (i = 0; i < 4; i++) {
-        intendedPos[0] = m->pos[0] + m->vel[0] / 4.0f;
-        intendedPos[1] = m->pos[1] + m->vel[1] / 4.0f;
-        intendedPos[2] = m->pos[2] + m->vel[2] / 4.0f;
-
+    u32 quarterStepResult;
+    for ((i = 0); (i < numSteps); (i++)) {
+        intendedPos[0] = (m->pos[0] + (m->vel[0] / numSteps));
+        intendedPos[1] = (m->pos[1] + (m->vel[1] / numSteps));
+        intendedPos[2] = (m->pos[2] + (m->vel[2] / numSteps));
         quarterStepResult = perform_air_quarter_step(m, intendedPos, stepArg);
-
         //! On one qf, hit OOB/ceil/wall to store the 2 return value, and continue
         // getting 0s until your last qf. Graze a wall on your last qf, and it will
         // return the stored 2 with a sharply angled reference wall. (some gwks)
-
-        if (quarterStepResult != AIR_STEP_NONE) {
-            stepResult = quarterStepResult;
-        }
-
-        if (quarterStepResult == AIR_STEP_LANDED || quarterStepResult == AIR_STEP_GRABBED_LEDGE
-            || quarterStepResult == AIR_STEP_GRABBED_CEILING
-            || quarterStepResult == AIR_STEP_HIT_LAVA_WALL) {
-            break;
-        }
+        if (quarterStepResult != AIR_STEP_NONE) stepResult = quarterStepResult;
+        if ((quarterStepResult == AIR_STEP_LANDED)
+         || (quarterStepResult == AIR_STEP_GRABBED_LEDGE)
+         || (quarterStepResult == AIR_STEP_GRABBED_CEILING)
+         || (quarterStepResult == AIR_STEP_HIT_LAVA_WALL)) break;
     }
-
-    if (m->vel[1] >= 0.0f) {
-        m->peakHeight = m->pos[1];
-    }
-
+#else
+    // Step once
+    vec3f_sum(intendedPos, m->pos, m->vel);
+    stepResult = perform_air_quarter_step(m, intendedPos, stepArg);
+#endif
+    if (m->vel[1] >= 0.0f) m->peakHeight = m->pos[1];
     m->terrainSoundAddend = mario_get_terrain_sound_addend(m);
-
-    if (m->action != ACT_FLYING) {
-        apply_gravity(m);
-    }
+    if (m->action != ACT_FLYING) apply_gravity(m);
     apply_vertical_wind(m);
-
     vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
-    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
-
+    vec3s_set( m->marioObj->header.gfx.angle, 0x0, m->faceAngle[1], 0x0);
+    /*if (stepResult == AIR_STEP_HIT_WALL && m->wall != NULL) {
+        wallDYaw = atan2s(m->wall->normal.z, m->wall->normal.x) - m->faceAngle[1];
+        if ((stepArg & AIR_STEP_CHECK_BONK) && (wallDYaw < -DEGREES(135) || wallDYaw > DEGREES(135))) {
+            if (m->forwardVel > 16.0f) mario_bonk_reflection(m, (stepArg & AIR_STEP_BONK_NEGATE_SPEED), m->wall);
+        }
+    }*/
     return stepResult;
 }
 
diff --git a/src/game/obj_behaviors.c b/src/game/obj_behaviors.c
index de6dba7..3c17e11 100644
--- a/src/game/obj_behaviors.c
+++ b/src/game/obj_behaviors.c
@@ -430,14 +430,19 @@ s16 object_step(void) {
     f32 objVelX = o->oForwardVel * sins(o->oMoveAngleYaw);
     f32 objVelZ = o->oForwardVel * coss(o->oMoveAngleYaw);
 
+#ifdef CENTERED_COLLISION
+    f32 midY = (objY + (o->hitboxHeight / 2.0f));
     s16 collisionFlags = 0;
-
     // Find any wall collisions, receive the push, and set the flag.
-    if (obj_find_wall(objX + objVelX, objY, objZ + objVelZ, objVelX, objVelZ) == 0) {
-        collisionFlags += OBJ_COL_FLAG_HIT_WALL;
-    }
+    if (!obj_find_wall(objX, midY, objZ, objVelX, objVelZ)) collisionFlags |= OBJ_COL_FLAG_HIT_WALL;
+    floorY = find_floor(objX, midY, objZ, &sObjFloor);
+#else
+    s16 collisionFlags = 0;
+    // Find any wall collisions, receive the push, and set the flag.
+    if (!obj_find_wall(objX, objY, objZ, objVelX, objVelZ)) collisionFlags |= OBJ_COL_FLAG_HIT_WALL;
+    floorY = find_floor(objX, objY, objZ, &sObjFloor);
+#endif
 
-    floorY = find_floor(objX + objVelX, objY, objZ + objVelZ, &sObjFloor);
     if (turn_obj_away_from_steep_floor(sObjFloor, floorY, objVelX, objVelZ) == 1) {
         waterY = find_water_level(objX + objVelX, objZ + objVelZ);
         if (waterY > objY) {
diff --git a/src/game/obj_behaviors.h b/src/game/obj_behaviors.h
index 9755984..fdfb998 100644
--- a/src/game/obj_behaviors.h
+++ b/src/game/obj_behaviors.h
@@ -64,7 +64,7 @@ void butterfly_act_follow_mario(void);
 void butterfly_act_return_home(void);
 void bhv_butterfly_loop(void);
 void bhv_hoot_init(void);
-f32 hoot_find_next_floor(struct FloorGeometry **arg0, f32 arg1);
+f32 hoot_find_next_floor(f32 arg1);
 void hoot_floor_bounce(void);
 void hoot_free_step(s16 fastOscY, s32 speed);
 void hoot_player_set_yaw(void);
diff --git a/src/game/object_helpers.c b/src/game/object_helpers.c
index c4575a7..0e660e3 100644
--- a/src/game/object_helpers.c
+++ b/src/game/object_helpers.c
@@ -171,27 +171,33 @@ Gfx *geo_switch_area(s32 callContext, struct GraphNode *node, UNUSED void *conte
 #else
 Gfx *geo_switch_area(s32 callContext, struct GraphNode *node) {
 #endif
-    s16 sp26;
-    struct Surface *sp20;
+    s16 areaCase;
+    struct Surface *floor;
     UNUSED struct Object *sp1C =
         (struct Object *) gCurGraphNodeObject; // TODO: change global type to Object pointer
     struct GraphNodeSwitchCase *switchCase = (struct GraphNodeSwitchCase *) node;
+    struct Object *roomFocusObj = (gCamera->cutscene && gCutsceneFocus) ? gCutsceneFocus : gMarioObject;
 
     if (callContext == GEO_CONTEXT_RENDER) {
         if (gMarioObject == NULL) {
             switchCase->selectedCase = 0;
         } else {
-            gFindFloorIncludeSurfaceIntangible = TRUE;
-
-            find_floor(gMarioObject->oPosX, gMarioObject->oPosY, gMarioObject->oPosZ, &sp20);
+            // Check if there is an intangible floor in the current cell
+            if (floor_type_exists_in_current_cell(roomFocusObj->oPosX, roomFocusObj->oPosZ, SURFACE_INTANGIBLE, FALSE)) {
+                // there is an intangible floor in the current cell, so look for it.
+                find_room_floor(roomFocusObj->oPosX, roomFocusObj->oPosY, roomFocusObj->oPosZ, &floor);
+            } else {
+                // Since no intangible floors are nearby, use Mario's floor instead.
+                floor = gMarioState->floor;
+            }
 
-            if (sp20) {
-                gMarioCurrentRoom = sp20->room;
-                sp26 = sp20->room - 1;
-                print_debug_top_down_objectinfo("areainfo %d", sp20->room);
+            if (floor) {
+                gMarioCurrentRoom = floor->room;
+                areaCase = floor->room - 1;
+                print_debug_top_down_objectinfo("areainfo %d", floor->room);
 
-                if (sp26 >= 0) {
-                    switchCase->selectedCase = sp26;
+                if (areaCase >= 0) {
+                    switchCase->selectedCase = areaCase;
                 }
             }
         }
@@ -1173,12 +1179,20 @@ void obj_become_tangible(struct Object *obj) {
 
 void cur_obj_update_floor_height(void) {
     struct Surface *floor;
+#ifdef CENTERED_COLLISION
+    o->oFloorHeight = find_floor(o->oPosX, o->oPosY + OBJ_STEP_HEIGHT, o->oPosZ, &floor);
+#else
     o->oFloorHeight = find_floor(o->oPosX, o->oPosY, o->oPosZ, &floor);
+#endif
 }
 
 struct Surface *cur_obj_update_floor_height_and_get_floor(void) {
     struct Surface *floor;
+#ifdef CENTERED_COLLISION
+    o->oFloorHeight = find_floor(o->oPosX, o->oPosY + OBJ_STEP_HEIGHT, o->oPosZ, &floor);
+#else
     o->oFloorHeight = find_floor(o->oPosX, o->oPosY, o->oPosZ, &floor);
+#endif
     return floor;
 }
 
@@ -1214,7 +1228,11 @@ static s32 cur_obj_move_xz(f32 steepSlopeNormalY, s32 careAboutEdgesAndSteepSlop
     f32 intendedX = o->oPosX + o->oVelX;
     f32 intendedZ = o->oPosZ + o->oVelZ;
 
-    f32 intendedFloorHeight = find_floor(intendedX, o->oPosY, intendedZ, &intendedFloor);
+#ifdef CENTERED_COLLISION
+    f32 intendedFloorHeight = find_floor(intendedX, o->oPosY + OBJ_STEP_HEIGHT, intendedZ, &intendedFloor); // find_room_floor?
+#else
+    f32 intendedFloorHeight = find_floor(intendedX, o->oPosY, intendedZ, &intendedFloor); // find_room_floor?
+#endif
     f32 deltaFloorHeight = intendedFloorHeight - o->oFloorHeight;
 
     o->oMoveFlags &= ~OBJ_MOVE_HIT_EDGE;
@@ -1609,11 +1627,14 @@ static void obj_spawn_loot_coins(struct Object *obj, s32 numCoins, f32 sp30,
                                     const BehaviorScript *coinBehavior,
                                     s16 posJitter, s16 model) {
     s32 i;
-    f32 spawnHeight;
     struct Surface *floor;
     struct Object *coin;
 
-    spawnHeight = find_floor(obj->oPosX, obj->oPosY, obj->oPosZ, &floor);
+#ifdef CENTERED_COLLISION
+    f32 spawnHeight = find_floor(obj->oPosX, obj->oPosY + OBJ_STEP_HEIGHT, obj->oPosZ, &floor);
+#else
+    f32 spawnHeight = find_floor(obj->oPosX, obj->oPosY, obj->oPosZ, &floor);
+#endif
     if (obj->oPosY - spawnHeight > 100.0f) {
         spawnHeight = obj->oPosY;
     }
@@ -1691,7 +1712,11 @@ static s32 cur_obj_detect_steep_floor(s16 steepAngleDegrees) {
     if (o->oForwardVel != 0.0f) {
         intendedX = o->oPosX + o->oVelX;
         intendedZ = o->oPosZ + o->oVelZ;
+#ifdef CENTERED_COLLISION
+        intendedFloorHeight = find_floor(intendedX, o->oPosY + OBJ_STEP_HEIGHT, intendedZ, &intendedFloor);
+#else
         intendedFloorHeight = find_floor(intendedX, o->oPosY, intendedZ, &intendedFloor);
+#endif
         deltaFloorHeight = intendedFloorHeight - o->oFloorHeight;
 
         if (intendedFloorHeight < FLOOR_LOWER_LIMIT_MISC) {
@@ -1842,24 +1867,15 @@ void cur_obj_move_standard(s16 steepSlopeAngleDegrees) {
     }
 }
 
-static s32 cur_obj_within_12k_bounds(void) {
-    if (o->oPosX < -12000.0f || 12000.0f < o->oPosX) {
-        return FALSE;
-    }
-
-    if (o->oPosY < -12000.0f || 12000.0f < o->oPosY) {
-        return FALSE;
-    }
-
-    if (o->oPosZ < -12000.0f || 12000.0f < o->oPosZ) {
-        return FALSE;
-    }
-
+static u32 cur_obj_within_bounds(f32 bounds) {
+    if ((o->oPosX < -bounds) || (bounds < o->oPosX)) return FALSE;
+    if ((o->oPosY < -bounds) || (bounds < o->oPosY)) return FALSE;
+    if ((o->oPosZ < -bounds) || (bounds < o->oPosZ)) return FALSE;
     return TRUE;
 }
 
 void cur_obj_move_using_vel_and_gravity(void) {
-    if (cur_obj_within_12k_bounds()) {
+    if (cur_obj_within_bounds(LEVEL_BOUNDARY_MAX + 4096.0f)) {
         o->oPosX += o->oVelX;
         o->oPosZ += o->oVelZ;
         o->oVelY += o->oGravity; //! No terminal velocity
@@ -2405,24 +2421,11 @@ UNUSED static void stub_obj_helpers_5(void) {
 
 void bhv_init_room(void) {
     struct Surface *floor;
-    f32 floorHeight;
+    UNUSED f32 floorHeight;
 
     if (is_item_in_array(gCurrLevelNum, sLevelsWithRooms)) {
-        floorHeight = find_floor(o->oPosX, o->oPosY, o->oPosZ, &floor);
-
-        if (floor != NULL) {
-            if (floor->room != 0) {
-                o->oRoom = floor->room;
-            } else {
-                // Floor probably belongs to a platform object. Try looking
-                // underneath it
-                find_floor(o->oPosX, floorHeight - 100.0f, o->oPosZ, &floor);
-                if (floor != NULL) {
-                    //! Technically possible that the room could still be 0 here
-                    o->oRoom = floor->room;
-                }
-            }
-        }
+        floorHeight = find_room_floor(o->oPosX, o->oPosY, o->oPosZ, &floor);
+        if (floor != NULL) o->oRoom = floor->room;
     } else {
         o->oRoom = -1;
     }
diff --git a/src/game/object_list_processor.c b/src/game/object_list_processor.c
index 87dd3d6..a82138e 100644
--- a/src/game/object_list_processor.c
+++ b/src/game/object_list_processor.c
@@ -148,6 +148,12 @@ struct MemoryPool *gObjectMemoryPool;
 
 s16 gCheckingSurfaceCollisionsForCamera;
 s16 gFindFloorIncludeSurfaceIntangible;
+#ifdef FIND_FLOOR_EXCLUDE_DYNAMIC_CHECK
+s16 gFindFloorExcludeDynamic;
+#endif
+#ifdef UNDERWATER_STEEP_FLOORS_AS_WALLS
+s16 gIncludeSteepFloorsInWallCollisionCheck;
+#endif
 s16 *gEnvironmentRegions;
 s32 gEnvironmentLevels[20];
 s8 gDoorAdjacentRooms[60][2];
@@ -649,6 +655,9 @@ void update_objects(UNUSED s32 unused) {
     gNumRoomedObjectsInMarioRoom = 0;
     gNumRoomedObjectsNotInMarioRoom = 0;
     gCheckingSurfaceCollisionsForCamera = FALSE;
+#ifdef UNDERWATER_STEEP_FLOORS_AS_WALLS
+    gIncludeSteepFloorsInWallCollisionCheck = FALSE;
+#endif
 
     reset_debug_objectinfo();
     stub_debug_5();
diff --git a/src/game/object_list_processor.h b/src/game/object_list_processor.h
index 0ff3905..a1ff2c2 100644
--- a/src/game/object_list_processor.h
+++ b/src/game/object_list_processor.h
@@ -104,6 +104,12 @@ extern struct MemoryPool *gObjectMemoryPool;
 
 extern s16 gCheckingSurfaceCollisionsForCamera;
 extern s16 gFindFloorIncludeSurfaceIntangible;
+#ifdef FIND_FLOOR_EXCLUDE_DYNAMIC_CHECK
+extern s16 gFindFloorExcludeDynamic;
+#endif
+#ifdef UNDERWATER_STEEP_FLOORS_AS_WALLS
+extern s16 gIncludeSteepFloorsInWallCollisionCheck;
+#endif
 extern s16 *gEnvironmentRegions;
 extern s32 gEnvironmentLevels[20];
 extern s8 gDoorAdjacentRooms[60][2];
diff --git a/src/game/paintings.c b/src/game/paintings.c
index 89251e4..8384e12 100644
--- a/src/game/paintings.c
+++ b/src/game/paintings.c
@@ -1329,7 +1329,11 @@ Gfx *geo_painting_update(s32 callContext, UNUSED struct GraphNode *node, UNUSED
         gPaintingUpdateCounter = gAreaUpdateCounter;
 
         // Store Mario's floor and position
-        find_floor(gMarioObject->oPosX, gMarioObject->oPosY, gMarioObject->oPosZ, &surface);
+#ifdef CENTERED_COLLISION
+        find_floor(gMarioObject->oPosX, (gMarioObject->oPosY + (160.0f / 2.0f)), gMarioObject->oPosZ, &surface); //! use gMarioState floor instead?
+#else
+        find_floor(gMarioObject->oPosX, gMarioObject->oPosY, gMarioObject->oPosZ, &surface); //! use gMarioState floor instead?
+#endif
         gPaintingMarioFloorType = surface->type;
         gPaintingMarioXPos = gMarioObject->oPosX;
         gPaintingMarioYPos = gMarioObject->oPosY;
diff --git a/src/game/platform_displacement.c b/src/game/platform_displacement.c
index 1808af2..a6a3d36 100644
--- a/src/game/platform_displacement.c
+++ b/src/game/platform_displacement.c
@@ -3,6 +3,7 @@
 
 #include "engine/math_util.h"
 #include "engine/surface_collision.h"
+#include "game_init.h"
 #include "level_update.h"
 #include "object_fields.h"
 #include "object_helpers.h"
@@ -10,6 +11,8 @@
 #include "platform_displacement.h"
 #include "types.h"
 
+#include "behavior_data.h"
+
 u16 D_8032FEC0 = 0;
 
 u32 unused_8032FEC4[4] = { 0 };
@@ -85,6 +88,148 @@ void set_mario_pos(f32 x, f32 y, f32 z) {
     gMarioStates[0].pos[2] = z;
 }
 
+#ifdef PLATFORM_DISPLACEMENT_2
+static struct PlatformDisplacementInfo sMarioDisplacementInfo;
+static Vec3f sMarioAmountDisplaced;
+
+/**
+ * Upscale or downscale a vector by another vector.
+ */
+static void scale_vec3f(Vec3f dst, Vec3f src, Vec3f scale, u32 doInverted) {
+    if (doInverted) {
+        dst[0] = src[0] / scale[0];
+        dst[1] = src[1] / scale[1];
+        dst[2] = src[2] / scale[2];
+    } else {
+        dst[0] = src[0] * scale[0];
+        dst[1] = src[1] * scale[1];
+        dst[2] = src[2] * scale[2];
+    }
+}
+
+/**
+ * Apply one frame of platform displacement to Mario or an object using the given
+ * platform.
+ */
+void apply_platform_displacement(struct PlatformDisplacementInfo *displaceInfo, Vec3f pos, s16 *yaw, struct Object *platform) {
+    Vec3f platformPos;
+    Vec3f posDifference;
+    Vec3f yawVec;
+    Vec3f scaledPos;
+    // Determine how much Mario turned on his own since last frame
+    s16 yawDifference = *yaw - displaceInfo->prevYaw;
+
+    // Avoid a crash if the platform unloaded its collision while stood on
+    if (platform->header.gfx.throwMatrix == NULL) return;
+
+    vec3f_copy(platformPos, (*platform->header.gfx.throwMatrix)[3]);
+
+    // Determine how far Mario moved on his own since last frame
+    vec3f_copy(posDifference, pos);
+    vec3f_sub(posDifference, displaceInfo->prevPos);
+
+    if ((platform == displaceInfo->prevPlatform) && (gGlobalTimer == displaceInfo->prevTimer + 1)) {
+        // Transform from relative positions to world positions
+        scale_vec3f(scaledPos, displaceInfo->prevTransformedPos, platform->header.gfx.scale, FALSE);
+        linear_mtxf_mul_vec3f(*platform->header.gfx.throwMatrix, pos, scaledPos);
+
+        // Add on how much Mario moved in the previous frame
+        vec3f_add(pos, posDifference);
+
+        // Calculate new yaw
+        linear_mtxf_mul_vec3f(*platform->header.gfx.throwMatrix, yawVec, displaceInfo->prevTransformedYawVec);
+        *yaw = atan2s(yawVec[2], yawVec[0]) + yawDifference;
+    } else {
+        // First frame of standing on the platform, don't calculate a new position
+        vec3f_sub(pos, platformPos);
+    }
+
+    // Apply velocity-based displacement for certain objects (like the TTC Treadmills)
+    if (platform->oFlags & OBJ_FLAG_VELOCITY_PLATFORM) {
+        pos[0] += platform->oVelX;
+        pos[1] += platform->oVelY;
+        pos[2] += platform->oVelZ;
+    }
+
+    // Transform from world positions to relative positions for use next frame
+    linear_mtxf_transpose_mul_vec3f(*platform->header.gfx.throwMatrix, scaledPos, pos);
+    scale_vec3f(displaceInfo->prevTransformedPos, scaledPos, platform->header.gfx.scale, TRUE);
+    vec3f_add(pos, platformPos);
+
+    // If the object is Mario, set inertia
+    if (pos == gMarioState->pos) {
+        vec3f_copy(sMarioAmountDisplaced, pos);
+        vec3f_sub(sMarioAmountDisplaced, displaceInfo->prevPos);
+        vec3f_sub(sMarioAmountDisplaced, posDifference);
+
+        // Make sure inertia isn't set on the first frame otherwise the previous value isn't cleared
+        if ((platform != displaceInfo->prevPlatform) || (gGlobalTimer != displaceInfo->prevTimer + 1)) {
+            vec3f_set(sMarioAmountDisplaced, 0.f, 0.f, 0.f);
+        }
+    }
+
+    // Update info for next frame
+    // Update position
+    vec3f_copy(displaceInfo->prevPos, pos);
+
+    // Set yaw info
+    vec3f_set(yawVec, sins(*yaw), 0, coss(*yaw));
+    linear_mtxf_transpose_mul_vec3f(*platform->header.gfx.throwMatrix, displaceInfo->prevTransformedYawVec, yawVec);
+    displaceInfo->prevYaw = *yaw;
+
+    // Update platform and timer
+    displaceInfo->prevPlatform = platform;
+    displaceInfo->prevTimer = gGlobalTimer;
+}
+
+// Doesn't change in the code, set this to FALSE if you don't want inertia
+static u8 gDoInertia = TRUE;
+
+static u8 sShouldApplyInertia = FALSE;
+static u8 sInertiaFirstFrame = FALSE;
+
+/**
+ * Apply inertia based on Mario's last platform.
+ */
+static void apply_mario_inertia(void) {
+    // On the first frame of leaving the ground, boost Mario's y velocity
+    if (sInertiaFirstFrame) {
+        gMarioState->vel[1] += sMarioAmountDisplaced[1];
+    }
+
+    // Apply sideways inertia
+    gMarioState->pos[0] += sMarioAmountDisplaced[0];
+    gMarioState->pos[2] += sMarioAmountDisplaced[2];
+
+    // Drag
+    sMarioAmountDisplaced[0] *= 0.97f;
+    sMarioAmountDisplaced[2] *= 0.97f;
+
+    // Stop applying inertia once Mario has landed, or when ground pounding
+    if (!(gMarioState->action & ACT_FLAG_AIR) || (gMarioState->action == ACT_GROUND_POUND)) {
+        sShouldApplyInertia = FALSE;
+    }
+}
+
+/**
+ * Apply platform displacement or inertia if required.
+ */
+void apply_mario_platform_displacement(void) {
+    struct Object *platform;
+
+    platform = gMarioPlatform;
+    if (!(gTimeStopState & TIME_STOP_ACTIVE) && gMarioObject != NULL && !(gMarioStates[0].action & ACT_FLAG_INTANGIBLE)) {
+        if (platform != NULL) {
+            apply_platform_displacement(&sMarioDisplacementInfo, gMarioState->pos, &gMarioState->faceAngle[1], platform);
+            sShouldApplyInertia = TRUE;
+            sInertiaFirstFrame = TRUE;
+        } else if (sShouldApplyInertia && gDoInertia) {
+            apply_mario_inertia();
+            sInertiaFirstFrame = FALSE;
+        }
+    }
+}
+#else
 /**
  * Apply one frame of platform rotation to Mario or an object using the given
  * platform. If isMario is false, use gCurrentObject.
@@ -180,6 +325,7 @@ void apply_mario_platform_displacement(void) {
         apply_platform_displacement(TRUE, platform);
     }
 }
+#endif
 
 #ifndef VERSION_JP
 /**
diff --git a/src/game/platform_displacement.h b/src/game/platform_displacement.h
index 556192b..4aa4d23 100644
--- a/src/game/platform_displacement.h
+++ b/src/game/platform_displacement.h
@@ -5,10 +5,27 @@
 
 #include "types.h"
 
+#include "engine/extended_bounds.h"
+
+#ifdef PLATFORM_DISPLACEMENT_2
+struct PlatformDisplacementInfo {
+	Vec3f prevPos;
+	Vec3f prevTransformedPos;
+	Vec3f prevTransformedYawVec;
+	s16 prevYaw;
+	struct Object *prevPlatform;
+	u32 prevTimer;
+};
+#endif
+
 void update_mario_platform(void);
 void get_mario_pos(f32 *x, f32 *y, f32 *z);
 void set_mario_pos(f32 x, f32 y, f32 z);
+#ifdef PLATFORM_DISPLACEMENT_2
+void apply_platform_displacement(struct PlatformDisplacementInfo *displaceInfo, Vec3f pos, s16 *yaw, struct Object *platform);
+#else
 void apply_platform_displacement(u32 isMario, struct Object *platform);
+#endif
 void apply_mario_platform_displacement(void);
 #ifndef VERSION_JP
 void clear_mario_platform(void);
diff --git a/src/game/rendering_graph_node.c b/src/game/rendering_graph_node.c
index 20d05ae..d5a3e28 100644
--- a/src/game/rendering_graph_node.c
+++ b/src/game/rendering_graph_node.c
@@ -2,6 +2,7 @@
 
 #include "area.h"
 #include "engine/math_util.h"
+#include "engine/surface_collision.h"
 #include "game_init.h"
 #include "gfx_dimensions.h"
 #include "main.h"
@@ -44,6 +45,12 @@ Mat4 gMatStackInterpolated[32];
 Mtx *gMatStackInterpolatedFixed[32];
 #endif
 
+#ifdef AUTOMATIC_WORLD_SCALE
+f32 gWorldScale = WORLD_SCALE;
+#else
+f32 gWorldScale = 1.0f;
+#endif
+
 /**
  * Animation nodes have state in global variables, so this struct captures
  * the animation state so a 'context switch' can be made when rendering the
@@ -331,13 +338,25 @@ static void geo_process_perspective(struct GraphNodePerspective *node) {
         f32 aspect = (f32) gCurGraphNodeRoot->width / (f32) gCurGraphNodeRoot->height;
 #endif
 
-        guPerspective(mtx, &perspNorm, node->fov, aspect, node->near, node->far, 1.0f);
+#ifdef AUTOMATIC_WORLD_SCALE
+        s32 nearNode = (node->far / 300);
+
+        if (gCamera) {
+            gWorldScale = MAX(((gCamera->pos[0] * gCamera->pos[0]) + (gCamera->pos[1] * gCamera->pos[1]) + (gCamera->pos[2] * gCamera->pos[2]))/ (0x2000 * 0x2000), 1.0f);
+        } else {
+            gWorldScale = 1.0f;
+        }
+#else
+        s32 nearNode = (node->near);
+#endif
+
+        guPerspective(mtx, &perspNorm, node->fov, aspect, (nearNode / gWorldScale), (node->far / gWorldScale), 1.0f);
 
 #ifdef HIGH_FPS_PC
         if (gGlobalTimer == node->prevTimestamp + 1 && gGlobalTimer != gLakituState.skipCameraInterpolationTimestamp) {
 
             fovInterpolated = (node->prevFov + node->fov) / 2.0f;
-            guPerspective(mtxInterpolated, &perspNorm, fovInterpolated, aspect, node->near, node->far, 1.0f);
+            guPerspective(mtxInterpolated, &perspNorm, fovInterpolated, aspect, (nearNode / gWorldScale), (node->far / gWorldScale), 1.0f);
             gSPPerspNormalize(gDisplayListHead++, perspNorm);
 
             sPerspectivePos = gDisplayListHead;
@@ -368,22 +387,13 @@ static void geo_process_perspective(struct GraphNodePerspective *node) {
  * range of this node.
  */
 static void geo_process_level_of_detail(struct GraphNodeLevelOfDetail *node) {
-#ifdef GBI_FLOATS
-    Mtx *mtx = gMatStackFixed[gMatStackIndex];
-    s16 distanceFromCam = (s32) -mtx->m[3][2]; // z-component of the translation column
-#else
-    // The fixed point Mtx type is defined as 16 longs, but it's actually 16
-    // shorts for the integer parts followed by 16 shorts for the fraction parts
-    Mtx *mtx = gMatStackFixed[gMatStackIndex];
-    s16 distanceFromCam = -GET_HIGH_S16_OF_32(mtx->m[1][3]); // z-component of the translation column
-#endif
-
+	f32 distanceFromCam = -gMatStack[gMatStackIndex][3][2];
 #ifndef TARGET_N64
     // We assume modern hardware is powerful enough to draw the most detailed variant
     distanceFromCam = 0;
 #endif
 
-    if (node->minDistance <= distanceFromCam && distanceFromCam < node->maxDistance) {
+    if ((f32)node->minDistance <= distanceFromCam && distanceFromCam < (f32)node->maxDistance) {
         if (node->node.children != 0) {
             geo_process_node_and_siblings(node->node.children);
         }
@@ -445,6 +455,17 @@ static void interpolate_angles(Vec3s res, Vec3s a, Vec3s b) {
 }
 #endif
 
+static void make_roll_matrix(Mtx *mtx, s16 angle) {
+    Mat4 temp;
+
+    mtxf_identity(temp);
+    temp[0][0] = coss(angle);
+    temp[0][1] = sins(angle);
+    temp[1][0] = -temp[0][1];
+    temp[1][1] = temp[0][0];
+    guMtxF2L(temp, mtx);
+}
+
 /**
  * Process a camera node.
  */
@@ -461,7 +482,8 @@ static void geo_process_camera(struct GraphNodeCamera *node) {
     if (node->fnNode.func != NULL) {
         node->fnNode.func(GEO_CONTEXT_RENDER, &node->fnNode.node, gMatStack[gMatStackIndex]);
     }
-    mtxf_rotate_xy(rollMtx, node->rollScreen);
+
+    make_roll_matrix(rollMtx, node->rollScreen);
 
     gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(rollMtx), G_MTX_PROJECTION | G_MTX_MUL | G_MTX_NOPUSH);
 
@@ -1087,7 +1109,7 @@ static void geo_process_shadow(struct GraphNodeShadow *node) {
             if (gShadowAboveWaterOrLava == TRUE) {
                 geo_append_display_list2((void *) VIRTUAL_TO_PHYSICAL(shadowList),
                                          (void *) VIRTUAL_TO_PHYSICAL(shadowListInterpolated), 4);
-            } else if (gMarioOnIceOrCarpet == 1) {
+            } else if (gMarioOnIceOrCarpet == 1 || gShadowAboveCustomWater == 1) {
                 geo_append_display_list2((void *) VIRTUAL_TO_PHYSICAL(shadowList),
                                          (void *) VIRTUAL_TO_PHYSICAL(shadowListInterpolated), 5);
             } else {
@@ -1097,7 +1119,7 @@ static void geo_process_shadow(struct GraphNodeShadow *node) {
 #else
             if (gShadowAboveWaterOrLava == TRUE) {
                 geo_append_display_list((void *) VIRTUAL_TO_PHYSICAL(shadowList), 4);
-            } else if (gMarioOnIceOrCarpet == 1) {
+            } else if (gMarioOnIceOrCarpet == 1 || gShadowAboveCustomWater == 1) {
                 geo_append_display_list((void *) VIRTUAL_TO_PHYSICAL(shadowList), 5);
             } else {
                 geo_append_display_list((void *) VIRTUAL_TO_PHYSICAL(shadowList), 6);
diff --git a/src/game/rendering_graph_node.h b/src/game/rendering_graph_node.h
index 7b9fde7..cf5ca61 100644
--- a/src/game/rendering_graph_node.h
+++ b/src/game/rendering_graph_node.h
@@ -12,6 +12,7 @@ extern struct GraphNodeCamera *gCurGraphNodeCamera;
 extern struct GraphNodeObject *gCurGraphNodeObject;
 extern struct GraphNodeHeldObject *gCurGraphNodeHeldObject;
 extern u16 gAreaUpdateCounter;
+extern f32 gWorldScale;
 
 // after processing an object, the type is reset to this
 #define ANIM_TYPE_NONE                  0
diff --git a/src/game/shadow.c b/src/game/shadow.c
index 77f0f5d..9aae6a0 100644
--- a/src/game/shadow.c
+++ b/src/game/shadow.c
@@ -14,8 +14,10 @@
 #include "sm64.h"
 
 // Avoid Z-fighting
-#define find_floor_height_and_data 0.4 + find_floor_height_and_data
-#define find_water_level -1.4 + find_water_level
+#define find_floor_shadow            1.4 + find_floor
+#define find_floor_height            1.4 + find_floor_height
+#define find_water_level            -1.4 + find_water_level
+#define find_water_level_and_floor  -1.4 + find_water_level_and_floor
 
 /**
  * @file shadow.c
@@ -106,6 +108,7 @@ shadowRectangle rectangles[2] = {
 
 // See shadow.h for documentation.
 s8 gShadowAboveWaterOrLava;
+s8 gShadowAboveCustomWater;
 s8 gMarioOnIceOrCarpet;
 s8 sMarioOnFlyingCarpet;
 s16 sSurfaceTypeBelowShadow;
@@ -181,8 +184,8 @@ u8 dim_shadow_with_distance(u8 solidity, f32 distFromFloor) {
  * Return the water level below a shadow, or 0 if the water level is below
  * -10,000.
  */
-f32 get_water_level_below_shadow(struct Shadow *s) {
-    f32 waterLevel = find_water_level(s->parentX, s->parentZ);
+f32 get_water_level_below_shadow(struct Shadow *s, struct Surface **waterFloor) {
+    f32 waterLevel = find_water_level_and_floor(s->parentX, s->parentZ, waterFloor);
     if (waterLevel < FLOOR_LOWER_LIMIT_SHADOW) {
         return 0;
     } else if (s->parentY >= waterLevel && s->floorHeight <= waterLevel) {
@@ -207,17 +210,22 @@ f32 get_water_level_below_shadow(struct Shadow *s) {
 s8 init_shadow(struct Shadow *s, f32 xPos, f32 yPos, f32 zPos, s16 shadowScale, u8 overwriteSolidity) {
     f32 waterLevel;
     f32 floorSteepness;
-    struct FloorGeometry *floorGeometry;
+    struct Surface *floor;
+    struct Surface *waterFloor = NULL;
 
     s->parentX = xPos;
     s->parentY = yPos;
     s->parentZ = zPos;
 
-    s->floorHeight = find_floor_height_and_data(s->parentX, s->parentY, s->parentZ, &floorGeometry);
+    gFindFloorIncludeSurfaceIntangible = TRUE;
 
-    if (gEnvironmentRegions != NULL) {
-        waterLevel = get_water_level_below_shadow(s);
-    }
+#ifdef CENTERED_COLLISION
+    s->floorHeight             = find_floor_shadow(s->parentX, (s->parentY + 80.0f), s->parentZ, &floor);
+#else
+    s->floorHeight             = find_floor_shadow(s->parentX, s->parentY, s->parentZ, &floor);
+#endif
+
+    waterLevel = get_water_level_below_shadow(s, &waterFloor);
 
     if (gShadowAboveWaterOrLava) {
         //! @bug Use of potentially undefined variable `waterLevel`
@@ -225,21 +233,33 @@ s8 init_shadow(struct Shadow *s, f32 xPos, f32 yPos, f32 zPos, s16 shadowScale,
         s->floorHeight = waterLevel;
 
         // Assume that the water is flat.
-        s->floorNormalX = 0;
-        s->floorNormalY = 1.0;
-        s->floorNormalZ = 0;
-        s->floorOriginOffset = -waterLevel;
+        if (waterFloor != NULL) {
+            s->floorNormalX = waterFloor->normal.x;
+            s->floorNormalY = waterFloor->normal.y;
+            s->floorNormalZ = waterFloor->normal.z;
+            s->floorOriginOffset = waterFloor->originOffset;
+            gShadowAboveWaterOrLava = FALSE;
+            gShadowAboveCustomWater = TRUE;
+            s->solidity = 200;
+        } else {
+            gShadowAboveCustomWater = FALSE;
+            // Assume that the water is flat.
+            s->floorNormalX = 0;
+            s->floorNormalY = 1.0;
+            s->floorNormalZ = 0;
+            s->floorOriginOffset = -waterLevel;
+        }
     } else {
         // Don't draw a shadow if the floor is lower than expected possible,
         // or if the y-normal is negative (an unexpected result).
-        if (s->floorHeight < FLOOR_LOWER_LIMIT_SHADOW || floorGeometry->normalY <= 0.0) {
+        if (s->floorHeight < FLOOR_LOWER_LIMIT_SHADOW || floor->normal.y <= 0.0) {
             return 1;
         }
 
-        s->floorNormalX = floorGeometry->normalX;
-        s->floorNormalY = floorGeometry->normalY;
-        s->floorNormalZ = floorGeometry->normalZ;
-        s->floorOriginOffset = floorGeometry->originOffset;
+        s->floorNormalX = floor->normal.x;
+        s->floorNormalY = floor->normal.y;
+        s->floorNormalZ = floor->normal.z;
+        s->floorOriginOffset = floor->originOffset;
     }
 
     if (overwriteSolidity) {
@@ -370,7 +390,6 @@ void calculate_vertex_xyz(s8 index, struct Shadow s, f32 *xPosVtx, f32 *yPosVtx,
     f32 halfTiltedScale;
     s8 xCoordUnit;
     s8 zCoordUnit;
-    struct FloorGeometry *dummy;
 
     // This makes xCoordUnit and yCoordUnit each one of -1, 0, or 1.
     get_vertex_coords(index, shadowVertexType, &xCoordUnit, &zCoordUnit);
@@ -393,7 +412,11 @@ void calculate_vertex_xyz(s8 index, struct Shadow s, f32 *xPosVtx, f32 *yPosVtx,
                 // Clamp this vertex's y-position to that of the floor directly
                 // below it, which may differ from the floor below the center
                 // vertex.
-                *yPosVtx = find_floor_height_and_data(*xPosVtx, s.parentY, *zPosVtx, &dummy);
+                #ifdef CENTERED_COLLISION
+                *yPosVtx = find_floor_height(*xPosVtx, (s.parentY + 80.0f), *zPosVtx);
+                #else
+                *yPosVtx = find_floor_height(*xPosVtx, s.parentY, *zPosVtx);
+                #endif
                 break;
             case SHADOW_WITH_4_VERTS:
                 // Do not clamp. Instead, extrapolate the y-position of this
@@ -413,7 +436,7 @@ void calculate_vertex_xyz(s8 index, struct Shadow s, f32 *xPosVtx, f32 *yPosVtx,
  * perpendicular, meaning the ground is locally flat. It returns nonzero
  * in most cases where `vtxY` is on a different floor triangle from the
  * center vertex, as in the case with SHADOW_WITH_9_VERTS, which sets
- * the y-value from `find_floor_height_and_data`. (See the bottom of
+ * the y-value from `find_floor`. (See the bottom of
  * `calculate_vertex_xyz`.)
  */
 s16 floor_local_tilt(struct Shadow s, f32 vtxX, f32 vtxY, f32 vtxZ) {
@@ -445,9 +468,8 @@ void make_shadow_vertex(Vtx *vertices, s8 index, struct Shadow s, s8 shadowVerte
      * GameShark code in this video: https://youtu.be/MSIh4rtNGF0. The code in
      * the video makes `extrapolate_vertex_y_position` return the same value as
      * the last-called function that returns a float; in this case, that's
-     * `find_floor_height_and_data`, which this if-statement was designed to
-     * overwrite in the first place. Thus, this if-statement is disabled by that
-     * code.
+     * `find_floor`, which this if-statement was designed to overwrite in the
+     * first place. Thus, this if-statement is disabled by that code.
      *
      * The last condition here means the y-position calculated previously
      * was probably on a different floor triangle from the center vertex.
@@ -707,9 +729,12 @@ Gfx *create_shadow_circle_assuming_flat_ground(f32 xPos, f32 yPos, f32 zPos, s16
                                                u8 solidity) {
     Vtx *verts;
     Gfx *displayList;
-    struct FloorGeometry *dummy; // only for calling find_floor_height_and_data
     f32 distBelowFloor;
-    f32 floorHeight = find_floor_height_and_data(xPos, yPos, zPos, &dummy);
+#ifdef CENTERED_COLLISION
+    f32 floorHeight = find_floor_height(xPos, (yPos + 80.0f), zPos);
+#else
+    f32 floorHeight = find_floor_height(xPos, yPos, zPos);
+#endif
     f32 radius = shadowScale / 2;
 
     if (floorHeight < FLOOR_LOWER_LIMIT_SHADOW) {
@@ -767,9 +792,12 @@ Gfx *create_shadow_rectangle(f32 halfWidth, f32 halfLength, f32 relY, u8 solidit
  * value is 200. Return 0 if a shadow should be drawn, 1 if not.
  */
 s32 get_shadow_height_solidity(f32 xPos, f32 yPos, f32 zPos, f32 *shadowHeight, u8 *solidity) {
-    struct FloorGeometry *dummy;
     f32 waterLevel;
-    *shadowHeight = find_floor_height_and_data(xPos, yPos, zPos, &dummy);
+#ifdef CENTERED_COLLISION
+    *shadowHeight = find_floor_height(xPos, (yPos + 80.0f), zPos);
+#else
+    *shadowHeight = find_floor_height(xPos, yPos, zPos);
+#endif
 
     if (*shadowHeight < FLOOR_LOWER_LIMIT_SHADOW) {
         return 1;
@@ -859,9 +887,14 @@ Gfx *create_shadow_below_xyz(f32 xPos, f32 yPos, f32 zPos, s16 shadowScale, u8 s
                              s8 shadowType) {
     Gfx *displayList = NULL;
     struct Surface *pfloor;
+#ifdef CENTERED_COLLISION
+    find_floor(xPos, (yPos + 80.0f), zPos, &pfloor);
+#else
     find_floor(xPos, yPos, zPos, &pfloor);
+#endif
 
     gShadowAboveWaterOrLava = FALSE;
+    gShadowAboveCustomWater = FALSE;
     gMarioOnIceOrCarpet = 0;
     sMarioOnFlyingCarpet = 0;
     if (pfloor != NULL) {
diff --git a/src/game/shadow.h b/src/game/shadow.h
index d527260..8c03786 100644
--- a/src/game/shadow.h
+++ b/src/game/shadow.h
@@ -37,6 +37,7 @@ extern s16 sSurfaceTypeBelowShadow;
  * Flag for if the current shadow is above water or lava.
  */
 extern s8 gShadowAboveWaterOrLava;
+extern s8 gShadowAboveCustomWater;
 
 /**
  * Flag for if Mario is on ice or a flying carpet.
