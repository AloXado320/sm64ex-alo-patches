diff --git a/src/engine/math_util.c b/src/engine/math_util.c
index 378a54f..313575e 100644
--- a/src/engine/math_util.c
+++ b/src/engine/math_util.c
@@ -496,6 +496,13 @@ void mtxf_align_terrain_triangle(Mat4 mtx, Vec3f pos, s16 yaw, f32 radius) {
     point1[1] = find_floor(point1[0], pos[1] + 150, point1[2], &sp74);
     point2[1] = find_floor(point2[0], pos[1] + 150, point2[2], &sp74);
 
+    if (gGravityMode) { // Transform all points
+        point0[1] = 9000.f-point0[1];
+        point1[1] = 9000.f-point1[1];
+        point2[1] = 9000.f-point2[1];
+        pos[1] = 9000.f-pos[1];
+    }
+
     if (point0[1] - pos[1] < minY) {
         point0[1] = pos[1];
     }
@@ -513,6 +520,13 @@ void mtxf_align_terrain_triangle(Mat4 mtx, Vec3f pos, s16 yaw, f32 radius) {
     vec3f_set(forward, sins(yaw), 0, coss(yaw));
     find_vector_perpendicular_to_plane(yColumn, point0, point1, point2);
     vec3f_normalize(yColumn);
+
+    if (gGravityMode) { // Flip the angle upside down
+        yColumn[0] = -yColumn[0];
+        yColumn[1] = -yColumn[1];
+        yColumn[2] = -yColumn[2];
+    }
+
     vec3f_cross(xColumn, yColumn, forward);
     vec3f_normalize(xColumn);
     vec3f_cross(zColumn, xColumn, yColumn);
diff --git a/src/engine/surface_collision.c b/src/engine/surface_collision.c
index 46b2385..c2daa91 100644
--- a/src/engine/surface_collision.c
+++ b/src/engine/surface_collision.c
@@ -13,6 +13,27 @@
 #include "extras/cheats.h"
 #endif
 
+/**
+ == UP / DOWN TOGGLEABLE GRAVITY ==
+How it works is that "transformed" positions are used for collision when gravity is flipped.
+These transforms only apply to Mario. The transform is "y = 9000 - y", mirroring across the range
+of values between 20000 and -11000.
+* gMarioState->pos: Transformed (for collision)
+* gMarioObject->oPos: Not transformed (various other things)
+* gMarioObject->header.gfx.pos: Not transformed (graphical position)
+* Collision triangles (when Mario is updated): Transformed
+**/
+
+
+u32 gGravityMode = FALSE; // Is flipped gravity currently being applied (only when Mario is updated)
+u32 gIsGravityFlipped = FALSE; // Is gravity flipped
+
+// Fake ceiling death plane for when Mario falls upwards
+struct Surface gCeilingDeathPlane = {
+    SURFACE_DEATH_PLANE, 0,    0,    0, 0, 0, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 },
+    { 0.0f, -1.0f, 0.0f },  0.0f, NULL,
+};
+
 /**************************************************
  *                      WALLS                     *
  **************************************************/
@@ -38,6 +59,9 @@ static s32 find_wall_collisions_from_list(struct SurfaceNode *surfaceNode, struc
         radius = 200.0f;
     }
 
+    // Unlike floors/ceils, walls use regular co-ordinates for collision, so undo the transform.
+    if (gGravityMode) y = 9000.f - y;
+
     // Stay in this loop until out of walls.
     while (surfaceNode != NULL) {
         surf = surfaceNode->surface;
@@ -231,6 +255,7 @@ static struct Surface *find_ceil_from_list(struct SurfaceNode *surfaceNode, s32
     register struct Surface *surf;
     register s32 x1, z1, x2, z2, x3, z3;
     struct Surface *ceil = NULL;
+    s32 temp;
 
     ceil = NULL;
 
@@ -244,18 +269,22 @@ static struct Surface *find_ceil_from_list(struct SurfaceNode *surfaceNode, s32
         z2 = surf->vertex2[2];
         x2 = surf->vertex2[0];
 
-        // Checking if point is in bounds of the triangle laterally.
-        if ((z1 - z) * (x2 - x1) - (x1 - x) * (z2 - z1) > 0) {
+        // Check that the point is within the triangle bounds.
+        temp = (z1 - z) * (x2 - x1) - (x1 - x) * (z2 - z1) > 0;
+        if (!gGravityMode != !temp) {
             continue;
         }
 
-        // Slight optimization by checking these later.
+        // To slightly save on computation time, set this later.
         x3 = surf->vertex3[0];
         z3 = surf->vertex3[2];
-        if ((z2 - z) * (x3 - x2) - (x2 - x) * (z3 - z2) > 0) {
+
+        temp = (z2 - z) * (x3 - x2) - (x2 - x) * (z3 - z2) > 0;
+        if (!gGravityMode != !temp) { // Equivalent to logical XOR
             continue;
         }
-        if ((z3 - z) * (x1 - x3) - (x3 - x) * (z1 - z3) > 0) {
+        temp = (z3 - z) * (x1 - x3) - (x3 - x) * (z1 - z3) > 0;
+        if (!gGravityMode != !temp) {
             continue;
         }
 
@@ -283,6 +312,8 @@ static struct Surface *find_ceil_from_list(struct SurfaceNode *surfaceNode, s32
 
         // Find the ceil height at the specific point.
         height = -(x * nx + nz * z + oo) / ny;
+        // Transform ceiling height
+        if (gGravityMode) height = 9000.f - height;
 
         // Checks for ceiling interaction with a 78 unit buffer.
         //! (Exposed Ceilings) Because any point above a ceiling counts
@@ -313,6 +344,7 @@ f32 find_ceil(f32 posX, f32 posY, f32 posZ, struct Surface **pceil) {
 
     f32 height = CELL_HEIGHT_LIMIT;
     f32 dynamicHeight = CELL_HEIGHT_LIMIT;
+    s32 ceilPartition = (gGravityMode ? SPATIAL_PARTITION_FLOORS : SPATIAL_PARTITION_CEILS);
 
     //! (Parallel Universes) Because position is casted to an s16, reaching higher
     //  float locations can return ceilings despite them not existing there.
@@ -335,11 +367,11 @@ f32 find_ceil(f32 posX, f32 posY, f32 posZ, struct Surface **pceil) {
     cellZ = ((z + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX;
 
     // Check for surfaces belonging to objects.
-    surfaceList = gDynamicSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_CEILS].next;
+    surfaceList = gDynamicSurfacePartition[cellZ][cellX][ceilPartition].next;
     dynamicCeil = find_ceil_from_list(surfaceList, x, y, z, &dynamicHeight);
 
     // Check for surfaces that are a part of level geometry.
-    surfaceList = gStaticSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_CEILS].next;
+    surfaceList = gStaticSurfacePartition[cellZ][cellX][ceilPartition].next;
     ceil = find_ceil_from_list(surfaceList, x, y, z, &height);
 
     if (dynamicHeight < height) {
@@ -409,6 +441,10 @@ static struct Surface *find_floor_from_list(struct SurfaceNode *surfaceNode, s32
     f32 height;
     struct Surface *floor = NULL;
 
+    s32 temp;
+
+    if (gGravityMode) floor = &gCeilingDeathPlane;
+
     // Iterate through the list of floors until there are no more floors.
     while (surfaceNode != NULL) {
         surf = surfaceNode->surface;
@@ -420,7 +456,8 @@ static struct Surface *find_floor_from_list(struct SurfaceNode *surfaceNode, s32
         z2 = surf->vertex2[2];
 
         // Check that the point is within the triangle bounds.
-        if ((z1 - z) * (x2 - x1) - (x1 - x) * (z2 - z1) < 0) {
+        temp = (z1 - z) * (x2 - x1) - (x1 - x) * (z2 - z1) < 0;
+        if (!gGravityMode != !temp) {
             continue;
         }
 
@@ -428,10 +465,12 @@ static struct Surface *find_floor_from_list(struct SurfaceNode *surfaceNode, s32
         x3 = surf->vertex3[0];
         z3 = surf->vertex3[2];
 
-        if ((z2 - z) * (x3 - x2) - (x2 - x) * (z3 - z2) < 0) {
+        temp = (z2 - z) * (x3 - x2) - (x2 - x) * (z3 - z2) < 0;
+        if (!gGravityMode != !temp) {
             continue;
         }
-        if ((z3 - z) * (x1 - x3) - (x3 - x) * (z1 - z3) < 0) {
+        temp = (z3 - z) * (x1 - x3) - (x3 - x) * (z1 - z3) < 0;
+        if (!gGravityMode != !temp) {
             continue;
         }
 
@@ -458,6 +497,9 @@ static struct Surface *find_floor_from_list(struct SurfaceNode *surfaceNode, s32
 
         // Find the height of the floor at a given location.
         height = -(x * nx + nz * z + oo) / ny;
+        // Transform floor height
+        if (gGravityMode) height = 9000.f - height;
+
         // Checks for floor interaction with a 78 unit buffer.
         if (y - (height + -78.0f) < 0.0f) {
             continue;
@@ -496,6 +538,7 @@ f32 unused_find_dynamic_floor(f32 xPos, f32 yPos, f32 zPos, struct Surface **pfl
     struct SurfaceNode *surfaceList;
     struct Surface *floor;
     f32 floorHeight = FLOOR_LOWER_LIMIT;
+    s32 floorPartition = (gGravityMode ? SPATIAL_PARTITION_CEILS : SPATIAL_PARTITION_FLOORS);
 
     // Would normally cause PUs, but dynamic floors unload at that range.
     s16 x = (s16) xPos;
@@ -506,7 +549,7 @@ f32 unused_find_dynamic_floor(f32 xPos, f32 yPos, f32 zPos, struct Surface **pfl
     s16 cellX = ((x + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX;
     s16 cellZ = ((z + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX;
 
-    surfaceList = gDynamicSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_FLOORS].next;
+    surfaceList = gDynamicSurfacePartition[cellZ][cellX][floorPartition].next;
     floor = find_floor_from_list(surfaceList, x, y, z, &floorHeight);
 
     *pfloor = floor;
@@ -522,6 +565,7 @@ f32 find_floor(f32 xPos, f32 yPos, f32 zPos, struct Surface **pfloor) {
 
     struct Surface *floor, *dynamicFloor;
     struct SurfaceNode *surfaceList;
+    s32 floorPartition = (gGravityMode ? SPATIAL_PARTITION_CEILS : SPATIAL_PARTITION_FLOORS);
 
     f32 height = FLOOR_LOWER_LIMIT;
     f32 dynamicHeight = FLOOR_LOWER_LIMIT;
@@ -547,11 +591,11 @@ f32 find_floor(f32 xPos, f32 yPos, f32 zPos, struct Surface **pfloor) {
     cellZ = ((z + LEVEL_BOUNDARY_MAX) / CELL_SIZE) & NUM_CELLS_INDEX;
 
     // Check for surfaces belonging to objects.
-    surfaceList = gDynamicSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_FLOORS].next;
+    surfaceList = gDynamicSurfacePartition[cellZ][cellX][floorPartition].next;
     dynamicFloor = find_floor_from_list(surfaceList, x, y, z, &dynamicHeight);
 
     // Check for surfaces that are a part of level geometry.
-    surfaceList = gStaticSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_FLOORS].next;
+    surfaceList = gStaticSurfacePartition[cellZ][cellX][floorPartition].next;
     floor = find_floor_from_list(surfaceList, x, y, z, &height);
 
     // To prevent the Merry-Go-Round room from loading when Mario passes above the hole that leads
diff --git a/src/engine/surface_collision.h b/src/engine/surface_collision.h
index f469508..540d64e 100644
--- a/src/engine/surface_collision.h
+++ b/src/engine/surface_collision.h
@@ -44,4 +44,7 @@ f32 find_water_level(f32 x, f32 z);
 f32 find_poison_gas_level(f32 x, f32 z);
 void debug_surface_list_info(f32 xPos, f32 zPos);
 
+extern u32 gGravityMode;
+extern u32 gIsGravityFlipped;
+
 #endif // SURFACE_COLLISION_H
diff --git a/src/game/behaviors/bobomb.inc.c b/src/game/behaviors/bobomb.inc.c
index 4db4137..76dfd13 100644
--- a/src/game/behaviors/bobomb.inc.c
+++ b/src/game/behaviors/bobomb.inc.c
@@ -211,7 +211,7 @@ void bobomb_thrown_loop(void) {
     o->oHeldState = 0;
     o->oFlags &= ~OBJ_FLAG_SET_FACE_YAW_TO_MOVE_YAW;
     o->oForwardVel = 25.0f;
-    o->oVelY = 20.0f;
+    o->oVelY = (gIsGravityFlipped ? -20.f : 20.f);
     o->oAction = BOBOMB_ACT_LAUNCHED;
 }
 
diff --git a/src/game/behaviors/breakable_box_small.inc.c b/src/game/behaviors/breakable_box_small.inc.c
index dbb305e..2a5e459 100644
--- a/src/game/behaviors/breakable_box_small.inc.c
+++ b/src/game/behaviors/breakable_box_small.inc.c
@@ -127,7 +127,7 @@ void breakable_box_small_get_thrown(void) {
     o->oHeldState = 0;
     o->oFlags &= ~OBJ_FLAG_SET_FACE_YAW_TO_MOVE_YAW;
     o->oForwardVel = 40.0f;
-    o->oVelY = 20.0f;
+    o->oVelY = (gIsGravityFlipped ? -20.f : 20.f);
     o->oBreakableBoxSmallReleased = TRUE;
     o->oBreakableBoxSmallFramesSinceReleased = 0;
     o->activeFlags &= ~ACTIVE_FLAG_UNK9;
diff --git a/src/game/behaviors/koopa_shell.inc.c b/src/game/behaviors/koopa_shell.inc.c
index 1ae1091..3a2254f 100644
--- a/src/game/behaviors/koopa_shell.inc.c
+++ b/src/game/behaviors/koopa_shell.inc.c
@@ -92,6 +92,10 @@ void bhv_koopa_shell_loop(void) {
 
         case 1:
             obj_copy_pos(o, gMarioObject);
+            if (gIsGravityFlipped)
+                o->oFaceAngleRoll = 0x8000;
+            else
+                o->oFaceAngleRoll = 0;
             sp34 = cur_obj_update_floor_height_and_get_floor();
 
             if (absf(find_water_level(o->oPosX, o->oPosZ) - o->oPosY) < 10.0f) {
diff --git a/src/game/behaviors/mips.inc.c b/src/game/behaviors/mips.inc.c
index 0aed1ec..28dbe06 100644
--- a/src/game/behaviors/mips.inc.c
+++ b/src/game/behaviors/mips.inc.c
@@ -275,7 +275,7 @@ void bhv_mips_thrown(void) {
     cur_obj_init_animation(2);
     cur_obj_become_tangible();
     o->oForwardVel = 25.0f;
-    o->oVelY = 20.0f;
+    o->oVelY = (gIsGravityFlipped ? -20.f : 20.f);
     o->oAction = MIPS_ACT_FALL_DOWN;
 }
 
diff --git a/src/game/behaviors/seesaw_platform.inc.c b/src/game/behaviors/seesaw_platform.inc.c
index 5b2e4bc..a97836d 100644
--- a/src/game/behaviors/seesaw_platform.inc.c
+++ b/src/game/behaviors/seesaw_platform.inc.c
@@ -44,7 +44,7 @@ void bhv_seesaw_platform_update(void) {
     if (gMarioObject->platform == o) {
         // Rotate toward mario
         f32 rotation = o->oDistanceToMario * coss(o->oAngleToMario - o->oMoveAngleYaw);
-        UNUSED u8 filler[4];
+        if (gIsGravityFlipped) rotation = -rotation; // Rotate in correct direction if Mario is underneath
 
         // Deceleration is faster than acceleration
         if (o->oSeesawPlatformPitchVel * rotation < 0) {
diff --git a/src/game/camera.c b/src/game/camera.c
index 3faf21c..682da72 100644
--- a/src/game/camera.c
+++ b/src/game/camera.c
@@ -730,7 +730,7 @@ void focus_on_mario(Vec3f focus, Vec3f pos, f32 posYOff, f32 focYOff, f32 dist,
     marioPos[1] = sMarioCamState->pos[1] + posYOff;
     marioPos[2] = sMarioCamState->pos[2];
 
-    vec3f_set_dist_and_angle(marioPos, pos, dist, pitch + sLakituPitch, yaw);
+    vec3f_set_dist_and_angle(marioPos, pos, dist, (gGravityMode ? -pitch-sLakituPitch : pitch + sLakituPitch), yaw);
 
     focus[0] = sMarioCamState->pos[0];
     focus[1] = sMarioCamState->pos[1] + focYOff;
@@ -750,7 +750,7 @@ static UNUSED void set_pos_to_mario(Vec3f foc, Vec3f pos, f32 yOff, f32 focYOff,
     vec3f_copy(marioPos, sMarioCamState->pos);
     marioPos[1] += yOff;
 
-    vec3f_set_dist_and_angle(marioPos, pos, dist, pitch + sLakituPitch, yaw);
+    vec3f_set_dist_and_angle(marioPos, pos, dist, (gGravityMode ? -pitch-sLakituPitch : pitch + sLakituPitch), yaw);
     vec3f_get_dist_and_angle(pos, sMarioCamState->pos, &posDist, &posPitch, &posYaw);
 
     //! Useless get and set
@@ -6965,6 +6965,8 @@ void find_mario_floor_and_ceil(struct PlayerGeometry *pg) {
     s16 tempCheckingSurfaceCollisionsForCamera = gCheckingSurfaceCollisionsForCamera;
     gCheckingSurfaceCollisionsForCamera = TRUE;
 
+    gGravityMode = gIsGravityFlipped; // Enable gravity for checks
+
     if (find_floor(sMarioCamState->pos[0], sMarioCamState->pos[1] + 10.f,
                    sMarioCamState->pos[2], &surf) != FLOOR_LOWER_LIMIT) {
         pg->currFloorType = surf->type;
@@ -6988,6 +6990,8 @@ void find_mario_floor_and_ceil(struct PlayerGeometry *pg) {
                                    sMarioCamState->pos[2], &pg->currCeil);
     pg->waterHeight = find_water_level(sMarioCamState->pos[0], sMarioCamState->pos[2]);
     gCheckingSurfaceCollisionsForCamera = tempCheckingSurfaceCollisionsForCamera;
+    
+    gGravityMode = 0;
 }
 
 /**
diff --git a/src/game/interaction.c b/src/game/interaction.c
index 87fd514..3fef7c8 100644
--- a/src/game/interaction.c
+++ b/src/game/interaction.c
@@ -234,12 +234,16 @@ u32 determine_interaction(struct MarioState *m, struct Object *o) {
     // that the interaction not be set prior. This specifically overrides turning a ground
     // pound into just a bounce.
     if (interaction == 0 && (action & ACT_FLAG_AIR)) {
-        if (m->vel[1] < 0.0f) {
-            if (m->pos[1] > o->oPosY) {
+        if (gGravityMode) {
+            if ((m->vel[1] > 0.0f) && ((9000.f-m->pos[1]) > o->oPosY)) {
                 interaction = INT_HIT_FROM_ABOVE;
+            } else if ((m->vel[1] < 0.0f) && ((9000.f-m->pos[1]) < o->oPosY)) {
+                interaction = INT_HIT_FROM_BELOW;
             }
         } else {
-            if (m->pos[1] < o->oPosY) {
+            if ((m->vel[1] < 0.0f) && (m->pos[1] > o->oPosY)) {
+                interaction = INT_HIT_FROM_ABOVE;
+            } else if ((m->vel[1] > 0.0f) && (m->pos[1] < o->oPosY)) {
                 interaction = INT_HIT_FROM_BELOW;
             }
         }
@@ -308,7 +312,7 @@ void mario_drop_held_object(struct MarioState *m) {
         // y-positon instead of the HOLP's y-position. This fact is often exploited when
         // cloning objects.
         m->heldObj->oPosX = m->marioBodyState->heldObjLastPosition[0];
-        m->heldObj->oPosY = m->pos[1];
+        m->heldObj->oPosY = (gGravityMode ? 8750.f - m->pos[1] : m->pos[1]);
         m->heldObj->oPosZ = m->marioBodyState->heldObjLastPosition[2];
 
         m->heldObj->oMoveAngleYaw = m->faceAngle[1];
@@ -518,7 +522,8 @@ u32 bully_knock_back_mario(struct MarioState *mario) {
 
 void bounce_off_object(struct MarioState *m, struct Object *o, f32 velY) {
     m->pos[1] = o->oPosY + o->hitboxHeight;
-    m->vel[1] = velY;
+    m->vel[1] = (gGravityMode ? -velY : velY);
+    if (gGravityMode) m->pos[1] = 9000.f - m->pos[1];
 
     m->flags &= ~MARIO_UNKNOWN_08;
 
@@ -591,7 +596,7 @@ u32 determine_knockback_action(struct MarioState *m, UNUSED s32 arg) {
             mario_set_forward_vel(m, 28.0f);
         }
 
-        if (m->pos[1] >= m->interactObj->oPosY) {
+        if ((gGravityMode ? 9000.f-m->pos[1] : m->pos[1]) >= m->interactObj->oPosY) {
             if (m->vel[1] < 20.0f) {
                 m->vel[1] = 20.0f;
             }
@@ -1121,7 +1126,7 @@ u32 interact_tornado(struct MarioState *m, UNUSED u32 interactType, struct Objec
         m->usedObj = o;
 
         marioObj->oMarioTornadoYawVel = 0x400;
-        marioObj->oMarioTornadoPosY = m->pos[1] - o->oPosY;
+        marioObj->oMarioTornadoPosY = (gGravityMode ? 9000.f - m->pos[1] : m->pos[1]) - o->oPosY;
 
         play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
 #ifdef RUMBLE_FEEDBACK  
@@ -1362,7 +1367,7 @@ u32 interact_hit_from_below(struct MarioState *m, UNUSED u32 interactType, struc
         attack_object(o, interaction);
         bounce_back_from_attack(m, interaction);
 
-        if (interaction & INT_HIT_FROM_BELOW) {
+        if ((interaction & INT_HIT_FROM_BELOW) && (!gGravityMode)) {
             hit_object_from_below(m, o);
         }
 
@@ -1576,9 +1581,17 @@ u32 interact_pole(struct MarioState *m, UNUSED u32 interactType, struct Object *
             marioObj->oMarioPoleUnk108 = 0;
             marioObj->oMarioPoleYawVel = 0;
 #if QOL_FIX_POLE_BOTTOM_GRAB
-            marioObj->oMarioPolePos = max(m->pos[1] - o->oPosY, poleBottom);
+            if (gGravityMode) {
+                marioObj->oMarioPolePos = o->oPosY - (9000.f - m->pos[1]) + o->hitboxHeight + 100.f;
+            } else {
+                marioObj->oMarioPolePos = max(m->pos[1] - o->oPosY, poleBottom);
+            }
 #else
-            marioObj->oMarioPolePos = m->pos[1] - o->oPosY;
+            if (gGravityMode) {
+                marioObj->oMarioPolePos = o->oPosY - (9000.f - m->pos[1]) + o->hitboxHeight + 100.f;
+            } else { 
+                marioObj->oMarioPolePos = m->pos[1] - o->oPosY;
+            }
 #endif
 
             if (lowSpeed) {
diff --git a/src/game/level_update.c b/src/game/level_update.c
index 8f28b73..9377793 100644
--- a/src/game/level_update.c
+++ b/src/game/level_update.c
@@ -414,6 +414,8 @@ void init_mario_after_warp(void) {
         gPlayerSpawnInfos[0].startAngle[1] = spawnNode->object->oMoveAngleYaw;
         gPlayerSpawnInfos[0].startAngle[2] = 0;
 
+        if (gIsGravityFlipped) gPlayerSpawnInfos[0].startPos[1] = 9000.f - gPlayerSpawnInfos[0].startPos[1]; // If gravity is flipped when warping
+
         if (marioSpawnType == MARIO_SPAWN_DOOR_WARP) {
             init_door_warp(&gPlayerSpawnInfos[0], sWarpDest.arg);
         }
@@ -566,15 +568,19 @@ void warp_credits(void) {
 
 void check_instant_warp(void) {
     s16 cameraAngle;
-    struct Surface *floor;
+    struct Surface *floor, *ceil;
 
     if (gCurrLevelNum == LEVEL_CASTLE
         && save_file_get_total_star_count(gCurrSaveFileNum - 1, COURSE_MIN - 1, COURSE_MAX - 1) >= 70) {
         return;
     }
 
-    if ((floor = gMarioState->floor) != NULL) {
-        s32 index = floor->type - SURFACE_INSTANT_WARP_1B;
+    // Make sure instant warps work both sides up
+    floor = gMarioState->floor;
+    ceil = gMarioState->ceil;
+
+    if ((!(gIsGravityFlipped) && (floor != NULL)) || ((gIsGravityFlipped) && (ceil != NULL))) {
+        s32 index = (gIsGravityFlipped ? ceil->type : floor->type) - SURFACE_INSTANT_WARP_1B;
         if (index >= INSTANT_WARP_INDEX_START && index < INSTANT_WARP_INDEX_STOP
             && gCurrentArea->instantWarps != NULL) {
             struct InstantWarp *warp = &gCurrentArea->instantWarps[index];
@@ -689,7 +695,13 @@ void initiate_warp(s16 destLevel, s16 destArea, s16 destWarpNode, s32 arg3) {
  */
 struct WarpNode *get_painting_warp_node(void) {
     struct WarpNode *warpNode = NULL;
-    s32 paintingIndex = gMarioState->floor->type - SURFACE_PAINTING_WARP_D3;
+    s32 paintingIndex = -1;
+    // Use ceiling if entering painting upside down
+    if (gIsGravityFlipped) {
+        if (gMarioState->ceil != NULL)
+            paintingIndex = gMarioState->ceil->type - SURFACE_PAINTING_WARP_D3;
+    } else
+        paintingIndex = gMarioState->floor->type - SURFACE_PAINTING_WARP_D3;
 
     if (paintingIndex >= PAINTING_WARP_INDEX_START && paintingIndex < PAINTING_WARP_INDEX_END) {
         if (paintingIndex < PAINTING_WARP_INDEX_FA
@@ -720,6 +732,7 @@ void initiate_painting_warp(void) {
                 }
 
                 initiate_warp(warpNode.destLevel & 0x7F, warpNode.destArea, warpNode.destNode, 0);
+                gIsGravityFlipped = FALSE;
                 check_if_should_set_warp_checkpoint(&warpNode);
 
                 play_transition_after_delay(WARP_TRANSITION_FADE_INTO_COLOR, 30, 255, 255, 255, 45);
@@ -739,6 +752,7 @@ void initiate_painting_warp(void) {
         }
     }
 }
+extern struct Surface gCeilingDeathPlane;
 
 /**
  * If there is not already a delayed warp, schedule one. The source node is
@@ -789,7 +803,7 @@ s16 level_trigger_warp(struct MarioState *m, s32 warpOp) {
 
             case WARP_OP_WARP_FLOOR:
                 sSourceWarpNodeId = WARP_NODE_WARP_FLOOR;
-                if (area_get_warp_node(sSourceWarpNodeId) == NULL) {
+                if ((area_get_warp_node(sSourceWarpNodeId) == NULL) || (gMarioState->floor = &gCeilingDeathPlane)) {
                     if (m->numLives == 0) {
                         sDelayedWarpOp = WARP_OP_GAME_OVER;
                     } else {
diff --git a/src/game/mario.c b/src/game/mario.c
index cc88e50..ba7caea 100644
--- a/src/game/mario.c
+++ b/src/game/mario.c
@@ -139,6 +139,16 @@ s16 set_mario_anim_with_accel(struct MarioState *m, s32 targetAnimID, s32 accel)
     return o->header.gfx.animInfo.animFrame;
 }
 
+// Copy a vec3f, but transform the Y if gravity is flipped.
+// Mario's object's GFX position is updated with vec3f_copy, so
+// use this instead to undo the transform for GFX pos.
+void vec3f_copy_with_gravity_switch(Vec3f dst, Vec3f src) {
+    dst[0] = src[0];
+    dst[1] = src[1];
+    if (gGravityMode) dst[1] = 9000.f - dst[1];
+    dst[2] = src[2];
+}
+
 /**
  * Sets the animation to a specific "next" frame from the frame given.
  */
@@ -440,7 +450,7 @@ s32 mario_get_floor_class(struct MarioState *m) {
     }
 
     // Crawling allows Mario to not slide on certain steeper surfaces.
-    if (m->action == ACT_CRAWLING && m->floor->normal.y > 0.5f && floorClass == SURFACE_CLASS_DEFAULT) {
+    if (m->action == ACT_CRAWLING && ABS(m->floor->normal.y) > 0.5f && floorClass == SURFACE_CLASS_DEFAULT) {
         floorClass = SURFACE_CLASS_NOT_SLIPPERY;
     }
 
@@ -594,7 +604,7 @@ u32 mario_floor_is_slippery(struct MarioState *m) {
     f32 normY;
 
     if ((m->area->terrainType & TERRAIN_MASK) == TERRAIN_SLIDE
-        && m->floor->normal.y < 0.9998477f //~cos(1 deg)
+        && ABS(m->floor->normal.y) < 0.9998477f //~cos(1 deg)
     ) {
         return TRUE;
     }
@@ -617,7 +627,7 @@ u32 mario_floor_is_slippery(struct MarioState *m) {
             break;
     }
 
-    return m->floor->normal.y <= normY;
+    return ABS(m->floor->normal.y) <= normY;
 }
 
 /**
@@ -627,7 +637,7 @@ s32 mario_floor_is_slope(struct MarioState *m) {
     f32 normY;
 
     if ((m->area->terrainType & TERRAIN_MASK) == TERRAIN_SLIDE
-        && m->floor->normal.y < 0.9998477f) { // ~cos(1 deg)
+        && ABS(m->floor->normal.y) < 0.9998477f) { // ~cos(1 deg)
         return TRUE;
     }
 
@@ -649,7 +659,7 @@ s32 mario_floor_is_slope(struct MarioState *m) {
             break;
     }
 
-    return m->floor->normal.y <= normY;
+    return ABS(m->floor->normal.y) <= normY;
 }
 
 /**
@@ -686,7 +696,7 @@ s32 mario_floor_is_steep(struct MarioState *m) {
 #endif
         }
 
-        return (m->floor->normal.y <= normY);
+        return ABS(m->floor->normal.y) <= normY;
     }
 
     return FALSE;
@@ -1283,7 +1293,7 @@ void debug_print_speed_action_normal(struct MarioState *m) {
     if (gShowDebugText) {
         steepness = sqrtf(
             ((m->floor->normal.x * m->floor->normal.x) + (m->floor->normal.z * m->floor->normal.z)));
-        floor_nY = m->floor->normal.y;
+        floor_nY = ABS(m->floor->normal.y);
 
         print_text_fmt_int(210, 88, "ANG %d", (atan2s(floor_nY, steepness) * 180.0f) / 32768.0f);
 
@@ -1372,7 +1382,7 @@ void update_mario_geometry_inputs(struct MarioState *m) {
     // This can cause errant behavior when combined with astral projection,
     // since the graphical position was not Mario's previous location.
     if (m->floor == NULL) {
-        vec3f_copy(m->pos, m->marioObj->header.gfx.pos);
+        vec3f_copy_with_gravity_switch(m->pos, m->marioObj->header.gfx.pos);
         m->floorHeight = find_floor(m->pos[0], m->pos[1], m->pos[2], &m->floor);
     }
 
@@ -1593,8 +1603,10 @@ void update_mario_info_for_cam(struct MarioState *m) {
     vec3s_copy(m->statusForCamera->faceAngle, m->faceAngle);
 
     if (!(m->flags & MARIO_UNKNOWN_25)) {
-        vec3f_copy(m->statusForCamera->pos, m->pos);
+        vec3f_copy_with_gravity_switch(m->statusForCamera->pos, m->pos);
     }
+    if (gGravityMode)
+        m->statusForCamera->pos[1] -= 165.f;
 }
 
 /**
@@ -1728,6 +1740,11 @@ void mario_update_hitbox_and_cap_model(struct MarioState *m) {
     } else {
         m->marioObj->hitboxHeight = 160.0f;
     }
+    if (gIsGravityFlipped && !(gMarioState->action & ACT_FLAG_SWIMMING)) {
+        gMarioObject->hitboxDownOffset = (gMarioState->action & ACT_FLAG_SHORT_HITBOX ? 100.f : 160.f); // Adjust hitbox when upside down
+    } else {
+        gMarioObject->hitboxDownOffset = 0;
+    }
 
     if ((m->flags & MARIO_TELEPORTING) && (m->fadeWarpOpacity != 0xFF)) {
         bodyState->modelState &= ~0xFF;
@@ -1943,7 +1960,7 @@ void init_mario(void) {
     gMarioState->marioObj->oMoveAngleYaw = gMarioState->faceAngle[1];
     gMarioState->marioObj->oMoveAngleRoll = gMarioState->faceAngle[2];
 
-    vec3f_copy(gMarioState->marioObj->header.gfx.pos, gMarioState->pos);
+    vec3f_copy_with_gravity_switch(gMarioState->marioObj->header.gfx.pos, gMarioState->pos);
     vec3s_set(gMarioState->marioObj->header.gfx.angle, 0, gMarioState->faceAngle[1], 0);
 
     if (save_file_get_cap_pos(capPos)
diff --git a/src/game/mario.h b/src/game/mario.h
index 0c573b8..11df5dd 100644
--- a/src/game/mario.h
+++ b/src/game/mario.h
@@ -51,5 +51,6 @@ u32 update_and_return_cap_flags(struct MarioState *m);
 s32 execute_mario_action(UNUSED struct Object *o);
 void init_mario(void);
 void init_mario_from_save_file(void);
+void vec3f_copy_with_gravity_switch(Vec3f, Vec3f);
 
 #endif // MARIO_H
diff --git a/src/game/mario_actions_airborne.c b/src/game/mario_actions_airborne.c
index 294a3e1..dfb0fe7 100644
--- a/src/game/mario_actions_airborne.c
+++ b/src/game/mario_actions_airborne.c
@@ -16,6 +16,7 @@
 #ifdef CHEATS_ACTIONS
 #include "extras/cheats.h"
 #endif
+#include "engine/surface_collision.h"
 
 void play_flip_sounds(struct MarioState *m, s16 frame1, s16 frame2, s16 frame3) {
     s32 animFrame = m->marioObj->header.gfx.animInfo.animFrame;
@@ -327,7 +328,7 @@ void update_flying_yaw(struct MarioState *m) {
 }
 
 void update_flying_pitch(struct MarioState *m) {
-    s16 targetPitchVel = -(s16)(m->controller->stickY * (m->forwardVel / 5.0f));
+    s16 targetPitchVel = -(s16)((gGravityMode ? -m->controller->stickY : m->controller->stickY) * (m->forwardVel / 5.0f));
 
     if (targetPitchVel > 0) {
         if (m->angleVel[0] < 0) {
@@ -354,11 +355,12 @@ void update_flying_pitch(struct MarioState *m) {
 
 void update_flying(struct MarioState *m) {
     UNUSED u8 filler[4];
+    s16 pitch = (gGravityMode ? -m->faceAngle[0] : m->faceAngle[0]);
 
     update_flying_pitch(m);
     update_flying_yaw(m);
 
-    m->forwardVel -= 2.0f * ((f32) m->faceAngle[0] / 0x4000) + 0.1f;
+    m->forwardVel -= 2.0f * ((f32) pitch  / 0x4000) + 0.1f;
     m->forwardVel -= 0.5f * (1.0f - coss(m->angleVel[1]));
 
     if (m->forwardVel < 0.0f) {
@@ -366,25 +368,27 @@ void update_flying(struct MarioState *m) {
     }
 
     if (m->forwardVel > 16.0f) {
-        m->faceAngle[0] += (m->forwardVel - 32.0f) * 6.0f;
+        pitch += (m->forwardVel - 32.0f) * 6.0f;
     } else if (m->forwardVel > 4.0f) {
-        m->faceAngle[0] += (m->forwardVel - 32.0f) * 10.0f;
+        pitch += (m->forwardVel - 32.0f) * 10.0f;
     } else {
-        m->faceAngle[0] -= 0x400;
+        pitch -= 0x400;
     }
 
-    m->faceAngle[0] += m->angleVel[0];
+    pitch += m->angleVel[0];
 
-    if (m->faceAngle[0] > 0x2AAA) {
-        m->faceAngle[0] = 0x2AAA;
+    if (pitch > 0x2AAA) {
+        pitch = 0x2AAA;
     }
-    if (m->faceAngle[0] < -0x2AAA) {
-        m->faceAngle[0] = -0x2AAA;
+    if (pitch < -0x2AAA) {
+        pitch = -0x2AAA;
     }
 
-    m->vel[0] = m->forwardVel * coss(m->faceAngle[0]) * sins(m->faceAngle[1]);
-    m->vel[1] = m->forwardVel * sins(m->faceAngle[0]);
-    m->vel[2] = m->forwardVel * coss(m->faceAngle[0]) * coss(m->faceAngle[1]);
+    m->vel[0] = m->forwardVel * coss(pitch) * sins(m->faceAngle[1]);
+    m->vel[1] = m->forwardVel * sins(pitch);
+    m->vel[2] = m->forwardVel * coss(pitch) * coss(m->faceAngle[1]);
+
+    m->faceAngle[0] = (gGravityMode ? -pitch : pitch);
 
     m->slideVelX = m->vel[0];
     m->slideVelZ = m->vel[2];
@@ -701,7 +705,7 @@ s32 act_riding_shell_air(struct MarioState *m) {
             break;
     }
 
-    m->marioObj->header.gfx.pos[1] += 42.0f;
+    m->marioObj->header.gfx.pos[1] += (gGravityMode ? -42.0f : 42.0f);
     return FALSE;
 }
 
@@ -770,10 +774,15 @@ s32 act_dive(struct MarioState *m) {
 
     switch (perform_air_step(m, 0)) {
         case AIR_STEP_NONE:
-            if (m->vel[1] < 0.0f && m->faceAngle[0] > -0x2AAA) {
-                m->faceAngle[0] -= 0x200;
-                if (m->faceAngle[0] < -0x2AAA) {
-                    m->faceAngle[0] = -0x2AAA;
+            if (m->vel[1] < 0.0f) {
+                if (gGravityMode) {
+                    m->faceAngle[0] += 0x200;
+                    if (m->faceAngle[0] > 0x2AAA)
+                        m->faceAngle[0] = 0x2AAA;
+                } else {
+                    m->faceAngle[0] -= 0x200;
+                    if (m->faceAngle[0] < -0x2AAA)
+                        m->faceAngle[0] = -0x2AAA;
                 }
             }
             m->marioObj->header.gfx.angle[0] = -m->faceAngle[0];
@@ -956,9 +965,13 @@ s32 act_ground_pound(struct MarioState *m) {
                 m->pos[1] += yOffset;
                 m->peakHeight = m->pos[1];
                 vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+                // Ground pound explicitly sets GFX position, so undo the transform
+                if (gGravityMode) m->marioObj->header.gfx.pos[1] = 9000.f - m->marioObj->header.gfx.pos[1];
             }
         }
 
+        m->marioObj->header.gfx.angle[2] = 0; // GP doesn't do air steps while in mid-air, so reset roll manually each frame
+
 #if QOL_FIX_GROUND_POUND_WALL
         mario_set_forward_vel(m, -0.1f);
 #else
@@ -1125,7 +1138,7 @@ s32 act_crazy_box_bounce(struct MarioState *m) {
             break;
     }
 
-    m->marioObj->header.gfx.angle[0] = atan2s(m->forwardVel, -m->vel[1]);
+    m->marioObj->header.gfx.angle[0] = atan2s(m->forwardVel, (gGravityMode ? m->vel[1] : -m->vel[1]));
     return FALSE;
 }
 
@@ -1481,7 +1494,7 @@ s32 act_butt_slide_air(struct MarioState *m) {
 
     switch (perform_air_step(m, 0)) {
         case AIR_STEP_LANDED:
-            if (m->actionState == 0 && m->vel[1] < 0.0f && m->floor->normal.y >= 0.9848077f) {
+            if (m->actionState == 0 && m->vel[1] < 0.0f && ABS(m->floor->normal.y) >= 0.9848077f) {
                 m->vel[1] = -m->vel[1] / 2.0f;
                 m->actionState = 1;
             } else {
@@ -1520,7 +1533,7 @@ s32 act_hold_butt_slide_air(struct MarioState *m) {
 
     switch (perform_air_step(m, 0)) {
         case AIR_STEP_LANDED:
-            if (m->actionState == 0 && m->vel[1] < 0.0f && m->floor->normal.y >= 0.9848077f) {
+            if (m->actionState == 0 && m->vel[1] < 0.0f && ABS(m->floor->normal.y) >= 0.9848077f) {
                 m->vel[1] = -m->vel[1] / 2.0f;
                 m->actionState = 1;
             } else {
@@ -1719,7 +1732,7 @@ s32 act_shot_from_cannon(struct MarioState *m) {
     switch (perform_air_step(m, 0)) {
         case AIR_STEP_NONE:
             set_mario_animation(m, MARIO_ANIM_AIRBORNE_ON_STOMACH);
-            m->faceAngle[0] = atan2s(m->forwardVel, m->vel[1]);
+            m->faceAngle[0] = atan2s(m->forwardVel, (gGravityMode ? -m->vel[1] : m->vel[1]));
             m->marioObj->header.gfx.angle[0] = -m->faceAngle[0];
             break;
 
@@ -1758,7 +1771,7 @@ s32 act_shot_from_cannon(struct MarioState *m) {
         mario_set_forward_vel(m, 10.0f);
     }
 
-    if (m->vel[1] > 0.0f) {
+    if (((m->vel[1] > 0.0f) && !gGravityMode) || ((m->vel[1] < 0.0f) && gGravityMode)) {
         m->particleFlags |= PARTICLE_DUST;
     }
 #ifdef RUMBLE_FEEDBACK
@@ -1918,7 +1931,7 @@ s32 act_riding_hoot(struct MarioState *m) {
     }
 
     vec3f_set(m->vel, 0.0f, 0.0f, 0.0f);
-    vec3f_set(m->marioObj->header.gfx.pos, m->pos[0], m->pos[1], m->pos[2]);
+    vec3f_copy_with_gravity_switch(m->marioObj->header.gfx.pos, m->pos);
     vec3s_set(m->marioObj->header.gfx.angle, 0, 0x4000 - m->faceAngle[1], 0);
     return FALSE;
 }
@@ -2130,7 +2143,12 @@ s32 act_special_triple_jump(struct MarioState *m) {
 }
 
 s32 check_common_airborne_cancels(struct MarioState *m) {
-    if (m->pos[1] < m->waterLevel - 100) {
+    if ((m->pos[1] < m->waterLevel - 100) && !(gGravityMode)) {
+        return set_water_plunge_action(m);
+    }
+    if (((9000.f - m->pos[1]) < m->waterLevel + 50.f) && (gGravityMode)) {
+        m->vel[1] = -m->vel[1];
+        gGravityMode = FALSE;
         return set_water_plunge_action(m);
     }
 
diff --git a/src/game/mario_actions_automatic.c b/src/game/mario_actions_automatic.c
index c1d7bbf..73b8a1f 100644
--- a/src/game/mario_actions_automatic.c
+++ b/src/game/mario_actions_automatic.c
@@ -75,8 +75,10 @@ s32 set_pole_position(struct MarioState *m, f32 offsetY) {
     f32 ceilHeight;
     s32 collided;
     s32 result = POLE_NONE;
-    f32 poleTop = m->usedObj->hitboxHeight - 100.0f;
     struct Object *marioObj = m->marioObj;
+    f32 poleBottom = (gGravityMode ? 0 : -m->usedObj->hitboxDownOffset);
+    f32 poleTop = m->usedObj->hitboxHeight - 100.0f;
+    if (gGravityMode) poleTop += m->usedObj->hitboxDownOffset;
 
     if (marioObj->oMarioPolePos > poleTop) {
         marioObj->oMarioPolePos = poleTop;
@@ -84,7 +86,11 @@ s32 set_pole_position(struct MarioState *m, f32 offsetY) {
 
     m->pos[0] = m->usedObj->oPosX;
     m->pos[2] = m->usedObj->oPosZ;
-    m->pos[1] = m->usedObj->oPosY + marioObj->oMarioPolePos + offsetY;
+
+    if (gGravityMode)
+        m->pos[1] = 9000.f - (m->usedObj->oPosY + m->usedObj->hitboxHeight + 100.f - marioObj->oMarioPolePos - offsetY);
+    else
+        m->pos[1] = m->usedObj->oPosY + marioObj->oMarioPolePos + offsetY;
 
     collided = f32_find_wall_collision(&m->pos[0], &m->pos[1], &m->pos[2], 60.0f, 50.0f);
     collided |= f32_find_wall_collision(&m->pos[0], &m->pos[1], &m->pos[2], 30.0f, 24.0f);
@@ -92,7 +98,15 @@ s32 set_pole_position(struct MarioState *m, f32 offsetY) {
     ceilHeight = vec3f_find_ceil(m->pos, m->pos[1], &ceil);
     if (m->pos[1] > ceilHeight - 160.0f) {
         m->pos[1] = ceilHeight - 160.0f;
-        marioObj->oMarioPolePos = m->pos[1] - m->usedObj->oPosY;
+        if (gGravityMode)
+            marioObj->oMarioPolePos = m->usedObj->oPosY - (9000.f - m->pos[1]) + m->usedObj->hitboxHeight + 100.f;
+        else
+            marioObj->oMarioPolePos = m->pos[1] - m->usedObj->oPosY;
+    }
+
+    if ((virtual_to_segmented(0x13, m->usedObj->behavior) == bhvGiantPole) && gGravityMode) {
+        if (marioObj->oMarioPolePos < 100)
+            marioObj->oMarioPolePos = 100;
     }
 
     floorHeight = find_floor(m->pos[0], m->pos[1], m->pos[2], &floor);
@@ -100,8 +114,12 @@ s32 set_pole_position(struct MarioState *m, f32 offsetY) {
         m->pos[1] = floorHeight;
         set_mario_action(m, ACT_IDLE, 0);
         result = POLE_TOUCHED_FLOOR;
-    } else if (marioObj->oMarioPolePos < -m->usedObj->hitboxDownOffset) {
-        m->pos[1] = m->usedObj->oPosY - m->usedObj->hitboxDownOffset;
+    } else if (marioObj->oMarioPolePos < poleBottom) {
+        if (gGravityMode)
+            m->pos[1] = 9000.f - (m->usedObj->oPosY + m->usedObj->hitboxHeight + 100.f);
+        else
+            m->pos[1] = m->usedObj->oPosY - m->usedObj->hitboxDownOffset;
+
         set_mario_action(m, ACT_FREEFALL, 0);
         result = POLE_FELL_OFF;
     } else if (collided) {
@@ -115,7 +133,7 @@ s32 set_pole_position(struct MarioState *m, f32 offsetY) {
         }
     }
 
-    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(m->marioObj->header.gfx.pos, m->pos);
     vec3s_set(m->marioObj->header.gfx.angle, m->usedObj->oMoveAnglePitch, m->faceAngle[1],
               m->usedObj->oMoveAngleRoll);
 
@@ -151,21 +169,23 @@ s32 act_holding_pole(struct MarioState *m) {
     }
 #endif
 
-    if (m->controller->stickY > 16.0f) {
+    if (((m->controller->stickY > 16.0f) && !(gGravityMode)) || ((m->controller->stickY < -16.0f) && gGravityMode)) {
         f32 poleTop = m->usedObj->hitboxHeight - 100.0f;
         const BehaviorScript *poleBehavior = virtual_to_segmented(0x13, m->usedObj->behavior);
 
+        if (gGravityMode) poleTop += m->usedObj->hitboxDownOffset;
+
         if (marioObj->oMarioPolePos < poleTop - 0.4f) {
             return set_mario_action(m, ACT_CLIMBING_POLE, 0);
         }
 
-        if (poleBehavior != bhvGiantPole && m->controller->stickY > 50.0f) {
+        if (poleBehavior != bhvGiantPole && (((m->controller->stickY > 50.0f) && !(gGravityMode)) || ((m->controller->stickY < -50.0f) && gGravityMode))) {
             return set_mario_action(m, ACT_TOP_OF_POLE_TRANSITION, 0);
         }
     }
 
-    if (m->controller->stickY < -16.0f) {
-        marioObj->oMarioPoleYawVel -= m->controller->stickY * 2;
+    if (((m->controller->stickY < -16.0f) && !(gGravityMode)) || ((m->controller->stickY > 16.0f) && gGravityMode)) {
+        marioObj->oMarioPoleYawVel -= m->controller->stickY * (gGravityMode ? -2 : 2);
         if (marioObj->oMarioPoleYawVel > 0x1000) {
             marioObj->oMarioPoleYawVel = 0x1000;
         }
@@ -219,17 +239,17 @@ s32 act_climbing_pole(struct MarioState *m) {
         return set_mario_action(m, ACT_WALL_KICK_AIR, 0);
     }
 
-    if (m->controller->stickY < 8.0f) {
+    if (((m->controller->stickY < 8.0f) && !(gGravityMode)) || ((m->controller->stickY > -8.0f) && gGravityMode)) {
         return set_mario_action(m, ACT_HOLDING_POLE, 0);
     }
 
-    marioObj->oMarioPolePos += m->controller->stickY / 8.0f;
+    marioObj->oMarioPolePos += (gGravityMode ? -m->controller->stickY : m->controller->stickY) / 8.0f;
     marioObj->oMarioPoleYawVel = 0;
     m->faceAngle[1] = cameraAngle - approach_s32((s16)(cameraAngle - m->faceAngle[1]), 0, 0x400, 0x400);
 
     if (set_pole_position(m, 0.0f) == POLE_NONE) {
         sp24 = m->controller->stickY / 4.0f * 0x10000;
-        set_mario_anim_with_accel(m, MARIO_ANIM_CLIMB_UP_POLE, sp24);
+        set_mario_anim_with_accel(m, MARIO_ANIM_CLIMB_UP_POLE, (gGravityMode ? -sp24: sp24));
         add_tree_leaf_particles(m);
         play_climbing_sounds(m, 1);
     }
@@ -300,7 +320,7 @@ s32 act_top_of_pole(struct MarioState *m) {
     if (m->input & INPUT_A_PRESSED) {
         return set_mario_action(m, ACT_TOP_OF_POLE_JUMP, 0);
     }
-    if (m->controller->stickY < -16.0f) {
+    if (((m->controller->stickY < -16.0f) && !(gGravityMode)) || ((m->controller->stickY > 16.0f) && gGravityMode)) {
         return set_mario_action(m, ACT_TOP_OF_POLE_TRANSITION, 1);
     }
 
@@ -400,7 +420,7 @@ s32 update_hang_moving(struct MarioState *m) {
 
     stepResult = perform_hanging_step(m, nextPos);
 
-    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(m->marioObj->header.gfx.pos, m->pos);
     vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
     return stepResult;
 }
@@ -412,7 +432,7 @@ void update_hang_stationary(struct MarioState *m) {
 
     m->pos[1] = m->ceilHeight - 160.0f;
     vec3f_copy(m->vel, gVec3fZero);
-    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(m->marioObj->header.gfx.pos, m->pos);
 #if QOL_FEATURE_BETTER_HANGING
     vec3s_set(m->marioObj->header.gfx.angle, 0x0, m->faceAngle[1], 0x0);
 #endif
@@ -604,7 +624,7 @@ void climb_up_ledge(struct MarioState *m) {
     set_mario_animation(m, MARIO_ANIM_IDLE_HEAD_LEFT);
     m->pos[0] += 14.0f * sins(m->faceAngle[1]);
     m->pos[2] += 14.0f * coss(m->faceAngle[1]);
-    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(m->marioObj->header.gfx.pos, m->pos);
 }
 
 void update_ledge_climb_camera(struct MarioState *m) {
@@ -618,6 +638,7 @@ void update_ledge_climb_camera(struct MarioState *m) {
     m->statusForCamera->pos[0] = m->pos[0] + sp4 * sins(m->faceAngle[1]);
     m->statusForCamera->pos[2] = m->pos[2] + sp4 * coss(m->faceAngle[1]);
     m->statusForCamera->pos[1] = m->pos[1];
+    if (gGravityMode) m->statusForCamera->pos[1] = 9000.f - m->pos[1]; // Update camera correctly when upside down
     m->actionTimer++;
     m->flags |= MARIO_UNKNOWN_25;
 }
@@ -643,7 +664,7 @@ s32 act_ledge_grab(struct MarioState *m) {
         m->actionTimer++;
     }
 
-    if (m->floor->normal.y < 0.9063078f) {
+    if (ABS(m->floor->normal.y) < 0.9063078f) {
         return let_go_of_ledge(m);
     }
 
@@ -753,7 +774,7 @@ s32 act_grabbed(struct MarioState *m) {
         s32 thrown = (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK6) == 0;
 
         m->faceAngle[1] = m->usedObj->oMoveAngleYaw;
-        vec3f_copy(m->pos, m->marioObj->header.gfx.pos);
+        vec3f_copy_with_gravity_switch(m->pos, m->marioObj->header.gfx.pos);
 #ifdef RUMBLE_FEEDBACK
         queue_rumble_data(5, 60);
 #endif
@@ -832,10 +853,10 @@ s32 act_in_cannon(struct MarioState *m) {
             if (m->input & INPUT_A_PRESSED) {
                 m->forwardVel = 100.0f * coss(m->faceAngle[0]);
 
-                m->vel[1] = 100.0f * sins(m->faceAngle[0]);
+                m->vel[1] = (gGravityMode ? -100.0f : 100.f) * sins(m->faceAngle[0]);
 
                 m->pos[0] += 120.0f * coss(m->faceAngle[0]) * sins(m->faceAngle[1]);
-                m->pos[1] += 120.0f * sins(m->faceAngle[0]);
+                m->pos[1] += (gGravityMode ? -120.0f : 120.f) * sins(m->faceAngle[0]);
                 m->pos[2] += 120.0f * coss(m->faceAngle[0]) * coss(m->faceAngle[1]);
 
                 play_sound(SOUND_ACTION_FLYING_FAST, m->marioObj->header.gfx.cameraToObject);
@@ -861,7 +882,7 @@ s32 act_in_cannon(struct MarioState *m) {
             }
     }
 
-    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(m->marioObj->header.gfx.pos, m->pos);
     vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
     set_mario_animation(m, MARIO_ANIM_DIVE);
 
@@ -881,16 +902,26 @@ s32 act_tornado_twirling(struct MarioState *m) {
     f32 dx = (m->pos[0] - usedObj->oPosX) * 0.95f;
     f32 dz = (m->pos[2] - usedObj->oPosZ) * 0.95f;
 
-    if (m->vel[1] < 60.0f) {
-        m->vel[1] += 1.0f;
-    }
-
-    if ((marioObj->oMarioTornadoPosY += m->vel[1]) < 0.0f) {
-        marioObj->oMarioTornadoPosY = 0.0f;
+    if (gGravityMode) {
+        if (m->vel[1] > -60.0f)
+            m->vel[1] -= 1.0f;
+        if ((marioObj->oMarioTornadoPosY -= m->vel[1]) < 0.0f)
+            marioObj->oMarioTornadoPosY = 0.0f;
+    } else {
+        if (m->vel[1] < 60.0f)
+            m->vel[1] += 1.0f;
+        if ((marioObj->oMarioTornadoPosY += m->vel[1]) < 0.0f)
+            marioObj->oMarioTornadoPosY = 0.0f;
     }
     if (marioObj->oMarioTornadoPosY > usedObj->hitboxHeight) {
-        if (m->vel[1] < 20.0f) {
-            m->vel[1] = 20.0f;
+        if (gGravityMode) {
+            if (m->vel[1] > -20.0f) {
+                m->vel[1] = -20.0f;
+            }
+        } else {
+            if (m->vel[1] < 20.0f) {
+                m->vel[1] = 20.0f;
+            }
         }
         return set_mario_action(m, ACT_TWIRLING, 1);
     }
@@ -910,7 +941,10 @@ s32 act_tornado_twirling(struct MarioState *m) {
 
     nextPos[0] = usedObj->oPosX + dx * cosAngleVel + dz * sinAngleVel;
     nextPos[2] = usedObj->oPosZ - dx * sinAngleVel + dz * cosAngleVel;
-    nextPos[1] = usedObj->oPosY + marioObj->oMarioTornadoPosY;
+    if (gGravityMode)
+        nextPos[1] = 9000.f - usedObj->oPosY - marioObj->oMarioTornadoPosY;
+    else
+        nextPos[1] = usedObj->oPosY + marioObj->oMarioTornadoPosY;
 
     f32_find_wall_collision(&nextPos[0], &nextPos[1], &nextPos[2], 60.0f, 50.0f);
 
@@ -940,7 +974,7 @@ s32 act_tornado_twirling(struct MarioState *m) {
         play_sound(SOUND_ACTION_TWIRL, m->marioObj->header.gfx.cameraToObject);
     }
 
-    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(m->marioObj->header.gfx.pos, m->pos);
     vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1] + m->twirlYaw, 0);
 #ifdef RUMBLE_FEEDBACK
     reset_rumble_timers_slip();
@@ -949,7 +983,12 @@ s32 act_tornado_twirling(struct MarioState *m) {
 }
 
 s32 check_common_automatic_cancels(struct MarioState *m) {
-    if (m->pos[1] < m->waterLevel - 100) {
+    if ((m->pos[1] < m->waterLevel - 100) && !(gGravityMode)) {
+        return set_water_plunge_action(m);
+    }
+    if (((9000.f - m->pos[1]) < m->waterLevel + 50.f) && (gGravityMode)) {
+        m->vel[1] = -m->vel[1];
+        gGravityMode = FALSE;
         return set_water_plunge_action(m);
     }
 
diff --git a/src/game/mario_actions_cutscene.c b/src/game/mario_actions_cutscene.c
index eb2f7a4..8879abc 100644
--- a/src/game/mario_actions_cutscene.c
+++ b/src/game/mario_actions_cutscene.c
@@ -422,7 +422,7 @@ s32 act_reading_npc_dialog(struct MarioState *m) {
             set_mario_action(m, m->heldObj == NULL ? ACT_IDLE : ACT_HOLD_IDLE, 0);
         }
     }
-    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(m->marioObj->header.gfx.pos, m->pos);
     vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
     vec3s_set(m->marioBodyState->headAngle, m->actionTimer, 0, 0);
 
@@ -437,7 +437,7 @@ s32 act_reading_npc_dialog(struct MarioState *m) {
 s32 act_waiting_for_dialog(struct MarioState *m) {
     set_mario_animation(m, m->heldObj == NULL ? MARIO_ANIM_FIRST_PERSON
                                               : MARIO_ANIM_IDLE_WITH_LIGHT_OBJ);
-    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(m->marioObj->header.gfx.pos, m->pos);
     vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
     return FALSE;
 }
@@ -544,7 +544,7 @@ s32 act_reading_sign(struct MarioState *m) {
             break;
     }
 
-    vec3f_copy(marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(marioObj->header.gfx.pos, m->pos);
     vec3s_set(marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
     return FALSE;
 }
@@ -588,7 +588,7 @@ s32 act_debug_free_move(struct MarioState *m) {
     }
 
     m->faceAngle[1] = m->intendedYaw;
-    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(m->marioObj->header.gfx.pos, m->pos);
     vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
 
     if (gPlayer1Controller->buttonPressed == A_BUTTON) {
@@ -688,7 +688,7 @@ s32 act_star_dance_water(struct MarioState *m) {
     m->faceAngle[1] = m->area->camera->yaw;
     set_mario_animation(m, m->actionState == 2 ? MARIO_ANIM_RETURN_FROM_WATER_STAR_DANCE
                                                : MARIO_ANIM_WATER_STAR_DANCE);
-    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(m->marioObj->header.gfx.pos, m->pos);
     vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
     general_star_dance_handler(m, 1);
     if (m->actionState != 2 && m->actionTimer >= 62) {
@@ -1605,7 +1605,7 @@ s32 act_squished(struct MarioState *m) {
     }
 
     // steep floor
-    if (m->floor != NULL && m->floor->normal.y < 0.5f) {
+    if (m->floor != NULL && ABS(m->floor->normal.y) < 0.5f) {
         surfAngle = atan2s(m->floor->normal.z, m->floor->normal.x);
         underSteepSurf = TRUE;
     }
@@ -1941,7 +1941,7 @@ static s32 jumbo_star_cutscene_taking_off(struct MarioState *m) {
 
     vec3f_set(m->pos, 0.0f, 307.0, marioObj->rawData.asF32[0x22]);
     update_mario_pos_for_anim(m);
-    vec3f_copy(marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(marioObj->header.gfx.pos, m->pos);
     vec3s_set(marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
 
     // not sure why they did this, probably was from being used to action
@@ -1990,7 +1990,7 @@ static s32 jumbo_star_cutscene_flying(struct MarioState *m) {
     }
 
     m->marioBodyState->handState = MARIO_HAND_RIGHT_OPEN;
-    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(m->marioObj->header.gfx.pos, m->pos);
     m->particleFlags |= PARTICLE_SPARKLES;
 
     if (m->actionTimer++ == 500) {
@@ -2238,7 +2238,7 @@ static void end_peach_cutscene_run_to_peach(struct MarioState *m) {
     set_mario_anim_with_accel(m, MARIO_ANIM_RUNNING, 0x00080000);
     play_step_sound(m, 9, 45);
 
-    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(m->marioObj->header.gfx.pos, m->pos);
     m->particleFlags |= PARTICLE_DUST;
 }
 
@@ -2544,7 +2544,7 @@ static void end_peach_cutscene_run_to_castle(struct MarioState *m) {
     set_mario_animation(m, m->actionState == 0 ? MARIO_ANIM_CREDITS_START_WALK_LOOK_UP
                                                : MARIO_ANIM_CREDITS_LOOK_BACK_THEN_RUN);
 
-    m->marioObj->header.gfx.pos[1] = end_obj_set_visual_pos(m->marioObj);
+    m->marioObj->header.gfx.pos[1] = end_obj_set_visual_pos(m->marioObj); // GRAVITY
 
     if (m->actionState == 0 && is_anim_past_end(m)) {
         m->actionState = 1;
@@ -2664,7 +2664,7 @@ static s32 act_credits_cutscene(struct MarioState *m) {
             set_camera_mode(m->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
         }
         set_mario_animation(m, MARIO_ANIM_WATER_IDLE);
-        vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+        vec3f_copy_with_gravity_switch(m->marioObj->header.gfx.pos, m->pos);
         // will copy over roll and pitch, if set
         vec3s_copy(m->marioObj->header.gfx.angle, m->faceAngle);
         m->particleFlags |= PARTICLE_BUBBLE;
diff --git a/src/game/mario_actions_moving.c b/src/game/mario_actions_moving.c
index 976d634..3710bd2 100644
--- a/src/game/mario_actions_moving.c
+++ b/src/game/mario_actions_moving.c
@@ -17,6 +17,7 @@
 #ifdef CHEATS_ACTIONS
 #include "extras/cheats.h"
 #endif
+#include "camera.h"
 
 struct LandingAction {
     s16 numFrames;
@@ -93,6 +94,11 @@ void play_step_sound(struct MarioState *m, s16 frame1, s16 frame2) {
 #if QOL_FEATURE_FAST_FLOOR_ALIGN
 void align_with_floor(struct MarioState *m) {
     struct Surface *floor = m->floor;
+    // Use a temp position so m->pos is not passed to the function
+    Vec3f tempPos;
+    vec3f_copy(tempPos,m->pos);
+    tempPos[1] = m->floorHeight;
+
     if ((floor != NULL) && (m->pos[1] < (m->floorHeight + 80.0f))) {
         m->pos[1] = m->floorHeight;  
 
@@ -100,7 +106,7 @@ void align_with_floor(struct MarioState *m) {
             Vec3f floorNormal = { floor->normal.x, floor->normal.y, floor->normal.z };
             mtxf_align_terrain_normal(sFloorAlignMatrix[m->unk00], floorNormal, m->pos, m->faceAngle[1]);
         } else {
-            mtxf_align_terrain_triangle(sFloorAlignMatrix[m->unk00], m->pos, m->faceAngle[1], 40.0f);
+            mtxf_align_terrain_triangle(sFloorAlignMatrix[m->unk00], tempPos, m->faceAngle[1], 40.0f);
         }
 
         m->marioObj->header.gfx.throwMatrix = &sFloorAlignMatrix[m->unk00];
@@ -108,8 +114,12 @@ void align_with_floor(struct MarioState *m) {
 }
 #else
 void align_with_floor(struct MarioState *m) {
-    m->pos[1] = m->floorHeight;
-    mtxf_align_terrain_triangle(sFloorAlignMatrix[m->unk00], m->pos, m->faceAngle[1], 40.0f);
+    // Use a temp position so m->pos is not passed to the function
+    Vec3f tempPos;
+    vec3f_copy(tempPos,m->pos);
+    tempPos[1] = m->floorHeight;
+
+    mtxf_align_terrain_triangle(sFloorAlignMatrix[m->unk00], tempPos, m->faceAngle[1], 40.0f);
     m->marioObj->header.gfx.throwMatrix = &sFloorAlignMatrix[m->unk00];
 }
 #endif
@@ -402,7 +412,7 @@ void update_shell_speed(struct MarioState *m) {
         m->forwardVel += 1.1f;
     } else if (m->forwardVel <= targetSpeed) {
         m->forwardVel += 1.1f - m->forwardVel / 58.0f;
-    } else if (m->floor->normal.y >= 0.95f) {
+    } else if (ABS(m->floor->normal.y) >= 0.95f) {
         m->forwardVel -= 1.0f;
     }
 
@@ -478,7 +488,7 @@ void update_walking_speed(struct MarioState *m) {
         m->forwardVel += 1.1f;
     } else if (m->forwardVel <= targetSpeed) {
         m->forwardVel += 1.1f - m->forwardVel / 43.0f;
-    } else if (m->floor->normal.y >= 0.95f) {
+    } else if (ABS(m->floor->normal.y) >= 0.95f) {
         m->forwardVel -= 1.0f;
     }
 
@@ -563,7 +573,7 @@ s32 begin_braking_action(struct MarioState *m) {
         return set_mario_action(m, ACT_STANDING_AGAINST_WALL, 0);
     }
 
-    if (m->forwardVel >= 16.0f && m->floor->normal.y >= 0.17364818f) {
+    if (m->forwardVel >= 16.0f && ABS(m->floor->normal.y) >= 0.17364818f) {
         return set_mario_action(m, ACT_BRAKING, 0);
     }
 
@@ -828,7 +838,7 @@ void tilt_body_ground_shell(struct MarioState *m, s16 startYaw) {
     val0C->headAngle[2] = -val0C->torsoAngle[2];
 
     marioObj->header.gfx.angle[2] = val0C->torsoAngle[2];
-    marioObj->header.gfx.pos[1] += 45.0f;
+    marioObj->header.gfx.pos[1] += (gGravityMode ? -45.0f : 45.0f);
 }
 
 s32 act_walking(struct MarioState *m) {
@@ -1789,6 +1799,8 @@ s32 act_death_exit_land(struct MarioState *m) {
         set_mario_action(m, ACT_IDLE, 0);
     }
 
+    m->marioObj->header.gfx.angle[2] = 0;
+
     return FALSE;
 }
 
@@ -1839,7 +1851,7 @@ s32 common_landing_cancels(struct MarioState *m, struct LandingAction *landingAc
     // if Mario is actually on the floor. This leads to e.g. remote sliding.
 #endif
 
-    if (m->floor->normal.y < 0.2923717f) {
+    if (ABS(m->floor->normal.y) < 0.2923717f) {
         return mario_push_off_steep_floor(m, landingAction->verySteepAction, 0);
     }
 
@@ -2032,7 +2044,12 @@ s32 act_hold_quicksand_jump_land(struct MarioState *m) {
 }
 
 s32 check_common_moving_cancels(struct MarioState *m) {
-    if (m->pos[1] < m->waterLevel - 100) {
+    if ((m->pos[1] < m->waterLevel - 100) && !(gGravityMode)) {
+        return set_water_plunge_action(m);
+    }
+    if (((9000.f - m->pos[1]) < m->waterLevel + 50.f) && (gGravityMode)) {
+        m->vel[1] = -m->vel[1];
+        gGravityMode = FALSE;
         return set_water_plunge_action(m);
     }
 
diff --git a/src/game/mario_actions_object.c b/src/game/mario_actions_object.c
index c7341eb..a6a79f4 100644
--- a/src/game/mario_actions_object.c
+++ b/src/game/mario_actions_object.c
@@ -9,6 +9,7 @@
 #include "interaction.h"
 #include "engine/math_util.h"
 #include "rumble_init.h"
+#include "engine/surface_collision.h"
 
 /**
  * Used by act_punching() to determine Mario's forward velocity during each
@@ -439,8 +440,12 @@ s32 act_releasing_bowser(struct MarioState *m) {
 }
 
 s32 check_common_object_cancels(struct MarioState *m) {
-    f32 waterSurface = m->waterLevel - 100;
-    if (m->pos[1] < waterSurface) {
+    if ((m->pos[1] < m->waterLevel - 100) && !(gGravityMode)) {
+        return set_water_plunge_action(m);
+    }
+    if (((9000.f - m->pos[1]) < m->waterLevel + 50.f) && (gGravityMode)) {
+        m->vel[1] = -m->vel[1];
+        gGravityMode = FALSE;
         return set_water_plunge_action(m);
     }
 
diff --git a/src/game/mario_actions_stationary.c b/src/game/mario_actions_stationary.c
index 597e41d..5bfdc69 100644
--- a/src/game/mario_actions_stationary.c
+++ b/src/game/mario_actions_stationary.c
@@ -16,10 +16,11 @@
 #include "sound_init.h"
 #include "surface_terrains.h"
 #include "rumble_init.h"
+#include "engine/surface_collision.h"
 
 s32 check_common_idle_cancels(struct MarioState *m) {
     mario_drop_held_object(m);
-    if (m->floor->normal.y < 0.29237169f) {
+    if (ABS(m->floor->normal.y) < 0.29237169f) {
         return mario_push_off_steep_floor(m, ACT_FREEFALL, 0);
     }
 
@@ -60,7 +61,7 @@ s32 check_common_idle_cancels(struct MarioState *m) {
 }
 
 s32 check_common_hold_idle_cancels(struct MarioState *m) {
-    if (m->floor->normal.y < 0.29237169f) {
+    if (ABS(m->floor->normal.y) < 0.29237169f) {
         return mario_push_off_steep_floor(m, ACT_HOLD_FREEFALL, 0);
     }
 
@@ -821,7 +822,7 @@ s32 act_shockwave_bounce(struct MarioState *m) {
         m->pos[1] = m->floorHeight - sins(sp1E) * sp18;
     }
 
-    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(m->marioObj->header.gfx.pos, m->pos);
     vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
     set_mario_animation(m, MARIO_ANIM_A_POSE);
     return FALSE;
@@ -1081,13 +1082,18 @@ s32 act_first_person(struct MarioState *m) {
 }
 
 s32 check_common_stationary_cancels(struct MarioState *m) {
-    if (m->pos[1] < m->waterLevel - 100) {
+    if ((m->pos[1] < m->waterLevel - 100) && !(gGravityMode)) {
         if (m->action == ACT_SPAWN_SPIN_LANDING) {
             load_level_init_text(0);
         }
         update_mario_sound_and_camera(m);
         return set_water_plunge_action(m);
     }
+    if (((9000.f - m->pos[1]) < m->waterLevel + 50.f) && (gGravityMode)) {
+        m->vel[1] = -m->vel[1];
+        gGravityMode = FALSE;
+        return set_water_plunge_action(m);
+    }
 
     if (m->input & INPUT_SQUISHED) {
         update_mario_sound_and_camera(m);
diff --git a/src/game/mario_actions_submerged.c b/src/game/mario_actions_submerged.c
index 854fe11..11e6f02 100644
--- a/src/game/mario_actions_submerged.c
+++ b/src/game/mario_actions_submerged.c
@@ -181,14 +181,18 @@ static u32 perform_water_step(struct MarioState *m) {
     nextPos[1] = m->pos[1] + step[1];
     nextPos[2] = m->pos[2] + step[2];
 
-    if (nextPos[1] > m->waterLevel - 80) {
-        nextPos[1] = m->waterLevel - 80;
+    if ((gIsGravityFlipped) && (nextPos[1] > m->waterLevel - 80.f)) {
+        set_mario_action(m, ACT_FREEFALL, 0);
         m->vel[1] = 0.0f;
+        m->pos[1] = 8835.f - m->pos[1];
+        gGravityMode = TRUE;
+        set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+        return WATER_STEP_CANCELLED;
     }
 
     stepResult = perform_water_full_step(m, nextPos);
 
-    vec3f_copy(marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(marioObj->header.gfx.pos, m->pos);
     vec3s_set(marioObj->header.gfx.angle, -m->faceAngle[0], m->faceAngle[1], m->faceAngle[2]);
 
     return stepResult;
@@ -199,7 +203,7 @@ static BAD_RETURN(u32) update_water_pitch(struct MarioState *m) {
 
     if (marioObj->header.gfx.angle[0] > 0) {
         marioObj->header.gfx.pos[1] +=
-            60.0f * sins(marioObj->header.gfx.angle[0]) * sins(marioObj->header.gfx.angle[0]);
+            60.0f * sins(marioObj->header.gfx.angle[0]) * sins(marioObj->header.gfx.angle[0]); // GRAVITY
     }
 
     if (marioObj->header.gfx.angle[0] < 0) {
@@ -428,7 +432,7 @@ static void reset_bob_variables(struct MarioState *m) {
 static void surface_swim_bob(struct MarioState *m) {
     if (sBobIncrement != 0 && m->pos[1] > m->waterLevel - 85 && m->faceAngle[0] >= 0) {
         if ((sBobTimer += sBobIncrement) >= 0) {
-            m->marioObj->header.gfx.pos[1] += sBobHeight * sins(sBobTimer);
+            m->marioObj->header.gfx.pos[1] += sBobHeight * sins(sBobTimer); // GRAVITY
             return;
         }
     }
@@ -1100,7 +1104,7 @@ static s32 act_caught_in_whirlpool(struct MarioState *m) {
     m->faceAngle[1] = atan2s(dz, dx) + 0x8000;
 
     set_mario_animation(m, MARIO_ANIM_GENERAL_FALL);
-    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(m->marioObj->header.gfx.pos, m->pos);
     vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
 #ifdef RUMBLE_FEEDBACK
     reset_rumble_timers_slip();
@@ -1131,7 +1135,7 @@ static void update_metal_water_walking_speed(struct MarioState *m) {
         m->forwardVel += 1.1f;
     } else if (m->forwardVel <= val) {
         m->forwardVel += 1.1f - m->forwardVel / 43.0f;
-    } else if (m->floor->normal.y >= 0.95f) {
+    } else if (ABS(m->floor->normal.y) >= 0.95f) {
         m->forwardVel -= 1.0f;
     }
 
diff --git a/src/game/mario_misc.c b/src/game/mario_misc.c
index 43153ea..1db56bd 100644
--- a/src/game/mario_misc.c
+++ b/src/game/mario_misc.c
@@ -31,6 +31,7 @@
 #ifdef BETTERCAMERA
 #include "extras/bettercamera.h"
 #endif
+#include "engine/surface_collision.h"
 
 #define TOAD_STAR_1_REQUIREMENT 12
 #define TOAD_STAR_2_REQUIREMENT 25
diff --git a/src/game/mario_step.c b/src/game/mario_step.c
index 0ddca14..19a08fb 100644
--- a/src/game/mario_step.c
+++ b/src/game/mario_step.c
@@ -240,7 +240,7 @@ void stop_and_set_height_to_floor(struct MarioState *m) {
     //! This is responsible for some downwarps.
     m->pos[1] = m->floorHeight;
 
-    vec3f_copy(marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(marioObj->header.gfx.pos, m->pos);
     vec3s_set(marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
 }
 
@@ -265,7 +265,7 @@ s32 stationary_ground_step(struct MarioState *m) {
         //! This is responsible for several stationary downwarps.
         m->pos[1] = m->floorHeight;
 
-        vec3f_copy(marioObj->header.gfx.pos, m->pos);
+        vec3f_copy_with_gravity_switch(marioObj->header.gfx.pos, m->pos);
         vec3s_set(marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
     }
 
@@ -298,7 +298,7 @@ static s32 perform_ground_quarter_step(struct MarioState *m, Vec3f nextPos) {
         return GROUND_STEP_HIT_WALL_STOP_QSTEPS;
     }
 
-    if ((m->action & ACT_FLAG_RIDING_SHELL) && floorHeight < waterLevel) {
+    if ((m->action & ACT_FLAG_RIDING_SHELL) && floorHeight < waterLevel && !gGravityMode) {
         floorHeight = waterLevel;
         floor = &gWaterSurfacePseudoFloor;
 #if QOL_FIX_SHELL_SPEED_NEGATIVE_OFFSET
@@ -359,8 +359,8 @@ s32 perform_ground_step(struct MarioState *m) {
     Vec3f intendedPos;
 
     for (i = 0; i < 4; i++) {
-        intendedPos[0] = m->pos[0] + m->floor->normal.y * (m->vel[0] / 4.0f);
-        intendedPos[2] = m->pos[2] + m->floor->normal.y * (m->vel[2] / 4.0f);
+        intendedPos[0] = m->pos[0] + ABS(m->floor->normal.y) * (m->vel[0] / 4.0f);
+        intendedPos[2] = m->pos[2] + ABS(m->floor->normal.y) * (m->vel[2] / 4.0f);
         intendedPos[1] = m->pos[1];
 
         stepResult = perform_ground_quarter_step(m, intendedPos);
@@ -370,7 +370,7 @@ s32 perform_ground_step(struct MarioState *m) {
     }
 
     m->terrainSoundAddend = mario_get_terrain_sound_addend(m);
-    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(m->marioObj->header.gfx.pos, m->pos);
     vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
 
     if (stepResult == GROUND_STEP_HIT_WALL_CONTINUE_QSTEPS) {
@@ -455,7 +455,7 @@ s32 perform_air_quarter_step(struct MarioState *m, Vec3f intendedPos, u32 stepAr
         return AIR_STEP_HIT_WALL;
     }
 
-    if ((m->action & ACT_FLAG_RIDING_SHELL) && floorHeight < waterLevel) {
+    if ((m->action & ACT_FLAG_RIDING_SHELL) && floorHeight < waterLevel && !gGravityMode) {
         floorHeight = waterLevel;
         floor = &gWaterSurfacePseudoFloor;
 #if QOL_FIX_SHELL_SPEED_NEGATIVE_OFFSET
@@ -696,7 +696,7 @@ s32 perform_air_step(struct MarioState *m, u32 stepArg) {
     }
     apply_vertical_wind(m);
 
-    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
+    vec3f_copy_with_gravity_switch(m->marioObj->header.gfx.pos, m->pos);
     vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
 
     return stepResult;
diff --git a/src/game/object_helpers.c b/src/game/object_helpers.c
index c4575a7..fded24c 100644
--- a/src/game/object_helpers.c
+++ b/src/game/object_helpers.c
@@ -1088,7 +1088,7 @@ static void cur_obj_move_after_thrown_or_dropped(f32 forwardVel, f32 velY) {
     }
 
     o->oForwardVel = forwardVel;
-    o->oVelY = velY;
+    o->oVelY = (gIsGravityFlipped ? -velY : velY);
 
     if (o->oForwardVel != 0) {
         cur_obj_move_y(/*gravity*/ -4.0f, /*bounciness*/ -0.1f, /*buoyancy*/ 2.0f);
diff --git a/src/game/object_list_processor.c b/src/game/object_list_processor.c
index 87dd3d6..d08dcf6 100644
--- a/src/game/object_list_processor.c
+++ b/src/game/object_list_processor.c
@@ -20,6 +20,9 @@
 #include "profiler.h"
 #include "spawn_object.h"
 
+#include "audio/external.h"
+#include "ingame_menu.h"
+#include "game_init.h"
 
 /**
  * Flags controlling what debug info is displayed.
@@ -239,7 +242,7 @@ void copy_mario_state_to_object(void) {
     gCurrentObject->oVelZ = gMarioStates[i].vel[2];
 
     gCurrentObject->oPosX = gMarioStates[i].pos[0];
-    gCurrentObject->oPosY = gMarioStates[i].pos[1];
+    gCurrentObject->oPosY = (gGravityMode ? 9000.f - gMarioStates[i].pos[1] : gMarioStates[i].pos[1]);
     gCurrentObject->oPosZ = gMarioStates[i].pos[2];
 
     gCurrentObject->oMoveAnglePitch = gCurrentObject->header.gfx.angle[0];
@@ -273,6 +276,43 @@ void spawn_particle(u32 activeParticleFlag, s16 model, const BehaviorScript *beh
 void bhv_mario_update(void) {
     u32 particleFlags = 0;
     s32 i;
+    u32 val4 = get_dialog_id() >= 0;
+    u32 intangible = (gMarioState->action & ACT_FLAG_INTANGIBLE) != 0;
+
+    if (!intangible && !val4 && !gWarpTransition.isActive && sDelayedWarpOp == WARP_OP_NONE
+        && (gPlayer1Controller->buttonPressed & L_TRIG)) {
+        gIsGravityFlipped = !gIsGravityFlipped;
+
+        if (gIsGravityFlipped)
+            play_sound(SOUND_MENU_CAMERA_ZOOM_IN, gMarioObject->header.gfx.pos);
+        else
+            play_sound(SOUND_MENU_CAMERA_ZOOM_OUT, gMarioObject->header.gfx.pos);
+
+        if (!(gMarioState->action & ACT_FLAG_SWIMMING)) {
+            gMarioState->pos[1] = 8835.f - gMarioState->pos[1]; // Transform position. The extra 165 is due to Mario's visual model.
+
+            if ((gMarioState->action == ACT_CRAZY_BOX_BOUNCE) || (gMarioState->action == ACT_SHOT_FROM_CANNON))
+                gMarioState->pos[1] += 165.f;
+            else if ((gMarioState->action == ACT_DIVE) || (gMarioState->action == ACT_FLYING))
+                gMarioState->pos[1] += 65.f;
+
+            // Either increase or decrease tornado y pos by 165 depending on flip
+            if (gMarioState->action == ACT_TORNADO_TWIRLING)
+                gMarioState->marioObj->oMarioTornadoPosY += (gIsGravityFlipped * 330.f) - 165.f;
+
+            gMarioState->vel[1] = -gMarioState->vel[1]; // Flip velocity
+            gMarioState->peakHeight = 9000.f - gMarioState->peakHeight; // For fall damage
+        }
+        if (gMarioState->action & ACT_FLAG_ON_POLE) {
+            if (gIsGravityFlipped)
+                gMarioState->marioObj->oMarioPolePos = gMarioState->usedObj->oPosY - (9000.f - gMarioState->pos[1]) + gMarioState->usedObj->hitboxHeight + 100.f;
+            else
+                gMarioState->marioObj->oMarioPolePos = gMarioState->pos[1] - gMarioState->usedObj->oPosY;
+        }
+    }
+
+    if (!(gMarioState->action & ACT_FLAG_SWIMMING))
+        gGravityMode = gIsGravityFlipped;
 
     particleFlags = execute_mario_action(gCurrentObject);
     gCurrentObject->oMarioParticleFlags = particleFlags;
@@ -290,6 +330,11 @@ void bhv_mario_update(void) {
 
         i++;
     }
+
+    if ((gGravityMode) && (gMarioState->action != ACT_CRAZY_BOX_BOUNCE) && (gMarioState->action != ACT_SHOT_FROM_CANNON))
+        gMarioObject->header.gfx.angle[2] += 0x8000; // Turn Mario upside down
+
+    gGravityMode = FALSE; // Gravity must only be flipped when checking Mario's collision, not other objects.
 }
 
 /**
diff --git a/src/game/platform_displacement.c b/src/game/platform_displacement.c
index a8adc31..771a672 100644
--- a/src/game/platform_displacement.c
+++ b/src/game/platform_displacement.c
@@ -38,9 +38,11 @@ void update_mario_platform(void) {
     //  of displacement since he is considered to be far from the platform's
     //  axis of rotation.
 
-    marioX = gMarioObject->oPosX;
-    marioY = gMarioObject->oPosY;
-    marioZ = gMarioObject->oPosZ;
+    gGravityMode = gIsGravityFlipped; // This does not take place during Mario's update function, so flip gravity again
+
+    marioX = gMarioState->pos[0];
+    marioY = gMarioState->pos[1];
+    marioZ = gMarioState->pos[2];
     floorHeight = find_floor(marioX, marioY, marioZ, &floor);
 
     if (absf(marioY - floorHeight) < 4.0f) {
@@ -65,6 +67,8 @@ void update_mario_platform(void) {
             }
             break;
     }
+    
+    gGravityMode = 0; // Reset gravity
 }
 
 /**
diff --git a/src/game/shadow.c b/src/game/shadow.c
index 77f0f5d..8102d83 100644
--- a/src/game/shadow.c
+++ b/src/game/shadow.c
@@ -213,7 +213,7 @@ s8 init_shadow(struct Shadow *s, f32 xPos, f32 yPos, f32 zPos, s16 shadowScale,
     s->parentY = yPos;
     s->parentZ = zPos;
 
-    s->floorHeight = find_floor_height_and_data(s->parentX, s->parentY, s->parentZ, &floorGeometry);
+    s->floorHeight = find_floor_height_and_data(s->parentX, s->parentY-70.f, s->parentZ, &floorGeometry); // awful hack
 
     if (gEnvironmentRegions != NULL) {
         waterLevel = get_water_level_below_shadow(s);
@@ -393,7 +393,7 @@ void calculate_vertex_xyz(s8 index, struct Shadow s, f32 *xPosVtx, f32 *yPosVtx,
                 // Clamp this vertex's y-position to that of the floor directly
                 // below it, which may differ from the floor below the center
                 // vertex.
-                *yPosVtx = find_floor_height_and_data(*xPosVtx, s.parentY, *zPosVtx, &dummy);
+                *yPosVtx = find_floor_height_and_data(*xPosVtx, s.parentY-70.f, *zPosVtx, &dummy); // awful hack
                 break;
             case SHADOW_WITH_4_VERTS:
                 // Do not clamp. Instead, extrapolate the y-position of this
