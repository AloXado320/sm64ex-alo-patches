diff --git a/include/config.h b/include/config.h
index 1a654e1..9c3b67b 100644
--- a/include/config.h
+++ b/include/config.h
@@ -2,6 +2,8 @@
 
 #define CONFIG_H
 
+#include "qol_ultra_fixes.h"
+
 /**
  * @file config.h
  * A catch-all file for configuring various bugfixes and other settings
diff --git a/include/qol_ultra_fixes.h b/include/qol_ultra_fixes.h
new file mode 100644
index 0000000..9d0aaac
--- /dev/null
+++ b/include/qol_ultra_fixes.h
@@ -0,0 +1,35 @@
+#ifndef QOL_ULTRA_FIXES_H
+#define QOL_ULTRA_FIXES_H
+
+// Quality of life ULTRA fixes
+// Mostly a compilation of code provided by a few people
+// Main difference between the ordinary QOL fixes, is that it fixes
+// most of Mario's physics that are considered remarkable, and also
+// fixes oversights used in speedruns
+// Only use this if you REALLY want SM64 to be as bug-free as possible
+#define QOL_U_FIXES TRUE
+
+/// Fixes backwards long jump, preveting Mario from getting negative speeds
+#define QOL_U_FIX_BACKWARDS_LONG_JUMP (0 || QOL_U_FIXES)
+/// Fixes and changes how "Blast away the wall" is obtained, fixing it's skip
+#define QOL_U_FIX_BLAST_AWAY_WALL (0 || QOL_U_FIXES)
+/// Fixes lakitu skip at the beginning of the game
+#define QOL_U_FIX_LAKITU_INTRO_SKIP (0 || QOL_U_FIXES)
+/// Fixes platform rising on Wii (if you plan to inject the rom)
+#define QOL_U_FIX_RISING_FLATFORM_WII (0 || QOL_U_FIXES)
+/// Fixes bob-omb behavior, so now after throwing it becomes intangible
+#define QOL_U_FIX_BOBOMB_INTANGIBLE (0 || QOL_U_FIXES)
+/// Fixes Mario still alive after getting shot by a cannon even while 0 hp
+#define QOL_U_FIX_ZOMBIE_MARIO_CANNON (0 || QOL_U_FIXES)
+/// Fixes hands-free holding glitch, more info in it's code comment
+#define QOL_U_FIX_HANDS_FREE_HOLDING (0 || QOL_U_FIXES)
+/// Fixes triple jump on slopes
+#define QOL_U_FIX_TRIPLE_JUMP_SLOPES (0 || QOL_U_FIXES)
+/// Fixes kick while holding jump on slopes
+#define QOL_U_FIX_KICKING_SLOPES (0 || QOL_U_FIXES)
+/// Fixes shell negative hyperspeed
+#define QOL_U_FIX_NEGATIVE_SHELL_SPEED (0 || QOL_U_FIXES)
+/// Fixes potential wallkick hyperspeed
+#define QOL_U_FIX_SPEED_WALLKICK (0 || QOL_U_FIXES)
+
+#endif // QOL_ULTRA_FIXES_H
diff --git a/levels/wf/script.c b/levels/wf/script.c
index 6697b49..0661ea0 100644
--- a/levels/wf/script.c
+++ b/levels/wf/script.c
@@ -40,7 +40,11 @@ static const LevelScript script_func_local_2[] = {
     OBJECT(/*model*/ MODEL_WF_SLIDING_PLATFORM,         /*pos*/  3328, 1075,  -767, /*angle*/ 0,  90, 0, /*behParam*/ 0x00010000, /*beh*/ bhvWfSlidingPlatform),
     OBJECT(/*model*/ MODEL_WF_SLIDING_PLATFORM,         /*pos*/  3328, 1075, -2815, /*angle*/ 0,  90, 0, /*behParam*/ 0x00030000, /*beh*/ bhvWfSlidingPlatform),
     OBJECT(/*model*/ MODEL_WF_TUMBLING_BRIDGE,          /*pos*/  1792, 2496,  1600, /*angle*/ 0,   0, 0, /*behParam*/ 0x00000000, /*beh*/ bhvWfTumblingBridge),
+#if QOL_U_FIX_BLAST_AWAY_WALL
+    OBJECT(/*model*/ MODEL_WF_BREAKABLE_WALL_RIGHT,     /*pos*/   512, 2176,  2944, /*angle*/ 0,   0, 0, /*behParam*/ 0x05000000, /*beh*/ bhvWfBreakableWallRight),
+#else
     OBJECT(/*model*/ MODEL_WF_BREAKABLE_WALL_RIGHT,     /*pos*/   512, 2176,  2944, /*angle*/ 0,   0, 0, /*behParam*/ 0x00000000, /*beh*/ bhvWfBreakableWallRight),
+#endif
     OBJECT(/*model*/ MODEL_WF_BREAKABLE_WALL_LEFT,      /*pos*/ -1023, 2176,  2944, /*angle*/ 0,   0, 0, /*behParam*/ 0x00000000, /*beh*/ bhvWfBreakableWallLeft),
     OBJECT_WITH_ACTS(/*model*/ MODEL_WF_KICKABLE_BOARD,           /*pos*/    13, 3584, -1407, /*angle*/ 0, 315, 0, /*behParam*/ 0x00000000, /*beh*/ bhvKickableBoard, /*acts*/ ACT_2 | ACT_3 | ACT_4 | ACT_5 | ACT_6),
     OBJECT_WITH_ACTS(/*model*/ MODEL_1UP,                         /*pos*/  -384, 3584,     6, /*angle*/ 0,   0, 0, /*behParam*/ 0x00000000, /*beh*/ bhv1Up,            /*acts*/ ACT_2 | ACT_3 | ACT_4 | ACT_5 | ACT_6),
@@ -87,7 +91,9 @@ static const LevelScript script_func_local_4[] = {
     OBJECT_WITH_ACTS(/*model*/ MODEL_STAR,  /*pos*/ -2500, 1500, -750, /*angle*/ 0, 0, 0, /*behParam*/ 0x02000000, /*beh*/ bhvStar,                 /*acts*/ ALL_ACTS),
     OBJECT_WITH_ACTS(/*model*/ MODEL_NONE,  /*pos*/  4600,  550, 2500, /*angle*/ 0, 0, 0, /*behParam*/ 0x03000000, /*beh*/ bhvHiddenRedCoinStar, /*acts*/ ALL_ACTS),
     OBJECT_WITH_ACTS(/*model*/ MODEL_STAR,  /*pos*/  2880, 4300,  190, /*angle*/ 0, 0, 0, /*behParam*/ 0x04000000, /*beh*/ bhvStar,                 /*acts*/ ALL_ACTS),
+#if !QOL_U_FIX_BLAST_AWAY_WALL
     OBJECT_WITH_ACTS(/*model*/ MODEL_STAR,  /*pos*/   590, 2450, 2650, /*angle*/ 0, 0, 0, /*behParam*/ 0x05000000, /*beh*/ bhvStar,                 /*acts*/ ALL_ACTS),
+#endif
     RETURN(),
 };
 
diff --git a/src/game/behaviors/bobomb.inc.c b/src/game/behaviors/bobomb.inc.c
index 2e3a314..0a4ae5c 100644
--- a/src/game/behaviors/bobomb.inc.c
+++ b/src/game/behaviors/bobomb.inc.c
@@ -29,6 +29,9 @@ void bobomb_spawn_coin(void) {
 
 void bobomb_act_explode(void) {
     struct Object *explosion;
+#if QOL_U_FIX_BOBOMB_INTANGIBLE
+    cur_obj_become_intangible();
+#endif
     if (o->oTimer < 5)
         cur_obj_scale(1.0 + (f32) o->oTimer / 5.0);
     else {
@@ -100,6 +103,9 @@ void bobomb_act_chase_mario(void) {
 void bobomb_act_launched(void) {
     s16 collisionFlags = 0;
     collisionFlags = object_step();
+#if QOL_U_FIX_BOBOMB_INTANGIBLE
+    cur_obj_become_intangible();
+#endif
     if ((collisionFlags & OBJ_COL_FLAG_GROUNDED) == OBJ_COL_FLAG_GROUNDED)
         o->oAction = BOBOMB_ACT_EXPLODE; /* bit 0 */
 }
diff --git a/src/game/behaviors/breakable_wall.inc.c b/src/game/behaviors/breakable_wall.inc.c
index dbb92c8..9cba280 100644
--- a/src/game/behaviors/breakable_wall.inc.c
+++ b/src/game/behaviors/breakable_wall.inc.c
@@ -5,6 +5,9 @@ void bhv_wf_breakable_wall_loop(void) {
         cur_obj_become_tangible();
         if (obj_check_if_collided_with_object(o, gMarioObject)) {
             if (cur_obj_has_behavior(bhvWfBreakableWallRight))
+                #if QOL_U_FIX_BLAST_AWAY_WALL   
+                spawn_default_star(590.0f, 2450.0f, 2650.0f);
+                #endif
                 play_puzzle_jingle();
             create_sound_spawner(SOUND_GENERAL_WALL_EXPLOSION);
             o->oInteractType = 8;
diff --git a/src/game/behaviors/camera_lakitu.inc.c b/src/game/behaviors/camera_lakitu.inc.c
index c3e7f44..ba3fc3a 100644
--- a/src/game/behaviors/camera_lakitu.inc.c
+++ b/src/game/behaviors/camera_lakitu.inc.c
@@ -28,7 +28,11 @@ void bhv_camera_lakitu_init(void) {
 static void camera_lakitu_intro_act_trigger_cutscene(void) {
     //! These bounds are slightly smaller than the actual bridge bounds, allowing
     //  the RTA speedrunning method of lakitu skip
+#if QOL_U_FIX_LAKITU_INTRO_SKIP
+    if (gMarioObject->oPosX > -555.0f && gMarioObject->oPosX < 555.0f && gMarioObject->oPosY > 800.0f
+#else
     if (gMarioObject->oPosX > -544.0f && gMarioObject->oPosX < 545.0f && gMarioObject->oPosY > 800.0f
+#endif
         && gMarioObject->oPosZ > -2000.0f && gMarioObject->oPosZ < -177.0f
         && gMarioObject->oPosZ < -177.0f) // always double check your conditions
     {
diff --git a/src/game/behaviors/falling_rising_platform.inc.c b/src/game/behaviors/falling_rising_platform.inc.c
index 4bd7ecd..10eccc3 100644
--- a/src/game/behaviors/falling_rising_platform.inc.c
+++ b/src/game/behaviors/falling_rising_platform.inc.c
@@ -8,7 +8,11 @@ void bhv_squishable_platform_loop(void) {
 void bhv_bitfs_sinking_platform_loop(void) {
     o->oPosY -=
         sins(o->oPlatformTimer)
+#if QOL_U_FIX_RISING_FLATFORM_WII
+        * 0.58f;
+#else
         * 0.58; //! f32 double conversion error accumulates on Wii VC causing the platform to rise up
+#endif
     o->oPlatformTimer += 0x100;
 }
 
diff --git a/src/game/interaction.c b/src/game/interaction.c
index 51609e0..2f3d51d 100644
--- a/src/game/interaction.c
+++ b/src/game/interaction.c
@@ -1057,7 +1057,11 @@ u32 interact_door(struct MarioState *m, UNUSED u32 interactType, struct Object *
 }
 
 u32 interact_cannon_base(struct MarioState *m, UNUSED u32 interactType, struct Object *o) {
-    if (m->action != ACT_IN_CANNON) {
+    if (m->action != ACT_IN_CANNON
+#if QOL_U_FIX_ZOMBIE_MARIO_CANNON
+    && m->health >= 0x100
+#endif
+    ) {
         mario_stop_riding_and_holding(m);
         o->oInteractStatus = INT_STATUS_INTERACTED;
         m->interactObj = o;
diff --git a/src/game/mario_actions_airborne.c b/src/game/mario_actions_airborne.c
index 02a8fb5..312cf01 100644
--- a/src/game/mario_actions_airborne.c
+++ b/src/game/mario_actions_airborne.c
@@ -412,12 +412,20 @@ u32 common_air_action_step(struct MarioState *m, u32 landAction, s32 animation,
                     // not able to ledge grab it.
                     if (m->forwardVel >= 38.0f) {
                         m->particleFlags |= PARTICLE_VERTICAL_STAR;
+                        #if QOL_U_FIX_HANDS_FREE_HOLDING
+                        drop_and_set_mario_action(m, ACT_BACKWARD_AIR_KB, 0);
+                        #else
                         set_mario_action(m, ACT_BACKWARD_AIR_KB, 0);
+                        #endif
                     } else {
                         if (m->forwardVel > 8.0f) {
                             mario_set_forward_vel(m, -8.0f);
                         }
+                        #if QOL_U_FIX_HANDS_FREE_HOLDING
+                        drop_and_set_mario_action(m, ACT_SOFT_BONK, 0);
+                        #else
                         return set_mario_action(m, ACT_SOFT_BONK, 0);
+                        #endif
                     }
                 }
             } else {
@@ -1314,6 +1322,9 @@ s32 act_air_hit_wall(struct MarioState *m) {
         if (m->input & INPUT_A_PRESSED) {
             m->vel[1] = 52.0f;
             m->faceAngle[1] += 0x8000;
+            #if QOL_U_FIX_SPEED_WALLKICK
+            m->forwardVel = 0.0f;
+            #endif
             return set_mario_action(m, ACT_WALL_KICK_AIR, 0);
         }
     } else if (m->forwardVel >= 38.0f) {
diff --git a/src/game/mario_actions_moving.c b/src/game/mario_actions_moving.c
index 8c2d8a0..ad75cf8 100644
--- a/src/game/mario_actions_moving.c
+++ b/src/game/mario_actions_moving.c
@@ -151,8 +151,16 @@ void slide_bonk(struct MarioState *m, u32 fastAction, u32 slowAction) {
 s32 set_triple_jump_action(struct MarioState *m, UNUSED u32 action, UNUSED u32 actionArg) {
     if (m->flags & MARIO_WING_CAP) {
         return set_mario_action(m, ACT_FLYING_TRIPLE_JUMP, 0);
-    } else if (m->forwardVel > 20.0f) {
+    } else if (m->forwardVel > 20.0f
+#if QOL_U_FIX_TRIPLE_JUMP_SLOPES
+    && !(mario_floor_is_slope(m))
+#endif
+    ) {
         return set_mario_action(m, ACT_TRIPLE_JUMP, 0);
+#if QOL_U_FIX_TRIPLE_JUMP_SLOPES
+    } else if (mario_floor_is_slope(m)) {
+        return set_mario_action(m, ACT_JUMP, 0);
+#endif
     } else {
         return set_mario_action(m, ACT_JUMP, 0);
     }
@@ -388,6 +396,12 @@ void update_shell_speed(struct MarioState *m) {
         m->forwardVel = 64.0f;
     }
 
+#if QOL_U_FIX_NEGATIVE_SHELL_SPEED
+    if (m->forwardVel < -64.0f) {
+        m->forwardVel = -64.0f;
+    }
+#endif
+
     m->faceAngle[1] =
         m->intendedYaw - approach_s32((s16)(m->intendedYaw - m->faceAngle[1]), 0, 0x800, 0x800);
 
@@ -868,7 +882,16 @@ s32 act_move_punching(struct MarioState *m) {
     }
 
     if (m->actionState == 0 && (m->input & INPUT_A_DOWN)) {
+#if QOL_U_FIX_KICKING_SLOPES
+		if (mario_floor_is_slope(m)) {
+			return set_mario_action(m, ACT_DIVE, 0);
+		}
+		else {
+			return set_mario_action(m, ACT_JUMP_KICK, 0);
+		}
+#else
         return set_mario_action(m, ACT_JUMP_KICK, 0);
+#endif
     }
 
     m->actionState = 1;
@@ -1868,7 +1891,7 @@ s32 act_hold_freefall_land(struct MarioState *m) {
 }
 
 s32 act_long_jump_land(struct MarioState *m) {
-#ifdef VERSION_SH
+#if QOL_U_FIX_BACKWARDS_LONG_JUMP
     // BLJ (Backwards Long Jump) speed build up fix, crushing SimpleFlips's dreams since July 1997
     if (m->forwardVel < 0.0f) {
         m->forwardVel = 0.0f;
